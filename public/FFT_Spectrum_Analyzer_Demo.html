<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFTé¢‘è°±åˆ†æå™¨æ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group h3 {
            color: #495057;
            font-size: 1.2em;
            margin-bottom: 10px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group label {
            min-width: 80px;
            font-weight: 500;
            color: #495057;
        }

        .input-group input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .chart-container h3 {
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3em;
        }

        canvas {
            width: 100%;
            height: 300px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .info-panel {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .info-panel h3 {
            color: #1976d2;
            margin-bottom: 15px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .info-item h4 {
            color: #495057;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-item p {
            color: #667eea;
            font-weight: 600;
            font-size: 1.1em;
        }

        .spectrum-info {
            background: #fff3e0;
            border: 1px solid #ffcc02;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .spectrum-info h3 {
            color: #f57c00;
            margin-bottom: 15px;
        }

        .peak-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .peak-item {
            background: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #ffcc02;
        }

        .peak-item .frequency {
            font-weight: 600;
            color: #f57c00;
        }

        .peak-item .magnitude {
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 768px) {
            .visualization {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¬ FFTé¢‘è°±åˆ†æå™¨</h1>
            <p>å®æ—¶ä¿¡å·åˆ†æä¸é¢‘è°±æ˜¾ç¤ºæ¼”ç¤º</p>
        </div>

        <div class="content">
            <!-- æ§åˆ¶é¢æ¿ -->
            <div class="control-panel">
                <div class="control-group">
                    <h3>ğŸ“¡ ä¿¡å·å‚æ•°</h3>
                    <div class="input-group">
                        <label>é‡‡æ ·ç‡:</label>
                        <input type="number" id="sampleRate" value="44100" min="1000" max="192000" step="1000">
                    </div>
                    <div class="input-group">
                        <label>é‡‡æ ·ç‚¹æ•°:</label>
                        <input type="number" id="fftSize" value="2048" min="256" max="16384" step="256">
                    </div>
                    <div class="input-group">
                        <label>çª—å£ç±»å‹:</label>
                        <select id="windowType">
                            <option value="hann">æ±‰å®çª— (Hann)</option>
                            <option value="hamming">æµ·æ˜çª— (Hamming)</option>
                            <option value="blackman">å¸ƒè±å…‹æ›¼çª— (Blackman)</option>
                            <option value="rectangular">çŸ©å½¢çª— (Rectangular)</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>ğŸµ ä¿¡å·ç”Ÿæˆ</h3>
                    <div class="input-group">
                        <label>é¢‘ç‡1:</label>
                        <input type="number" id="freq1" value="440" min="1" max="20000" step="1">
                    </div>
                    <div class="input-group">
                        <label>é¢‘ç‡2:</label>
                        <input type="number" id="freq2" value="880" min="1" max="20000" step="1">
                    </div>
                    <div class="input-group">
                        <label>é¢‘ç‡3:</label>
                        <input type="number" id="freq3" value="1320" min="1" max="20000" step="1">
                    </div>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="generateSignal()">ç”Ÿæˆä¿¡å·</button>
                        <button class="btn btn-success" onclick="startRealTime()">å®æ—¶åˆ†æ</button>
                        <button class="btn btn-secondary" onclick="stopRealTime()">åœæ­¢</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>ğŸ›ï¸ æ˜¾ç¤ºè®¾ç½®</h3>
                    <div class="input-group">
                        <label>æ˜¾ç¤ºæ¨¡å¼:</label>
                        <select id="displayMode">
                            <option value="magnitude">å¹…åº¦è°±</option>
                            <option value="power">åŠŸç‡è°±</option>
                            <option value="db">åˆ†è´è°±</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Yè½´èŒƒå›´:</label>
                        <input type="number" id="yAxisMax" value="1" min="0.1" max="10" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>å³°å€¼æ£€æµ‹:</label>
                        <input type="checkbox" id="peakDetection" checked>
                    </div>
                </div>
            </div>

            <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>æ­£åœ¨è®¡ç®—FFT...</p>
            </div>

            <!-- å¯è§†åŒ–åŒºåŸŸ -->
            <div class="visualization">
                <div class="chart-container">
                    <h3>ğŸ“ˆ æ—¶åŸŸä¿¡å·</h3>
                    <canvas id="timeCanvas" width="600" height="300"></canvas>
                </div>
                <div class="chart-container">
                    <h3>ğŸ“Š é¢‘åŸŸé¢‘è°±</h3>
                    <canvas id="freqCanvas" width="600" height="300"></canvas>
                </div>
            </div>

            <!-- ä¿¡æ¯é¢æ¿ -->
            <div class="info-panel">
                <h3>ğŸ“‹ åˆ†æä¿¡æ¯</h3>
                <div class="info-grid">
                    <div class="info-item">
                        <h4>ä¿¡å·é•¿åº¦</h4>
                        <p id="signalLength">0 ms</p>
                    </div>
                    <div class="info-item">
                        <h4>é¢‘ç‡åˆ†è¾¨ç‡</h4>
                        <p id="freqResolution">0 Hz</p>
                    </div>
                    <div class="info-item">
                        <h4>å¥ˆå¥æ–¯ç‰¹é¢‘ç‡</h4>
                        <p id="nyquistFreq">0 Hz</p>
                    </div>
                    <div class="info-item">
                        <h4>è®¡ç®—æ—¶é—´</h4>
                        <p id="computeTime">0 ms</p>
                    </div>
                </div>
            </div>

            <!-- é¢‘è°±å³°å€¼ä¿¡æ¯ -->
            <div class="spectrum-info">
                <h3>ğŸ” æ£€æµ‹åˆ°çš„å³°å€¼</h3>
                <div class="peak-list" id="peakList">
                    <div class="peak-item">
                        <div class="frequency">æ— å³°å€¼</div>
                        <div class="magnitude">-</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // FFTé¢‘è°±åˆ†æå™¨ç±»
        class FFTSpectrumAnalyzer {
            constructor() {
                this.sampleRate = 44100;
                this.fftSize = 2048;
                this.windowType = 'hann';
                this.displayMode = 'magnitude';
                this.yAxisMax = 1;
                this.peakDetection = true;
                
                this.timeCanvas = document.getElementById('timeCanvas');
                this.freqCanvas = document.getElementById('freqCanvas');
                this.timeCtx = this.timeCanvas.getContext('2d');
                this.freqCtx = this.freqCanvas.getContext('2d');
                
                this.signal = [];
                this.spectrum = [];
                this.frequencies = [];
                this.realTimeMode = false;
                this.animationId = null;
                
                this.initializeEventListeners();
                this.updateInfo();
            }

            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
            initializeEventListeners() {
                // å‚æ•°å˜åŒ–ç›‘å¬
                ['sampleRate', 'fftSize', 'windowType', 'displayMode', 'yAxisMax', 'peakDetection'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => {
                        this[id] = document.getElementById(id).type === 'checkbox' ? 
                            document.getElementById(id).checked : 
                            parseFloat(document.getElementById(id).value) || document.getElementById(id).value;
                        this.updateInfo();
                        if (this.signal.length > 0) {
                            this.analyzeSignal();
                        }
                    });
                });
            }

            // ç”Ÿæˆæµ‹è¯•ä¿¡å·
            generateSignal() {
                const freq1 = parseFloat(document.getElementById('freq1').value);
                const freq2 = parseFloat(document.getElementById('freq2').value);
                const freq3 = parseFloat(document.getElementById('freq3').value);
                
                this.signal = [];
                const duration = this.fftSize / this.sampleRate;
                
                for (let i = 0; i < this.fftSize; i++) {
                    const t = i / this.sampleRate;
                    const signal1 = Math.sin(2 * Math.PI * freq1 * t);
                    const signal2 = Math.sin(2 * Math.PI * freq2 * t) * 0.7;
                    const signal3 = Math.sin(2 * Math.PI * freq3 * t) * 0.5;
                    
                    // æ·»åŠ ä¸€äº›å™ªå£°
                    const noise = (Math.random() - 0.5) * 0.1;
                    
                    this.signal.push(signal1 + signal2 + signal3 + noise);
                }
                
                this.analyzeSignal();
                this.drawTimeDomain();
            }

                         // åˆ†æä¿¡å·
             analyzeSignal() {
                 const startTime = performance.now();
                 
                 // åº”ç”¨çª—å£å‡½æ•°
                 const windowedSignal = this.applyWindow(this.signal);
                 
                 // è®¡ç®—FFT
                 const fft = this.computeFFT(windowedSignal);
                 
                 // è®¡ç®—é¢‘è°±
                 this.spectrum = this.computeSpectrum(fft);
                 
                 // è®¡ç®—é¢‘ç‡è½´
                 this.frequencies = this.computeFrequencies();
                 
                 // æ›´æ–°è®¡ç®—æ—¶é—´
                 const endTime = performance.now();
                 document.getElementById('computeTime').textContent = `${(endTime - startTime).toFixed(2)} ms`;
                 
                 // æ·»åŠ è°ƒè¯•ä¿¡æ¯
                 console.log('FFTåˆ†æç»“æœ:', {
                     signalLength: this.signal.length,
                     fftLength: fft.length,
                     spectrumLength: this.spectrum.length,
                     frequenciesLength: this.frequencies.length,
                     maxSpectrum: Math.max(...this.spectrum),
                     minSpectrum: Math.min(...this.spectrum)
                 });
                 
                 this.drawFrequencyDomain();
                 this.detectPeaks();
             }

            // åº”ç”¨çª—å£å‡½æ•°
            applyWindow(signal) {
                const windowed = new Array(signal.length);
                
                for (let i = 0; i < signal.length; i++) {
                    let windowValue = 1;
                    const normalizedIndex = i / (signal.length - 1);
                    
                    switch (this.windowType) {
                        case 'hann':
                            windowValue = 0.5 * (1 - Math.cos(2 * Math.PI * normalizedIndex));
                            break;
                        case 'hamming':
                            windowValue = 0.54 - 0.46 * Math.cos(2 * Math.PI * normalizedIndex);
                            break;
                        case 'blackman':
                            windowValue = 0.42 - 0.5 * Math.cos(2 * Math.PI * normalizedIndex) + 
                                         0.08 * Math.cos(4 * Math.PI * normalizedIndex);
                            break;
                        case 'rectangular':
                        default:
                            windowValue = 1;
                            break;
                    }
                    
                    windowed[i] = signal[i] * windowValue;
                }
                
                return windowed;
            }

                         // è®¡ç®—FFTï¼ˆä½¿ç”¨JavaScriptå®ç°çš„FFTç®—æ³•ï¼‰
             computeFFT(signal) {
                 const n = signal.length;
                 
                 // ç¡®ä¿ä¿¡å·é•¿åº¦æ˜¯2çš„å¹‚æ¬¡
                 if ((n & (n - 1)) !== 0) {
                     console.warn('ä¿¡å·é•¿åº¦ä¸æ˜¯2çš„å¹‚æ¬¡ï¼Œå¯èƒ½å½±å“FFTæ€§èƒ½');
                 }
                 
                 // åˆ›å»ºå¤æ•°æ•°ç»„
                 const complex = new Array(n);
                 for (let i = 0; i < n; i++) {
                     complex[i] = { real: signal[i], imag: 0 };
                 }
                 
                 // æ‰§è¡ŒFFT
                 this.fft(complex);
                 
                 // è®¡ç®—å¹…åº¦
                 const magnitudes = new Array(n / 2);
                 for (let i = 0; i < n / 2; i++) {
                     magnitudes[i] = Math.sqrt(complex[i].real * complex[i].real + complex[i].imag * complex[i].imag);
                 }
                 
                 return magnitudes;
             }
             
             // FFTç®—æ³•å®ç°
             fft(complex) {
                 const n = complex.length;
                 
                 // ä½åè½¬
                 for (let i = 1, j = 0; i < n; i++) {
                     let bit = n >> 1;
                     for (; j & bit; bit >>= 1) {
                         j ^= bit;
                     }
                     j ^= bit;
                     
                     if (i < j) {
                         [complex[i], complex[j]] = [complex[j], complex[i]];
                     }
                 }
                 
                 // è¶å½¢è¿ç®—
                 for (let len = 2; len <= n; len <<= 1) {
                     const angle = -2 * Math.PI / len;
                     const wlen_real = Math.cos(angle);
                     const wlen_imag = Math.sin(angle);
                     
                     for (let i = 0; i < n; i += len) {
                         let w_real = 1;
                         let w_imag = 0;
                         
                         for (let j = 0; j < len / 2; j++) {
                             const u_real = complex[i + j].real;
                             const u_imag = complex[i + j].imag;
                             const v_real = complex[i + j + len / 2].real * w_real - complex[i + j + len / 2].imag * w_imag;
                             const v_imag = complex[i + j + len / 2].real * w_imag + complex[i + j + len / 2].imag * w_real;
                             
                             complex[i + j].real = u_real + v_real;
                             complex[i + j].imag = u_imag + v_imag;
                             complex[i + j + len / 2].real = u_real - v_real;
                             complex[i + j + len / 2].imag = u_imag - v_imag;
                             
                             const next_w_real = w_real * wlen_real - w_imag * wlen_imag;
                             const next_w_imag = w_real * wlen_imag + w_imag * wlen_real;
                             w_real = next_w_real;
                             w_imag = next_w_imag;
                         }
                     }
                 }
             }

                         // è®¡ç®—é¢‘è°±
             computeSpectrum(fft) {
                 const spectrum = [];
                 const binCount = fft.length;
                 
                 // åº”ç”¨çª—å£å‡½æ•°çš„è¡¥å¿å› å­
                 let windowCompensation = 1;
                 switch (this.windowType) {
                     case 'hann':
                         windowCompensation = 2;
                         break;
                     case 'hamming':
                         windowCompensation = 1.85;
                         break;
                     case 'blackman':
                         windowCompensation = 2.8;
                         break;
                     case 'rectangular':
                     default:
                         windowCompensation = 1;
                         break;
                 }
                 
                 for (let i = 0; i < binCount; i++) {
                     let value;
                     
                     // åº”ç”¨çª—å£è¡¥å¿
                     const compensatedValue = fft[i] * windowCompensation;
                     
                     switch (this.displayMode) {
                         case 'magnitude':
                             value = compensatedValue;
                             break;
                         case 'power':
                             value = compensatedValue ** 2;
                             break;
                         case 'db':
                             value = 20 * Math.log10(compensatedValue + 1e-10);
                             break;
                         default:
                             value = compensatedValue;
                     }
                     
                     spectrum.push(value);
                 }
                 
                 return spectrum;
             }

                         // è®¡ç®—é¢‘ç‡è½´
             computeFrequencies() {
                 const frequencies = [];
                 const binCount = this.spectrum.length;
                 
                 for (let i = 0; i < binCount; i++) {
                     // FFTç»“æœåªåŒ…å«åˆ°å¥ˆå¥æ–¯ç‰¹é¢‘ç‡
                     const frequency = i * this.sampleRate / this.fftSize;
                     frequencies.push(frequency);
                 }
                 
                 return frequencies;
             }

                         // æ£€æµ‹å³°å€¼
             detectPeaks() {
                 if (!this.peakDetection || !this.spectrum || this.spectrum.length === 0) return;
                 
                 const peaks = [];
                 const maxValue = Math.max(...this.spectrum);
                 const threshold = maxValue * 0.05; // é™ä½é˜ˆå€¼ä»¥æ£€æµ‹æ›´å¤šå³°å€¼
                 
                 // å¯»æ‰¾å±€éƒ¨æœ€å¤§å€¼
                 for (let i = 2; i < this.spectrum.length - 2; i++) {
                     const current = this.spectrum[i];
                     
                     // æ£€æŸ¥æ˜¯å¦æ˜¯å±€éƒ¨æœ€å¤§å€¼
                     if (current > threshold &&
                         current > this.spectrum[i - 1] &&
                         current > this.spectrum[i - 2] &&
                         current > this.spectrum[i + 1] &&
                         current > this.spectrum[i + 2]) {
                         
                         peaks.push({
                             frequency: this.frequencies[i],
                             magnitude: current,
                             index: i
                         });
                     }
                 }
                 
                 // æŒ‰å¹…åº¦æ’åºï¼Œå–å‰5ä¸ªå³°å€¼
                 peaks.sort((a, b) => b.magnitude - a.magnitude);
                 peaks.splice(5);
                 
                 this.displayPeaks(peaks);
             }

            // æ˜¾ç¤ºå³°å€¼
            displayPeaks(peaks) {
                const peakList = document.getElementById('peakList');
                
                if (peaks.length === 0) {
                    peakList.innerHTML = '<div class="peak-item"><div class="frequency">æ— å³°å€¼</div><div class="magnitude">-</div></div>';
                    return;
                }
                
                peakList.innerHTML = peaks.map(peak => `
                    <div class="peak-item">
                        <div class="frequency">${peak.frequency.toFixed(1)} Hz</div>
                        <div class="magnitude">${peak.magnitude.toFixed(3)}</div>
                    </div>
                `).join('');
            }

            // ç»˜åˆ¶æ—¶åŸŸä¿¡å·
            drawTimeDomain() {
                const ctx = this.timeCtx;
                const width = this.timeCanvas.width;
                const height = this.timeCanvas.height;
                
                // æ¸…é™¤ç”»å¸ƒ
                ctx.clearRect(0, 0, width, height);
                
                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid(ctx, width, height, 'time');
                
                // ç»˜åˆ¶ä¿¡å·
                ctx.beginPath();
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                
                const timeStep = width / this.signal.length;
                const amplitudeScale = height / 4;
                const centerY = height / 2;
                
                for (let i = 0; i < this.signal.length; i++) {
                    const x = i * timeStep;
                    const y = centerY - this.signal[i] * amplitudeScale;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // ç»˜åˆ¶æ ‡ç­¾
                ctx.fillStyle = '#495057';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ—¶é—´ (ms)', width / 2, height - 10);
                
                ctx.save();
                ctx.translate(10, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('å¹…åº¦', 0, 0);
                ctx.restore();
            }

                         // ç»˜åˆ¶é¢‘åŸŸé¢‘è°±
             drawFrequencyDomain() {
                 const ctx = this.freqCtx;
                 const width = this.freqCanvas.width;
                 const height = this.freqCanvas.height;
                 
                 // æ¸…é™¤ç”»å¸ƒ
                 ctx.clearRect(0, 0, width, height);
                 
                 // ç»˜åˆ¶ç½‘æ ¼
                 this.drawGrid(ctx, width, height, 'frequency');
                 
                 // æ£€æŸ¥æ˜¯å¦æœ‰é¢‘è°±æ•°æ®
                 if (!this.spectrum || this.spectrum.length === 0) {
                     ctx.fillStyle = '#666';
                     ctx.font = '16px Arial';
                     ctx.textAlign = 'center';
                     ctx.fillText('æ— é¢‘è°±æ•°æ®', width / 2, height / 2);
                     return;
                 }
                 
                 // ç»˜åˆ¶é¢‘è°±
                 ctx.beginPath();
                 ctx.strokeStyle = '#28a745';
                 ctx.lineWidth = 2;
                 
                 const freqStep = width / this.spectrum.length;
                 const maxValue = Math.max(...this.spectrum);
                 const minValue = Math.min(...this.spectrum);
                 
                 // è®¡ç®—ç¼©æ”¾å› å­
                 let amplitudeScale;
                 if (this.displayMode === 'db') {
                     const range = maxValue - minValue;
                     amplitudeScale = height / (range * this.yAxisMax);
                 } else {
                     amplitudeScale = height / (maxValue * this.yAxisMax);
                 }
                 
                 for (let i = 0; i < this.spectrum.length; i++) {
                     const x = i * freqStep;
                     let y;
                     
                     if (this.displayMode === 'db') {
                         y = height - (this.spectrum[i] - minValue) * amplitudeScale;
                     } else {
                         y = height - this.spectrum[i] * amplitudeScale;
                     }
                     
                     if (i === 0) {
                         ctx.moveTo(x, y);
                     } else {
                         ctx.lineTo(x, y);
                     }
                 }
                 
                 ctx.stroke();
                 
                 // ç»˜åˆ¶é¢‘ç‡æ ‡ç­¾
                 ctx.fillStyle = '#495057';
                 ctx.font = '12px Arial';
                 ctx.textAlign = 'center';
                 
                 // ç»˜åˆ¶é¢‘ç‡åˆ»åº¦
                 const maxFreq = this.frequencies[this.frequencies.length - 1];
                 for (let i = 0; i <= 5; i++) {
                     const freq = (i / 5) * maxFreq;
                     const x = (i / 5) * width;
                     ctx.fillText(`${freq.toFixed(0)}Hz`, x, height - 5);
                 }
                 
                 // ç»˜åˆ¶Yè½´æ ‡ç­¾
                 ctx.save();
                 ctx.translate(10, height / 2);
                 ctx.rotate(-Math.PI / 2);
                 ctx.fillText(this.displayMode === 'db' ? 'å¹…åº¦ (dB)' : 'å¹…åº¦', 0, 0);
                 ctx.restore();
                 
                 // æ˜¾ç¤ºæœ€å¤§å€¼ä¿¡æ¯
                 ctx.fillStyle = '#28a745';
                 ctx.font = '10px Arial';
                 ctx.textAlign = 'left';
                 ctx.fillText(`æœ€å¤§: ${maxValue.toFixed(3)}`, 10, 20);
             }

            // ç»˜åˆ¶ç½‘æ ¼
            drawGrid(ctx, width, height, type) {
                ctx.strokeStyle = '#e9ecef';
                ctx.lineWidth = 1;
                
                // å‚ç›´ç½‘æ ¼çº¿
                const vLines = type === 'time' ? 10 : 20;
                for (let i = 0; i <= vLines; i++) {
                    const x = (i / vLines) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // æ°´å¹³ç½‘æ ¼çº¿
                const hLines = 8;
                for (let i = 0; i <= hLines; i++) {
                    const y = (i / hLines) * height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }

            // æ›´æ–°ä¿¡æ¯é¢æ¿
            updateInfo() {
                const signalLength = (this.fftSize / this.sampleRate) * 1000;
                const freqResolution = this.sampleRate / this.fftSize;
                const nyquistFreq = this.sampleRate / 2;
                
                document.getElementById('signalLength').textContent = `${signalLength.toFixed(1)} ms`;
                document.getElementById('freqResolution').textContent = `${freqResolution.toFixed(2)} Hz`;
                document.getElementById('nyquistFreq').textContent = `${nyquistFreq.toFixed(0)} Hz`;
            }

            // å¼€å§‹å®æ—¶åˆ†æ
            startRealTime() {
                if (this.realTimeMode) return;
                
                this.realTimeMode = true;
                this.animate();
            }

            // åœæ­¢å®æ—¶åˆ†æ
            stopRealTime() {
                this.realTimeMode = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            // åŠ¨ç”»å¾ªç¯
            animate() {
                if (!this.realTimeMode) return;
                
                // ç”Ÿæˆå®æ—¶ä¿¡å·
                this.generateRealTimeSignal();
                this.analyzeSignal();
                this.drawTimeDomain();
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }

            // ç”Ÿæˆå®æ—¶ä¿¡å·
            generateRealTimeSignal() {
                const freq1 = parseFloat(document.getElementById('freq1').value);
                const freq2 = parseFloat(document.getElementById('freq2').value);
                const freq3 = parseFloat(document.getElementById('freq3').value);
                
                this.signal = [];
                const time = Date.now() / 1000;
                
                for (let i = 0; i < this.fftSize; i++) {
                    const t = time + i / this.sampleRate;
                    const signal1 = Math.sin(2 * Math.PI * freq1 * t);
                    const signal2 = Math.sin(2 * Math.PI * freq2 * t) * 0.7;
                    const signal3 = Math.sin(2 * Math.PI * freq3 * t) * 0.5;
                    
                    // æ·»åŠ ä¸€äº›å™ªå£°
                    const noise = (Math.random() - 0.5) * 0.1;
                    
                    this.signal.push(signal1 + signal2 + signal3 + noise);
                }
            }
        }

        // å…¨å±€å˜é‡
        let analyzer;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            analyzer = new FFTSpectrumAnalyzer();
            
            // è®¾ç½®åˆå§‹å€¼
            analyzer.sampleRate = parseFloat(document.getElementById('sampleRate').value);
            analyzer.fftSize = parseInt(document.getElementById('fftSize').value);
            analyzer.windowType = document.getElementById('windowType').value;
            analyzer.displayMode = document.getElementById('displayMode').value;
            analyzer.yAxisMax = parseFloat(document.getElementById('yAxisMax').value);
            analyzer.peakDetection = document.getElementById('peakDetection').checked;
            
            // ç”Ÿæˆåˆå§‹ä¿¡å·
            analyzer.generateSignal();
        });

        // å…¨å±€å‡½æ•°
        function generateSignal() {
            analyzer.generateSignal();
        }

        function startRealTime() {
            analyzer.startRealTime();
        }

        function stopRealTime() {
            analyzer.stopRealTime();
        }

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        function showLoading() {
            document.getElementById('loading').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loading').classList.remove('show');
        }

        // é”™è¯¯å¤„ç†
        window.addEventListener('error', (e) => {
            console.error('FFTåˆ†æå™¨é”™è¯¯:', e.error);
            alert('å‘ç”Ÿé”™è¯¯: ' + e.error.message);
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            if (analyzer) {
                analyzer.stopRealTime();
            }
        });
    </script>
</body>
</html>
