"use strict";(self.webpackChunkoscilloscope_simulator=self.webpackChunkoscilloscope_simulator||[]).push([[96],{121:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cL: () => (/* binding */ GUI$1)\n/* harmony export */ });\n/* unused harmony exports color, controllers, dom, gui */\n/**\r\n * dat-gui JavaScript Controller Library\r\n * https://github.com/dataarts/dat.gui\r\n *\r\n * Copyright 2011 Data Arts Team, Google Creative Lab\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n */\r\n\r\nfunction ___$insertStyle(css) {\r\n  if (!css) {\r\n    return;\r\n  }\r\n  if (typeof window === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  var style = document.createElement('style');\r\n\r\n  style.setAttribute('type', 'text/css');\r\n  style.innerHTML = css;\r\n  document.head.appendChild(style);\r\n\r\n  return css;\r\n}\r\n\r\nfunction colorToString (color, forceCSSHex) {\r\n  var colorFormat = color.__state.conversionName.toString();\r\n  var r = Math.round(color.r);\r\n  var g = Math.round(color.g);\r\n  var b = Math.round(color.b);\r\n  var a = color.a;\r\n  var h = Math.round(color.h);\r\n  var s = color.s.toFixed(1);\r\n  var v = color.v.toFixed(1);\r\n  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {\r\n    var str = color.hex.toString(16);\r\n    while (str.length < 6) {\r\n      str = '0' + str;\r\n    }\r\n    return '#' + str;\r\n  } else if (colorFormat === 'CSS_RGB') {\r\n    return 'rgb(' + r + ',' + g + ',' + b + ')';\r\n  } else if (colorFormat === 'CSS_RGBA') {\r\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\r\n  } else if (colorFormat === 'HEX') {\r\n    return '0x' + color.hex.toString(16);\r\n  } else if (colorFormat === 'RGB_ARRAY') {\r\n    return '[' + r + ',' + g + ',' + b + ']';\r\n  } else if (colorFormat === 'RGBA_ARRAY') {\r\n    return '[' + r + ',' + g + ',' + b + ',' + a + ']';\r\n  } else if (colorFormat === 'RGB_OBJ') {\r\n    return '{r:' + r + ',g:' + g + ',b:' + b + '}';\r\n  } else if (colorFormat === 'RGBA_OBJ') {\r\n    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';\r\n  } else if (colorFormat === 'HSV_OBJ') {\r\n    return '{h:' + h + ',s:' + s + ',v:' + v + '}';\r\n  } else if (colorFormat === 'HSVA_OBJ') {\r\n    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';\r\n  }\r\n  return 'unknown format';\r\n}\r\n\r\nvar ARR_EACH = Array.prototype.forEach;\r\nvar ARR_SLICE = Array.prototype.slice;\r\nvar Common = {\r\n  BREAK: {},\r\n  extend: function extend(target) {\r\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\r\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\r\n      keys.forEach(function (key) {\r\n        if (!this.isUndefined(obj[key])) {\r\n          target[key] = obj[key];\r\n        }\r\n      }.bind(this));\r\n    }, this);\r\n    return target;\r\n  },\r\n  defaults: function defaults(target) {\r\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\r\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\r\n      keys.forEach(function (key) {\r\n        if (this.isUndefined(target[key])) {\r\n          target[key] = obj[key];\r\n        }\r\n      }.bind(this));\r\n    }, this);\r\n    return target;\r\n  },\r\n  compose: function compose() {\r\n    var toCall = ARR_SLICE.call(arguments);\r\n    return function () {\r\n      var args = ARR_SLICE.call(arguments);\r\n      for (var i = toCall.length - 1; i >= 0; i--) {\r\n        args = [toCall[i].apply(this, args)];\r\n      }\r\n      return args[0];\r\n    };\r\n  },\r\n  each: function each(obj, itr, scope) {\r\n    if (!obj) {\r\n      return;\r\n    }\r\n    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {\r\n      obj.forEach(itr, scope);\r\n    } else if (obj.length === obj.length + 0) {\r\n      var key = void 0;\r\n      var l = void 0;\r\n      for (key = 0, l = obj.length; key < l; key++) {\r\n        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {\r\n          return;\r\n        }\r\n      }\r\n    } else {\r\n      for (var _key in obj) {\r\n        if (itr.call(scope, obj[_key], _key) === this.BREAK) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  },\r\n  defer: function defer(fnc) {\r\n    setTimeout(fnc, 0);\r\n  },\r\n  debounce: function debounce(func, threshold, callImmediately) {\r\n    var timeout = void 0;\r\n    return function () {\r\n      var obj = this;\r\n      var args = arguments;\r\n      function delayed() {\r\n        timeout = null;\r\n        if (!callImmediately) func.apply(obj, args);\r\n      }\r\n      var callNow = callImmediately || !timeout;\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(delayed, threshold);\r\n      if (callNow) {\r\n        func.apply(obj, args);\r\n      }\r\n    };\r\n  },\r\n  toArray: function toArray(obj) {\r\n    if (obj.toArray) return obj.toArray();\r\n    return ARR_SLICE.call(obj);\r\n  },\r\n  isUndefined: function isUndefined(obj) {\r\n    return obj === undefined;\r\n  },\r\n  isNull: function isNull(obj) {\r\n    return obj === null;\r\n  },\r\n  isNaN: function (_isNaN) {\r\n    function isNaN(_x) {\r\n      return _isNaN.apply(this, arguments);\r\n    }\r\n    isNaN.toString = function () {\r\n      return _isNaN.toString();\r\n    };\r\n    return isNaN;\r\n  }(function (obj) {\r\n    return isNaN(obj);\r\n  }),\r\n  isArray: Array.isArray || function (obj) {\r\n    return obj.constructor === Array;\r\n  },\r\n  isObject: function isObject(obj) {\r\n    return obj === Object(obj);\r\n  },\r\n  isNumber: function isNumber(obj) {\r\n    return obj === obj + 0;\r\n  },\r\n  isString: function isString(obj) {\r\n    return obj === obj + '';\r\n  },\r\n  isBoolean: function isBoolean(obj) {\r\n    return obj === false || obj === true;\r\n  },\r\n  isFunction: function isFunction(obj) {\r\n    return obj instanceof Function;\r\n  }\r\n};\r\n\r\nvar INTERPRETATIONS = [\r\n{\r\n  litmus: Common.isString,\r\n  conversions: {\r\n    THREE_CHAR_HEX: {\r\n      read: function read(original) {\r\n        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\r\n        if (test === null) {\r\n          return false;\r\n        }\r\n        return {\r\n          space: 'HEX',\r\n          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)\r\n        };\r\n      },\r\n      write: colorToString\r\n    },\r\n    SIX_CHAR_HEX: {\r\n      read: function read(original) {\r\n        var test = original.match(/^#([A-F0-9]{6})$/i);\r\n        if (test === null) {\r\n          return false;\r\n        }\r\n        return {\r\n          space: 'HEX',\r\n          hex: parseInt('0x' + test[1].toString(), 0)\r\n        };\r\n      },\r\n      write: colorToString\r\n    },\r\n    CSS_RGB: {\r\n      read: function read(original) {\r\n        var test = original.match(/^rgb\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\r\n        if (test === null) {\r\n          return false;\r\n        }\r\n        return {\r\n          space: 'RGB',\r\n          r: parseFloat(test[1]),\r\n          g: parseFloat(test[2]),\r\n          b: parseFloat(test[3])\r\n        };\r\n      },\r\n      write: colorToString\r\n    },\r\n    CSS_RGBA: {\r\n      read: function read(original) {\r\n        var test = original.match(/^rgba\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\r\n        if (test === null) {\r\n          return false;\r\n        }\r\n        return {\r\n          space: 'RGB',\r\n          r: parseFloat(test[1]),\r\n          g: parseFloat(test[2]),\r\n          b: parseFloat(test[3]),\r\n          a: parseFloat(test[4])\r\n        };\r\n      },\r\n      write: colorToString\r\n    }\r\n  }\r\n},\r\n{\r\n  litmus: Common.isNumber,\r\n  conversions: {\r\n    HEX: {\r\n      read: function read(original) {\r\n        return {\r\n          space: 'HEX',\r\n          hex: original,\r\n          conversionName: 'HEX'\r\n        };\r\n      },\r\n      write: function write(color) {\r\n        return color.hex;\r\n      }\r\n    }\r\n  }\r\n},\r\n{\r\n  litmus: Common.isArray,\r\n  conversions: {\r\n    RGB_ARRAY: {\r\n      read: function read(original) {\r\n        if (original.length !== 3) {\r\n          return false;\r\n        }\r\n        return {\r\n          space: 'RGB',\r\n          r: original[0],\r\n          g: original[1],\r\n          b: original[2]\r\n        };\r\n      },\r\n      write: function write(color) {\r\n        return [color.r, color.g, color.b];\r\n      }\r\n    },\r\n    RGBA_ARRAY: {\r\n      read: function read(original) {\r\n        if (original.length !== 4) return false;\r\n        return {\r\n          space: 'RGB',\r\n          r: original[0],\r\n          g: original[1],\r\n          b: original[2],\r\n          a: original[3]\r\n        };\r\n      },\r\n      write: function write(color) {\r\n        return [color.r, color.g, color.b, color.a];\r\n      }\r\n    }\r\n  }\r\n},\r\n{\r\n  litmus: Common.isObject,\r\n  conversions: {\r\n    RGBA_OBJ: {\r\n      read: function read(original) {\r\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {\r\n          return {\r\n            space: 'RGB',\r\n            r: original.r,\r\n            g: original.g,\r\n            b: original.b,\r\n            a: original.a\r\n          };\r\n        }\r\n        return false;\r\n      },\r\n      write: function write(color) {\r\n        return {\r\n          r: color.r,\r\n          g: color.g,\r\n          b: color.b,\r\n          a: color.a\r\n        };\r\n      }\r\n    },\r\n    RGB_OBJ: {\r\n      read: function read(original) {\r\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {\r\n          return {\r\n            space: 'RGB',\r\n            r: original.r,\r\n            g: original.g,\r\n            b: original.b\r\n          };\r\n        }\r\n        return false;\r\n      },\r\n      write: function write(color) {\r\n        return {\r\n          r: color.r,\r\n          g: color.g,\r\n          b: color.b\r\n        };\r\n      }\r\n    },\r\n    HSVA_OBJ: {\r\n      read: function read(original) {\r\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {\r\n          return {\r\n            space: 'HSV',\r\n            h: original.h,\r\n            s: original.s,\r\n            v: original.v,\r\n            a: original.a\r\n          };\r\n        }\r\n        return false;\r\n      },\r\n      write: function write(color) {\r\n        return {\r\n          h: color.h,\r\n          s: color.s,\r\n          v: color.v,\r\n          a: color.a\r\n        };\r\n      }\r\n    },\r\n    HSV_OBJ: {\r\n      read: function read(original) {\r\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {\r\n          return {\r\n            space: 'HSV',\r\n            h: original.h,\r\n            s: original.s,\r\n            v: original.v\r\n          };\r\n        }\r\n        return false;\r\n      },\r\n      write: function write(color) {\r\n        return {\r\n          h: color.h,\r\n          s: color.s,\r\n          v: color.v\r\n        };\r\n      }\r\n    }\r\n  }\r\n}];\r\nvar result = void 0;\r\nvar toReturn = void 0;\r\nvar interpret = function interpret() {\r\n  toReturn = false;\r\n  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];\r\n  Common.each(INTERPRETATIONS, function (family) {\r\n    if (family.litmus(original)) {\r\n      Common.each(family.conversions, function (conversion, conversionName) {\r\n        result = conversion.read(original);\r\n        if (toReturn === false && result !== false) {\r\n          toReturn = result;\r\n          result.conversionName = conversionName;\r\n          result.conversion = conversion;\r\n          return Common.BREAK;\r\n        }\r\n      });\r\n      return Common.BREAK;\r\n    }\r\n  });\r\n  return toReturn;\r\n};\r\n\r\nvar tmpComponent = void 0;\r\nvar ColorMath = {\r\n  hsv_to_rgb: function hsv_to_rgb(h, s, v) {\r\n    var hi = Math.floor(h / 60) % 6;\r\n    var f = h / 60 - Math.floor(h / 60);\r\n    var p = v * (1.0 - s);\r\n    var q = v * (1.0 - f * s);\r\n    var t = v * (1.0 - (1.0 - f) * s);\r\n    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];\r\n    return {\r\n      r: c[0] * 255,\r\n      g: c[1] * 255,\r\n      b: c[2] * 255\r\n    };\r\n  },\r\n  rgb_to_hsv: function rgb_to_hsv(r, g, b) {\r\n    var min = Math.min(r, g, b);\r\n    var max = Math.max(r, g, b);\r\n    var delta = max - min;\r\n    var h = void 0;\r\n    var s = void 0;\r\n    if (max !== 0) {\r\n      s = delta / max;\r\n    } else {\r\n      return {\r\n        h: NaN,\r\n        s: 0,\r\n        v: 0\r\n      };\r\n    }\r\n    if (r === max) {\r\n      h = (g - b) / delta;\r\n    } else if (g === max) {\r\n      h = 2 + (b - r) / delta;\r\n    } else {\r\n      h = 4 + (r - g) / delta;\r\n    }\r\n    h /= 6;\r\n    if (h < 0) {\r\n      h += 1;\r\n    }\r\n    return {\r\n      h: h * 360,\r\n      s: s,\r\n      v: max / 255\r\n    };\r\n  },\r\n  rgb_to_hex: function rgb_to_hex(r, g, b) {\r\n    var hex = this.hex_with_component(0, 2, r);\r\n    hex = this.hex_with_component(hex, 1, g);\r\n    hex = this.hex_with_component(hex, 0, b);\r\n    return hex;\r\n  },\r\n  component_from_hex: function component_from_hex(hex, componentIndex) {\r\n    return hex >> componentIndex * 8 & 0xFF;\r\n  },\r\n  hex_with_component: function hex_with_component(hex, componentIndex, value) {\r\n    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);\r\n  }\r\n};\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\r\n  return typeof obj;\r\n} : function (obj) {\r\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar classCallCheck = function (instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n};\r\n\r\nvar createClass = function () {\r\n  function defineProperties(target, props) {\r\n    for (var i = 0; i < props.length; i++) {\r\n      var descriptor = props[i];\r\n      descriptor.enumerable = descriptor.enumerable || false;\r\n      descriptor.configurable = true;\r\n      if (\"value\" in descriptor) descriptor.writable = true;\r\n      Object.defineProperty(target, descriptor.key, descriptor);\r\n    }\r\n  }\r\n\r\n  return function (Constructor, protoProps, staticProps) {\r\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\r\n    if (staticProps) defineProperties(Constructor, staticProps);\r\n    return Constructor;\r\n  };\r\n}();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar get = function get(object, property, receiver) {\r\n  if (object === null) object = Function.prototype;\r\n  var desc = Object.getOwnPropertyDescriptor(object, property);\r\n\r\n  if (desc === undefined) {\r\n    var parent = Object.getPrototypeOf(object);\r\n\r\n    if (parent === null) {\r\n      return undefined;\r\n    } else {\r\n      return get(parent, property, receiver);\r\n    }\r\n  } else if (\"value\" in desc) {\r\n    return desc.value;\r\n  } else {\r\n    var getter = desc.get;\r\n\r\n    if (getter === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    return getter.call(receiver);\r\n  }\r\n};\r\n\r\nvar inherits = function (subClass, superClass) {\r\n  if (typeof superClass !== \"function\" && superClass !== null) {\r\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\r\n  }\r\n\r\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\r\n    constructor: {\r\n      value: subClass,\r\n      enumerable: false,\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar possibleConstructorReturn = function (self, call) {\r\n  if (!self) {\r\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n  }\r\n\r\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\r\n};\r\n\r\nvar Color = function () {\r\n  function Color() {\r\n    classCallCheck(this, Color);\r\n    this.__state = interpret.apply(this, arguments);\r\n    if (this.__state === false) {\r\n      throw new Error('Failed to interpret color arguments');\r\n    }\r\n    this.__state.a = this.__state.a || 1;\r\n  }\r\n  createClass(Color, [{\r\n    key: 'toString',\r\n    value: function toString() {\r\n      return colorToString(this);\r\n    }\r\n  }, {\r\n    key: 'toHexString',\r\n    value: function toHexString() {\r\n      return colorToString(this, true);\r\n    }\r\n  }, {\r\n    key: 'toOriginal',\r\n    value: function toOriginal() {\r\n      return this.__state.conversion.write(this);\r\n    }\r\n  }]);\r\n  return Color;\r\n}();\r\nfunction defineRGBComponent(target, component, componentHexIndex) {\r\n  Object.defineProperty(target, component, {\r\n    get: function get$$1() {\r\n      if (this.__state.space === 'RGB') {\r\n        return this.__state[component];\r\n      }\r\n      Color.recalculateRGB(this, component, componentHexIndex);\r\n      return this.__state[component];\r\n    },\r\n    set: function set$$1(v) {\r\n      if (this.__state.space !== 'RGB') {\r\n        Color.recalculateRGB(this, component, componentHexIndex);\r\n        this.__state.space = 'RGB';\r\n      }\r\n      this.__state[component] = v;\r\n    }\r\n  });\r\n}\r\nfunction defineHSVComponent(target, component) {\r\n  Object.defineProperty(target, component, {\r\n    get: function get$$1() {\r\n      if (this.__state.space === 'HSV') {\r\n        return this.__state[component];\r\n      }\r\n      Color.recalculateHSV(this);\r\n      return this.__state[component];\r\n    },\r\n    set: function set$$1(v) {\r\n      if (this.__state.space !== 'HSV') {\r\n        Color.recalculateHSV(this);\r\n        this.__state.space = 'HSV';\r\n      }\r\n      this.__state[component] = v;\r\n    }\r\n  });\r\n}\r\nColor.recalculateRGB = function (color, component, componentHexIndex) {\r\n  if (color.__state.space === 'HEX') {\r\n    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);\r\n  } else if (color.__state.space === 'HSV') {\r\n    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\r\n  } else {\r\n    throw new Error('Corrupted color state');\r\n  }\r\n};\r\nColor.recalculateHSV = function (color) {\r\n  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);\r\n  Common.extend(color.__state, {\r\n    s: result.s,\r\n    v: result.v\r\n  });\r\n  if (!Common.isNaN(result.h)) {\r\n    color.__state.h = result.h;\r\n  } else if (Common.isUndefined(color.__state.h)) {\r\n    color.__state.h = 0;\r\n  }\r\n};\r\nColor.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];\r\ndefineRGBComponent(Color.prototype, 'r', 2);\r\ndefineRGBComponent(Color.prototype, 'g', 1);\r\ndefineRGBComponent(Color.prototype, 'b', 0);\r\ndefineHSVComponent(Color.prototype, 'h');\r\ndefineHSVComponent(Color.prototype, 's');\r\ndefineHSVComponent(Color.prototype, 'v');\r\nObject.defineProperty(Color.prototype, 'a', {\r\n  get: function get$$1() {\r\n    return this.__state.a;\r\n  },\r\n  set: function set$$1(v) {\r\n    this.__state.a = v;\r\n  }\r\n});\r\nObject.defineProperty(Color.prototype, 'hex', {\r\n  get: function get$$1() {\r\n    if (this.__state.space !== 'HEX') {\r\n      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);\r\n      this.__state.space = 'HEX';\r\n    }\r\n    return this.__state.hex;\r\n  },\r\n  set: function set$$1(v) {\r\n    this.__state.space = 'HEX';\r\n    this.__state.hex = v;\r\n  }\r\n});\r\n\r\nvar Controller = function () {\r\n  function Controller(object, property) {\r\n    classCallCheck(this, Controller);\r\n    this.initialValue = object[property];\r\n    this.domElement = document.createElement('div');\r\n    this.object = object;\r\n    this.property = property;\r\n    this.__onChange = undefined;\r\n    this.__onFinishChange = undefined;\r\n  }\r\n  createClass(Controller, [{\r\n    key: 'onChange',\r\n    value: function onChange(fnc) {\r\n      this.__onChange = fnc;\r\n      return this;\r\n    }\r\n  }, {\r\n    key: 'onFinishChange',\r\n    value: function onFinishChange(fnc) {\r\n      this.__onFinishChange = fnc;\r\n      return this;\r\n    }\r\n  }, {\r\n    key: 'setValue',\r\n    value: function setValue(newValue) {\r\n      this.object[this.property] = newValue;\r\n      if (this.__onChange) {\r\n        this.__onChange.call(this, newValue);\r\n      }\r\n      this.updateDisplay();\r\n      return this;\r\n    }\r\n  }, {\r\n    key: 'getValue',\r\n    value: function getValue() {\r\n      return this.object[this.property];\r\n    }\r\n  }, {\r\n    key: 'updateDisplay',\r\n    value: function updateDisplay() {\r\n      return this;\r\n    }\r\n  }, {\r\n    key: 'isModified',\r\n    value: function isModified() {\r\n      return this.initialValue !== this.getValue();\r\n    }\r\n  }]);\r\n  return Controller;\r\n}();\r\n\r\nvar EVENT_MAP = {\r\n  HTMLEvents: ['change'],\r\n  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],\r\n  KeyboardEvents: ['keydown']\r\n};\r\nvar EVENT_MAP_INV = {};\r\nCommon.each(EVENT_MAP, function (v, k) {\r\n  Common.each(v, function (e) {\r\n    EVENT_MAP_INV[e] = k;\r\n  });\r\n});\r\nvar CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\r\nfunction cssValueToPixels(val) {\r\n  if (val === '0' || Common.isUndefined(val)) {\r\n    return 0;\r\n  }\r\n  var match = val.match(CSS_VALUE_PIXELS);\r\n  if (!Common.isNull(match)) {\r\n    return parseFloat(match[1]);\r\n  }\r\n  return 0;\r\n}\r\nvar dom = {\r\n  makeSelectable: function makeSelectable(elem, selectable) {\r\n    if (elem === undefined || elem.style === undefined) return;\r\n    elem.onselectstart = selectable ? function () {\r\n      return false;\r\n    } : function () {};\r\n    elem.style.MozUserSelect = selectable ? 'auto' : 'none';\r\n    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\r\n    elem.unselectable = selectable ? 'on' : 'off';\r\n  },\r\n  makeFullscreen: function makeFullscreen(elem, hor, vert) {\r\n    var vertical = vert;\r\n    var horizontal = hor;\r\n    if (Common.isUndefined(horizontal)) {\r\n      horizontal = true;\r\n    }\r\n    if (Common.isUndefined(vertical)) {\r\n      vertical = true;\r\n    }\r\n    elem.style.position = 'absolute';\r\n    if (horizontal) {\r\n      elem.style.left = 0;\r\n      elem.style.right = 0;\r\n    }\r\n    if (vertical) {\r\n      elem.style.top = 0;\r\n      elem.style.bottom = 0;\r\n    }\r\n  },\r\n  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {\r\n    var params = pars || {};\r\n    var className = EVENT_MAP_INV[eventType];\r\n    if (!className) {\r\n      throw new Error('Event type ' + eventType + ' not supported.');\r\n    }\r\n    var evt = document.createEvent(className);\r\n    switch (className) {\r\n      case 'MouseEvents':\r\n        {\r\n          var clientX = params.x || params.clientX || 0;\r\n          var clientY = params.y || params.clientY || 0;\r\n          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,\r\n          0,\r\n          clientX,\r\n          clientY,\r\n          false, false, false, false, 0, null);\r\n          break;\r\n        }\r\n      case 'KeyboardEvents':\r\n        {\r\n          var init = evt.initKeyboardEvent || evt.initKeyEvent;\r\n          Common.defaults(params, {\r\n            cancelable: true,\r\n            ctrlKey: false,\r\n            altKey: false,\r\n            shiftKey: false,\r\n            metaKey: false,\r\n            keyCode: undefined,\r\n            charCode: undefined\r\n          });\r\n          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);\r\n          break;\r\n        }\r\n      default:\r\n        {\r\n          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);\r\n          break;\r\n        }\r\n    }\r\n    Common.defaults(evt, aux);\r\n    elem.dispatchEvent(evt);\r\n  },\r\n  bind: function bind(elem, event, func, newBool) {\r\n    var bool = newBool || false;\r\n    if (elem.addEventListener) {\r\n      elem.addEventListener(event, func, bool);\r\n    } else if (elem.attachEvent) {\r\n      elem.attachEvent('on' + event, func);\r\n    }\r\n    return dom;\r\n  },\r\n  unbind: function unbind(elem, event, func, newBool) {\r\n    var bool = newBool || false;\r\n    if (elem.removeEventListener) {\r\n      elem.removeEventListener(event, func, bool);\r\n    } else if (elem.detachEvent) {\r\n      elem.detachEvent('on' + event, func);\r\n    }\r\n    return dom;\r\n  },\r\n  addClass: function addClass(elem, className) {\r\n    if (elem.className === undefined) {\r\n      elem.className = className;\r\n    } else if (elem.className !== className) {\r\n      var classes = elem.className.split(/ +/);\r\n      if (classes.indexOf(className) === -1) {\r\n        classes.push(className);\r\n        elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n      }\r\n    }\r\n    return dom;\r\n  },\r\n  removeClass: function removeClass(elem, className) {\r\n    if (className) {\r\n      if (elem.className === className) {\r\n        elem.removeAttribute('class');\r\n      } else {\r\n        var classes = elem.className.split(/ +/);\r\n        var index = classes.indexOf(className);\r\n        if (index !== -1) {\r\n          classes.splice(index, 1);\r\n          elem.className = classes.join(' ');\r\n        }\r\n      }\r\n    } else {\r\n      elem.className = undefined;\r\n    }\r\n    return dom;\r\n  },\r\n  hasClass: function hasClass(elem, className) {\r\n    return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\r\n  },\r\n  getWidth: function getWidth(elem) {\r\n    var style = getComputedStyle(elem);\r\n    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);\r\n  },\r\n  getHeight: function getHeight(elem) {\r\n    var style = getComputedStyle(elem);\r\n    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);\r\n  },\r\n  getOffset: function getOffset(el) {\r\n    var elem = el;\r\n    var offset = { left: 0, top: 0 };\r\n    if (elem.offsetParent) {\r\n      do {\r\n        offset.left += elem.offsetLeft;\r\n        offset.top += elem.offsetTop;\r\n        elem = elem.offsetParent;\r\n      } while (elem);\r\n    }\r\n    return offset;\r\n  },\r\n  isActive: function isActive(elem) {\r\n    return elem === document.activeElement && (elem.type || elem.href);\r\n  }\r\n};\r\n\r\nvar BooleanController = function (_Controller) {\r\n  inherits(BooleanController, _Controller);\r\n  function BooleanController(object, property) {\r\n    classCallCheck(this, BooleanController);\r\n    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));\r\n    var _this = _this2;\r\n    _this2.__prev = _this2.getValue();\r\n    _this2.__checkbox = document.createElement('input');\r\n    _this2.__checkbox.setAttribute('type', 'checkbox');\r\n    function onChange() {\r\n      _this.setValue(!_this.__prev);\r\n    }\r\n    dom.bind(_this2.__checkbox, 'change', onChange, false);\r\n    _this2.domElement.appendChild(_this2.__checkbox);\r\n    _this2.updateDisplay();\r\n    return _this2;\r\n  }\r\n  createClass(BooleanController, [{\r\n    key: 'setValue',\r\n    value: function setValue(v) {\r\n      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);\r\n      if (this.__onFinishChange) {\r\n        this.__onFinishChange.call(this, this.getValue());\r\n      }\r\n      this.__prev = this.getValue();\r\n      return toReturn;\r\n    }\r\n  }, {\r\n    key: 'updateDisplay',\r\n    value: function updateDisplay() {\r\n      if (this.getValue() === true) {\r\n        this.__checkbox.setAttribute('checked', 'checked');\r\n        this.__checkbox.checked = true;\r\n        this.__prev = true;\r\n      } else {\r\n        this.__checkbox.checked = false;\r\n        this.__prev = false;\r\n      }\r\n      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);\r\n    }\r\n  }]);\r\n  return BooleanController;\r\n}(Controller);\r\n\r\nvar OptionController = function (_Controller) {\r\n  inherits(OptionController, _Controller);\r\n  function OptionController(object, property, opts) {\r\n    classCallCheck(this, OptionController);\r\n    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));\r\n    var options = opts;\r\n    var _this = _this2;\r\n    _this2.__select = document.createElement('select');\r\n    if (Common.isArray(options)) {\r\n      var map = {};\r\n      Common.each(options, function (element) {\r\n        map[element] = element;\r\n      });\r\n      options = map;\r\n    }\r\n    Common.each(options, function (value, key) {\r\n      var opt = document.createElement('option');\r\n      opt.innerHTML = key;\r\n      opt.setAttribute('value', value);\r\n      _this.__select.appendChild(opt);\r\n    });\r\n    _this2.updateDisplay();\r\n    dom.bind(_this2.__select, 'change', function () {\r\n      var desiredValue = this.options[this.selectedIndex].value;\r\n      _this.setValue(desiredValue);\r\n    });\r\n    _this2.domElement.appendChild(_this2.__select);\r\n    return _this2;\r\n  }\r\n  createClass(OptionController, [{\r\n    key: 'setValue',\r\n    value: function setValue(v) {\r\n      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);\r\n      if (this.__onFinishChange) {\r\n        this.__onFinishChange.call(this, this.getValue());\r\n      }\r\n      return toReturn;\r\n    }\r\n  }, {\r\n    key: 'updateDisplay',\r\n    value: function updateDisplay() {\r\n      if (dom.isActive(this.__select)) return this;\r\n      this.__select.value = this.getValue();\r\n      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);\r\n    }\r\n  }]);\r\n  return OptionController;\r\n}(Controller);\r\n\r\nvar StringController = function (_Controller) {\r\n  inherits(StringController, _Controller);\r\n  function StringController(object, property) {\r\n    classCallCheck(this, StringController);\r\n    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));\r\n    var _this = _this2;\r\n    function onChange() {\r\n      _this.setValue(_this.__input.value);\r\n    }\r\n    function onBlur() {\r\n      if (_this.__onFinishChange) {\r\n        _this.__onFinishChange.call(_this, _this.getValue());\r\n      }\r\n    }\r\n    _this2.__input = document.createElement('input');\r\n    _this2.__input.setAttribute('type', 'text');\r\n    dom.bind(_this2.__input, 'keyup', onChange);\r\n    dom.bind(_this2.__input, 'change', onChange);\r\n    dom.bind(_this2.__input, 'blur', onBlur);\r\n    dom.bind(_this2.__input, 'keydown', function (e) {\r\n      if (e.keyCode === 13) {\r\n        this.blur();\r\n      }\r\n    });\r\n    _this2.updateDisplay();\r\n    _this2.domElement.appendChild(_this2.__input);\r\n    return _this2;\r\n  }\r\n  createClass(StringController, [{\r\n    key: 'updateDisplay',\r\n    value: function updateDisplay() {\r\n      if (!dom.isActive(this.__input)) {\r\n        this.__input.value = this.getValue();\r\n      }\r\n      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);\r\n    }\r\n  }]);\r\n  return StringController;\r\n}(Controller);\r\n\r\nfunction numDecimals(x) {\r\n  var _x = x.toString();\r\n  if (_x.indexOf('.') > -1) {\r\n    return _x.length - _x.indexOf('.') - 1;\r\n  }\r\n  return 0;\r\n}\r\nvar NumberController = function (_Controller) {\r\n  inherits(NumberController, _Controller);\r\n  function NumberController(object, property, params) {\r\n    classCallCheck(this, NumberController);\r\n    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));\r\n    var _params = params || {};\r\n    _this.__min = _params.min;\r\n    _this.__max = _params.max;\r\n    _this.__step = _params.step;\r\n    if (Common.isUndefined(_this.__step)) {\r\n      if (_this.initialValue === 0) {\r\n        _this.__impliedStep = 1;\r\n      } else {\r\n        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;\r\n      }\r\n    } else {\r\n      _this.__impliedStep = _this.__step;\r\n    }\r\n    _this.__precision = numDecimals(_this.__impliedStep);\r\n    return _this;\r\n  }\r\n  createClass(NumberController, [{\r\n    key: 'setValue',\r\n    value: function setValue(v) {\r\n      var _v = v;\r\n      if (this.__min !== undefined && _v < this.__min) {\r\n        _v = this.__min;\r\n      } else if (this.__max !== undefined && _v > this.__max) {\r\n        _v = this.__max;\r\n      }\r\n      if (this.__step !== undefined && _v % this.__step !== 0) {\r\n        _v = Math.round(_v / this.__step) * this.__step;\r\n      }\r\n      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);\r\n    }\r\n  }, {\r\n    key: 'min',\r\n    value: function min(minValue) {\r\n      this.__min = minValue;\r\n      return this;\r\n    }\r\n  }, {\r\n    key: 'max',\r\n    value: function max(maxValue) {\r\n      this.__max = maxValue;\r\n      return this;\r\n    }\r\n  }, {\r\n    key: 'step',\r\n    value: function step(stepValue) {\r\n      this.__step = stepValue;\r\n      this.__impliedStep = stepValue;\r\n      this.__precision = numDecimals(stepValue);\r\n      return this;\r\n    }\r\n  }]);\r\n  return NumberController;\r\n}(Controller);\r\n\r\nfunction roundToDecimal(value, decimals) {\r\n  var tenTo = Math.pow(10, decimals);\r\n  return Math.round(value * tenTo) / tenTo;\r\n}\r\nvar NumberControllerBox = function (_NumberController) {\r\n  inherits(NumberControllerBox, _NumberController);\r\n  function NumberControllerBox(object, property, params) {\r\n    classCallCheck(this, NumberControllerBox);\r\n    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));\r\n    _this2.__truncationSuspended = false;\r\n    var _this = _this2;\r\n    var prevY = void 0;\r\n    function onChange() {\r\n      var attempted = parseFloat(_this.__input.value);\r\n      if (!Common.isNaN(attempted)) {\r\n        _this.setValue(attempted);\r\n      }\r\n    }\r\n    function onFinish() {\r\n      if (_this.__onFinishChange) {\r\n        _this.__onFinishChange.call(_this, _this.getValue());\r\n      }\r\n    }\r\n    function onBlur() {\r\n      onFinish();\r\n    }\r\n    function onMouseDrag(e) {\r\n      var diff = prevY - e.clientY;\r\n      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\r\n      prevY = e.clientY;\r\n    }\r\n    function onMouseUp() {\r\n      dom.unbind(window, 'mousemove', onMouseDrag);\r\n      dom.unbind(window, 'mouseup', onMouseUp);\r\n      onFinish();\r\n    }\r\n    function onMouseDown(e) {\r\n      dom.bind(window, 'mousemove', onMouseDrag);\r\n      dom.bind(window, 'mouseup', onMouseUp);\r\n      prevY = e.clientY;\r\n    }\r\n    _this2.__input = document.createElement('input');\r\n    _this2.__input.setAttribute('type', 'text');\r\n    dom.bind(_this2.__input, 'change', onChange);\r\n    dom.bind(_this2.__input, 'blur', onBlur);\r\n    dom.bind(_this2.__input, 'mousedown', onMouseDown);\r\n    dom.bind(_this2.__input, 'keydown', function (e) {\r\n      if (e.keyCode === 13) {\r\n        _this.__truncationSuspended = true;\r\n        this.blur();\r\n        _this.__truncationSuspended = false;\r\n        onFinish();\r\n      }\r\n    });\r\n    _this2.updateDisplay();\r\n    _this2.domElement.appendChild(_this2.__input);\r\n    return _this2;\r\n  }\r\n  createClass(NumberControllerBox, [{\r\n    key: 'updateDisplay',\r\n    value: function updateDisplay() {\r\n      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\r\n      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);\r\n    }\r\n  }]);\r\n  return NumberControllerBox;\r\n}(NumberController);\r\n\r\nfunction map(v, i1, i2, o1, o2) {\r\n  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\r\n}\r\nvar NumberControllerSlider = function (_NumberController) {\r\n  inherits(NumberControllerSlider, _NumberController);\r\n  function NumberControllerSlider(object, property, min, max, step) {\r\n    classCallCheck(this, NumberControllerSlider);\r\n    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));\r\n    var _this = _this2;\r\n    _this2.__background = document.createElement('div');\r\n    _this2.__foreground = document.createElement('div');\r\n    dom.bind(_this2.__background, 'mousedown', onMouseDown);\r\n    dom.bind(_this2.__background, 'touchstart', onTouchStart);\r\n    dom.addClass(_this2.__background, 'slider');\r\n    dom.addClass(_this2.__foreground, 'slider-fg');\r\n    function onMouseDown(e) {\r\n      document.activeElement.blur();\r\n      dom.bind(window, 'mousemove', onMouseDrag);\r\n      dom.bind(window, 'mouseup', onMouseUp);\r\n      onMouseDrag(e);\r\n    }\r\n    function onMouseDrag(e) {\r\n      e.preventDefault();\r\n      var bgRect = _this.__background.getBoundingClientRect();\r\n      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\r\n      return false;\r\n    }\r\n    function onMouseUp() {\r\n      dom.unbind(window, 'mousemove', onMouseDrag);\r\n      dom.unbind(window, 'mouseup', onMouseUp);\r\n      if (_this.__onFinishChange) {\r\n        _this.__onFinishChange.call(_this, _this.getValue());\r\n      }\r\n    }\r\n    function onTouchStart(e) {\r\n      if (e.touches.length !== 1) {\r\n        return;\r\n      }\r\n      dom.bind(window, 'touchmove', onTouchMove);\r\n      dom.bind(window, 'touchend', onTouchEnd);\r\n      onTouchMove(e);\r\n    }\r\n    function onTouchMove(e) {\r\n      var clientX = e.touches[0].clientX;\r\n      var bgRect = _this.__background.getBoundingClientRect();\r\n      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\r\n    }\r\n    function onTouchEnd() {\r\n      dom.unbind(window, 'touchmove', onTouchMove);\r\n      dom.unbind(window, 'touchend', onTouchEnd);\r\n      if (_this.__onFinishChange) {\r\n        _this.__onFinishChange.call(_this, _this.getValue());\r\n      }\r\n    }\r\n    _this2.updateDisplay();\r\n    _this2.__background.appendChild(_this2.__foreground);\r\n    _this2.domElement.appendChild(_this2.__background);\r\n    return _this2;\r\n  }\r\n  createClass(NumberControllerSlider, [{\r\n    key: 'updateDisplay',\r\n    value: function updateDisplay() {\r\n      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);\r\n      this.__foreground.style.width = pct * 100 + '%';\r\n      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);\r\n    }\r\n  }]);\r\n  return NumberControllerSlider;\r\n}(NumberController);\r\n\r\nvar FunctionController = function (_Controller) {\r\n  inherits(FunctionController, _Controller);\r\n  function FunctionController(object, property, text) {\r\n    classCallCheck(this, FunctionController);\r\n    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));\r\n    var _this = _this2;\r\n    _this2.__button = document.createElement('div');\r\n    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;\r\n    dom.bind(_this2.__button, 'click', function (e) {\r\n      e.preventDefault();\r\n      _this.fire();\r\n      return false;\r\n    });\r\n    dom.addClass(_this2.__button, 'button');\r\n    _this2.domElement.appendChild(_this2.__button);\r\n    return _this2;\r\n  }\r\n  createClass(FunctionController, [{\r\n    key: 'fire',\r\n    value: function fire() {\r\n      if (this.__onChange) {\r\n        this.__onChange.call(this);\r\n      }\r\n      this.getValue().call(this.object);\r\n      if (this.__onFinishChange) {\r\n        this.__onFinishChange.call(this, this.getValue());\r\n      }\r\n    }\r\n  }]);\r\n  return FunctionController;\r\n}(Controller);\r\n\r\nvar ColorController = function (_Controller) {\r\n  inherits(ColorController, _Controller);\r\n  function ColorController(object, property) {\r\n    classCallCheck(this, ColorController);\r\n    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));\r\n    _this2.__color = new Color(_this2.getValue());\r\n    _this2.__temp = new Color(0);\r\n    var _this = _this2;\r\n    _this2.domElement = document.createElement('div');\r\n    dom.makeSelectable(_this2.domElement, false);\r\n    _this2.__selector = document.createElement('div');\r\n    _this2.__selector.className = 'selector';\r\n    _this2.__saturation_field = document.createElement('div');\r\n    _this2.__saturation_field.className = 'saturation-field';\r\n    _this2.__field_knob = document.createElement('div');\r\n    _this2.__field_knob.className = 'field-knob';\r\n    _this2.__field_knob_border = '2px solid ';\r\n    _this2.__hue_knob = document.createElement('div');\r\n    _this2.__hue_knob.className = 'hue-knob';\r\n    _this2.__hue_field = document.createElement('div');\r\n    _this2.__hue_field.className = 'hue-field';\r\n    _this2.__input = document.createElement('input');\r\n    _this2.__input.type = 'text';\r\n    _this2.__input_textShadow = '0 1px 1px ';\r\n    dom.bind(_this2.__input, 'keydown', function (e) {\r\n      if (e.keyCode === 13) {\r\n        onBlur.call(this);\r\n      }\r\n    });\r\n    dom.bind(_this2.__input, 'blur', onBlur);\r\n    dom.bind(_this2.__selector, 'mousedown', function () {\r\n      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {\r\n        dom.removeClass(_this.__selector, 'drag');\r\n      });\r\n    });\r\n    dom.bind(_this2.__selector, 'touchstart', function () {\r\n      dom.addClass(this, 'drag').bind(window, 'touchend', function () {\r\n        dom.removeClass(_this.__selector, 'drag');\r\n      });\r\n    });\r\n    var valueField = document.createElement('div');\r\n    Common.extend(_this2.__selector.style, {\r\n      width: '122px',\r\n      height: '102px',\r\n      padding: '3px',\r\n      backgroundColor: '#222',\r\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\r\n    });\r\n    Common.extend(_this2.__field_knob.style, {\r\n      position: 'absolute',\r\n      width: '12px',\r\n      height: '12px',\r\n      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),\r\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\r\n      borderRadius: '12px',\r\n      zIndex: 1\r\n    });\r\n    Common.extend(_this2.__hue_knob.style, {\r\n      position: 'absolute',\r\n      width: '15px',\r\n      height: '2px',\r\n      borderRight: '4px solid #fff',\r\n      zIndex: 1\r\n    });\r\n    Common.extend(_this2.__saturation_field.style, {\r\n      width: '100px',\r\n      height: '100px',\r\n      border: '1px solid #555',\r\n      marginRight: '3px',\r\n      display: 'inline-block',\r\n      cursor: 'pointer'\r\n    });\r\n    Common.extend(valueField.style, {\r\n      width: '100%',\r\n      height: '100%',\r\n      background: 'none'\r\n    });\r\n    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');\r\n    Common.extend(_this2.__hue_field.style, {\r\n      width: '15px',\r\n      height: '100px',\r\n      border: '1px solid #555',\r\n      cursor: 'ns-resize',\r\n      position: 'absolute',\r\n      top: '3px',\r\n      right: '3px'\r\n    });\r\n    hueGradient(_this2.__hue_field);\r\n    Common.extend(_this2.__input.style, {\r\n      outline: 'none',\r\n      textAlign: 'center',\r\n      color: '#fff',\r\n      border: 0,\r\n      fontWeight: 'bold',\r\n      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'\r\n    });\r\n    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);\r\n    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);\r\n    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);\r\n    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);\r\n    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);\r\n    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);\r\n    function fieldDown(e) {\r\n      setSV(e);\r\n      dom.bind(window, 'mousemove', setSV);\r\n      dom.bind(window, 'touchmove', setSV);\r\n      dom.bind(window, 'mouseup', fieldUpSV);\r\n      dom.bind(window, 'touchend', fieldUpSV);\r\n    }\r\n    function fieldDownH(e) {\r\n      setH(e);\r\n      dom.bind(window, 'mousemove', setH);\r\n      dom.bind(window, 'touchmove', setH);\r\n      dom.bind(window, 'mouseup', fieldUpH);\r\n      dom.bind(window, 'touchend', fieldUpH);\r\n    }\r\n    function fieldUpSV() {\r\n      dom.unbind(window, 'mousemove', setSV);\r\n      dom.unbind(window, 'touchmove', setSV);\r\n      dom.unbind(window, 'mouseup', fieldUpSV);\r\n      dom.unbind(window, 'touchend', fieldUpSV);\r\n      onFinish();\r\n    }\r\n    function fieldUpH() {\r\n      dom.unbind(window, 'mousemove', setH);\r\n      dom.unbind(window, 'touchmove', setH);\r\n      dom.unbind(window, 'mouseup', fieldUpH);\r\n      dom.unbind(window, 'touchend', fieldUpH);\r\n      onFinish();\r\n    }\r\n    function onBlur() {\r\n      var i = interpret(this.value);\r\n      if (i !== false) {\r\n        _this.__color.__state = i;\r\n        _this.setValue(_this.__color.toOriginal());\r\n      } else {\r\n        this.value = _this.__color.toString();\r\n      }\r\n    }\r\n    function onFinish() {\r\n      if (_this.__onFinishChange) {\r\n        _this.__onFinishChange.call(_this, _this.__color.toOriginal());\r\n      }\r\n    }\r\n    _this2.__saturation_field.appendChild(valueField);\r\n    _this2.__selector.appendChild(_this2.__field_knob);\r\n    _this2.__selector.appendChild(_this2.__saturation_field);\r\n    _this2.__selector.appendChild(_this2.__hue_field);\r\n    _this2.__hue_field.appendChild(_this2.__hue_knob);\r\n    _this2.domElement.appendChild(_this2.__input);\r\n    _this2.domElement.appendChild(_this2.__selector);\r\n    _this2.updateDisplay();\r\n    function setSV(e) {\r\n      if (e.type.indexOf('touch') === -1) {\r\n        e.preventDefault();\r\n      }\r\n      var fieldRect = _this.__saturation_field.getBoundingClientRect();\r\n      var _ref = e.touches && e.touches[0] || e,\r\n          clientX = _ref.clientX,\r\n          clientY = _ref.clientY;\r\n      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);\r\n      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\r\n      if (v > 1) {\r\n        v = 1;\r\n      } else if (v < 0) {\r\n        v = 0;\r\n      }\r\n      if (s > 1) {\r\n        s = 1;\r\n      } else if (s < 0) {\r\n        s = 0;\r\n      }\r\n      _this.__color.v = v;\r\n      _this.__color.s = s;\r\n      _this.setValue(_this.__color.toOriginal());\r\n      return false;\r\n    }\r\n    function setH(e) {\r\n      if (e.type.indexOf('touch') === -1) {\r\n        e.preventDefault();\r\n      }\r\n      var fieldRect = _this.__hue_field.getBoundingClientRect();\r\n      var _ref2 = e.touches && e.touches[0] || e,\r\n          clientY = _ref2.clientY;\r\n      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\r\n      if (h > 1) {\r\n        h = 1;\r\n      } else if (h < 0) {\r\n        h = 0;\r\n      }\r\n      _this.__color.h = h * 360;\r\n      _this.setValue(_this.__color.toOriginal());\r\n      return false;\r\n    }\r\n    return _this2;\r\n  }\r\n  createClass(ColorController, [{\r\n    key: 'updateDisplay',\r\n    value: function updateDisplay() {\r\n      var i = interpret(this.getValue());\r\n      if (i !== false) {\r\n        var mismatch = false;\r\n        Common.each(Color.COMPONENTS, function (component) {\r\n          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {\r\n            mismatch = true;\r\n            return {};\r\n          }\r\n        }, this);\r\n        if (mismatch) {\r\n          Common.extend(this.__color.__state, i);\r\n        }\r\n      }\r\n      Common.extend(this.__temp.__state, this.__color.__state);\r\n      this.__temp.a = 1;\r\n      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;\r\n      var _flip = 255 - flip;\r\n      Common.extend(this.__field_knob.style, {\r\n        marginLeft: 100 * this.__color.s - 7 + 'px',\r\n        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\r\n        backgroundColor: this.__temp.toHexString(),\r\n        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'\r\n      });\r\n      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';\r\n      this.__temp.s = 1;\r\n      this.__temp.v = 1;\r\n      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());\r\n      this.__input.value = this.__color.toString();\r\n      Common.extend(this.__input.style, {\r\n        backgroundColor: this.__color.toHexString(),\r\n        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',\r\n        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'\r\n      });\r\n    }\r\n  }]);\r\n  return ColorController;\r\n}(Controller);\r\nvar vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];\r\nfunction linearGradient(elem, x, a, b) {\r\n  elem.style.background = '';\r\n  Common.each(vendors, function (vendor) {\r\n    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';\r\n  });\r\n}\r\nfunction hueGradient(elem) {\r\n  elem.style.background = '';\r\n  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';\r\n  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\r\n  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\r\n  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\r\n  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\r\n}\r\n\r\nvar css = {\r\n  load: function load(url, indoc) {\r\n    var doc = indoc || document;\r\n    var link = doc.createElement('link');\r\n    link.type = 'text/css';\r\n    link.rel = 'stylesheet';\r\n    link.href = url;\r\n    doc.getElementsByTagName('head')[0].appendChild(link);\r\n  },\r\n  inject: function inject(cssContent, indoc) {\r\n    var doc = indoc || document;\r\n    var injected = document.createElement('style');\r\n    injected.type = 'text/css';\r\n    injected.innerHTML = cssContent;\r\n    var head = doc.getElementsByTagName('head')[0];\r\n    try {\r\n      head.appendChild(injected);\r\n    } catch (e) {\r\n    }\r\n  }\r\n};\r\n\r\nvar saveDialogContents = \"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n\\n    </div>\\n\\n  </div>\\n\\n</div>\";\r\n\r\nvar ControllerFactory = function ControllerFactory(object, property) {\r\n  var initialValue = object[property];\r\n  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {\r\n    return new OptionController(object, property, arguments[2]);\r\n  }\r\n  if (Common.isNumber(initialValue)) {\r\n    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {\r\n      if (Common.isNumber(arguments[4])) {\r\n        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);\r\n      }\r\n      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\r\n    }\r\n    if (Common.isNumber(arguments[4])) {\r\n      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });\r\n    }\r\n    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\r\n  }\r\n  if (Common.isString(initialValue)) {\r\n    return new StringController(object, property);\r\n  }\r\n  if (Common.isFunction(initialValue)) {\r\n    return new FunctionController(object, property, '');\r\n  }\r\n  if (Common.isBoolean(initialValue)) {\r\n    return new BooleanController(object, property);\r\n  }\r\n  return null;\r\n};\r\n\r\nfunction requestAnimationFrame(callback) {\r\n  setTimeout(callback, 1000 / 60);\r\n}\r\nvar requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;\r\n\r\nvar CenteredDiv = function () {\r\n  function CenteredDiv() {\r\n    classCallCheck(this, CenteredDiv);\r\n    this.backgroundElement = document.createElement('div');\r\n    Common.extend(this.backgroundElement.style, {\r\n      backgroundColor: 'rgba(0,0,0,0.8)',\r\n      top: 0,\r\n      left: 0,\r\n      display: 'none',\r\n      zIndex: '1000',\r\n      opacity: 0,\r\n      WebkitTransition: 'opacity 0.2s linear',\r\n      transition: 'opacity 0.2s linear'\r\n    });\r\n    dom.makeFullscreen(this.backgroundElement);\r\n    this.backgroundElement.style.position = 'fixed';\r\n    this.domElement = document.createElement('div');\r\n    Common.extend(this.domElement.style, {\r\n      position: 'fixed',\r\n      display: 'none',\r\n      zIndex: '1001',\r\n      opacity: 0,\r\n      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',\r\n      transition: 'transform 0.2s ease-out, opacity 0.2s linear'\r\n    });\r\n    document.body.appendChild(this.backgroundElement);\r\n    document.body.appendChild(this.domElement);\r\n    var _this = this;\r\n    dom.bind(this.backgroundElement, 'click', function () {\r\n      _this.hide();\r\n    });\r\n  }\r\n  createClass(CenteredDiv, [{\r\n    key: 'show',\r\n    value: function show() {\r\n      var _this = this;\r\n      this.backgroundElement.style.display = 'block';\r\n      this.domElement.style.display = 'block';\r\n      this.domElement.style.opacity = 0;\r\n      this.domElement.style.webkitTransform = 'scale(1.1)';\r\n      this.layout();\r\n      Common.defer(function () {\r\n        _this.backgroundElement.style.opacity = 1;\r\n        _this.domElement.style.opacity = 1;\r\n        _this.domElement.style.webkitTransform = 'scale(1)';\r\n      });\r\n    }\r\n  }, {\r\n    key: 'hide',\r\n    value: function hide() {\r\n      var _this = this;\r\n      var hide = function hide() {\r\n        _this.domElement.style.display = 'none';\r\n        _this.backgroundElement.style.display = 'none';\r\n        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\r\n        dom.unbind(_this.domElement, 'transitionend', hide);\r\n        dom.unbind(_this.domElement, 'oTransitionEnd', hide);\r\n      };\r\n      dom.bind(this.domElement, 'webkitTransitionEnd', hide);\r\n      dom.bind(this.domElement, 'transitionend', hide);\r\n      dom.bind(this.domElement, 'oTransitionEnd', hide);\r\n      this.backgroundElement.style.opacity = 0;\r\n      this.domElement.style.opacity = 0;\r\n      this.domElement.style.webkitTransform = 'scale(1.1)';\r\n    }\r\n  }, {\r\n    key: 'layout',\r\n    value: function layout() {\r\n      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';\r\n      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';\r\n    }\r\n  }]);\r\n  return CenteredDiv;\r\n}();\r\n\r\nvar styleSheet = ___$insertStyle(\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\");\r\n\r\ncss.inject(styleSheet);\r\nvar CSS_NAMESPACE = 'dg';\r\nvar HIDE_KEY_CODE = 72;\r\nvar CLOSE_BUTTON_HEIGHT = 20;\r\nvar DEFAULT_DEFAULT_PRESET_NAME = 'Default';\r\nvar SUPPORTS_LOCAL_STORAGE = function () {\r\n  try {\r\n    return !!window.localStorage;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}();\r\nvar SAVE_DIALOGUE = void 0;\r\nvar autoPlaceVirgin = true;\r\nvar autoPlaceContainer = void 0;\r\nvar hide = false;\r\nvar hideableGuis = [];\r\nvar GUI = function GUI(pars) {\r\n  var _this = this;\r\n  var params = pars || {};\r\n  this.domElement = document.createElement('div');\r\n  this.__ul = document.createElement('ul');\r\n  this.domElement.appendChild(this.__ul);\r\n  dom.addClass(this.domElement, CSS_NAMESPACE);\r\n  this.__folders = {};\r\n  this.__controllers = [];\r\n  this.__rememberedObjects = [];\r\n  this.__rememberedObjectIndecesToControllers = [];\r\n  this.__listening = [];\r\n  params = Common.defaults(params, {\r\n    closeOnTop: false,\r\n    autoPlace: true,\r\n    width: GUI.DEFAULT_WIDTH\r\n  });\r\n  params = Common.defaults(params, {\r\n    resizable: params.autoPlace,\r\n    hideable: params.autoPlace\r\n  });\r\n  if (!Common.isUndefined(params.load)) {\r\n    if (params.preset) {\r\n      params.load.preset = params.preset;\r\n    }\r\n  } else {\r\n    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\r\n  }\r\n  if (Common.isUndefined(params.parent) && params.hideable) {\r\n    hideableGuis.push(this);\r\n  }\r\n  params.resizable = Common.isUndefined(params.parent) && params.resizable;\r\n  if (params.autoPlace && Common.isUndefined(params.scrollable)) {\r\n    params.scrollable = true;\r\n  }\r\n  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\r\n  var saveToLocalStorage = void 0;\r\n  var titleRow = void 0;\r\n  Object.defineProperties(this,\r\n  {\r\n    parent: {\r\n      get: function get$$1() {\r\n        return params.parent;\r\n      }\r\n    },\r\n    scrollable: {\r\n      get: function get$$1() {\r\n        return params.scrollable;\r\n      }\r\n    },\r\n    autoPlace: {\r\n      get: function get$$1() {\r\n        return params.autoPlace;\r\n      }\r\n    },\r\n    closeOnTop: {\r\n      get: function get$$1() {\r\n        return params.closeOnTop;\r\n      }\r\n    },\r\n    preset: {\r\n      get: function get$$1() {\r\n        if (_this.parent) {\r\n          return _this.getRoot().preset;\r\n        }\r\n        return params.load.preset;\r\n      },\r\n      set: function set$$1(v) {\r\n        if (_this.parent) {\r\n          _this.getRoot().preset = v;\r\n        } else {\r\n          params.load.preset = v;\r\n        }\r\n        setPresetSelectIndex(this);\r\n        _this.revert();\r\n      }\r\n    },\r\n    width: {\r\n      get: function get$$1() {\r\n        return params.width;\r\n      },\r\n      set: function set$$1(v) {\r\n        params.width = v;\r\n        setWidth(_this, v);\r\n      }\r\n    },\r\n    name: {\r\n      get: function get$$1() {\r\n        return params.name;\r\n      },\r\n      set: function set$$1(v) {\r\n        params.name = v;\r\n        if (titleRow) {\r\n          titleRow.innerHTML = params.name;\r\n        }\r\n      }\r\n    },\r\n    closed: {\r\n      get: function get$$1() {\r\n        return params.closed;\r\n      },\r\n      set: function set$$1(v) {\r\n        params.closed = v;\r\n        if (params.closed) {\r\n          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\r\n        } else {\r\n          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\r\n        }\r\n        this.onResize();\r\n        if (_this.__closeButton) {\r\n          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\r\n        }\r\n      }\r\n    },\r\n    load: {\r\n      get: function get$$1() {\r\n        return params.load;\r\n      }\r\n    },\r\n    useLocalStorage: {\r\n      get: function get$$1() {\r\n        return useLocalStorage;\r\n      },\r\n      set: function set$$1(bool) {\r\n        if (SUPPORTS_LOCAL_STORAGE) {\r\n          useLocalStorage = bool;\r\n          if (bool) {\r\n            dom.bind(window, 'unload', saveToLocalStorage);\r\n          } else {\r\n            dom.unbind(window, 'unload', saveToLocalStorage);\r\n          }\r\n          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\r\n        }\r\n      }\r\n    }\r\n  });\r\n  if (Common.isUndefined(params.parent)) {\r\n    this.closed = params.closed || false;\r\n    dom.addClass(this.domElement, GUI.CLASS_MAIN);\r\n    dom.makeSelectable(this.domElement, false);\r\n    if (SUPPORTS_LOCAL_STORAGE) {\r\n      if (useLocalStorage) {\r\n        _this.useLocalStorage = true;\r\n        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\r\n        if (savedGui) {\r\n          params.load = JSON.parse(savedGui);\r\n        }\r\n      }\r\n    }\r\n    this.__closeButton = document.createElement('div');\r\n    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\r\n    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\r\n    if (params.closeOnTop) {\r\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);\r\n      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);\r\n    } else {\r\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);\r\n      this.domElement.appendChild(this.__closeButton);\r\n    }\r\n    dom.bind(this.__closeButton, 'click', function () {\r\n      _this.closed = !_this.closed;\r\n    });\r\n  } else {\r\n    if (params.closed === undefined) {\r\n      params.closed = true;\r\n    }\r\n    var titleRowName = document.createTextNode(params.name);\r\n    dom.addClass(titleRowName, 'controller-name');\r\n    titleRow = addRow(_this, titleRowName);\r\n    var onClickTitle = function onClickTitle(e) {\r\n      e.preventDefault();\r\n      _this.closed = !_this.closed;\r\n      return false;\r\n    };\r\n    dom.addClass(this.__ul, GUI.CLASS_CLOSED);\r\n    dom.addClass(titleRow, 'title');\r\n    dom.bind(titleRow, 'click', onClickTitle);\r\n    if (!params.closed) {\r\n      this.closed = false;\r\n    }\r\n  }\r\n  if (params.autoPlace) {\r\n    if (Common.isUndefined(params.parent)) {\r\n      if (autoPlaceVirgin) {\r\n        autoPlaceContainer = document.createElement('div');\r\n        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);\r\n        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);\r\n        document.body.appendChild(autoPlaceContainer);\r\n        autoPlaceVirgin = false;\r\n      }\r\n      autoPlaceContainer.appendChild(this.domElement);\r\n      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\r\n    }\r\n    if (!this.parent) {\r\n      setWidth(_this, params.width);\r\n    }\r\n  }\r\n  this.__resizeHandler = function () {\r\n    _this.onResizeDebounced();\r\n  };\r\n  dom.bind(window, 'resize', this.__resizeHandler);\r\n  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);\r\n  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);\r\n  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);\r\n  this.onResize();\r\n  if (params.resizable) {\r\n    addResizeHandle(this);\r\n  }\r\n  saveToLocalStorage = function saveToLocalStorage() {\r\n    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {\r\n      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\r\n    }\r\n  };\r\n  this.saveToLocalStorageIfPossible = saveToLocalStorage;\r\n  function resetWidth() {\r\n    var root = _this.getRoot();\r\n    root.width += 1;\r\n    Common.defer(function () {\r\n      root.width -= 1;\r\n    });\r\n  }\r\n  if (!params.parent) {\r\n    resetWidth();\r\n  }\r\n};\r\nGUI.toggleHide = function () {\r\n  hide = !hide;\r\n  Common.each(hideableGuis, function (gui) {\r\n    gui.domElement.style.display = hide ? 'none' : '';\r\n  });\r\n};\r\nGUI.CLASS_AUTO_PLACE = 'a';\r\nGUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\r\nGUI.CLASS_MAIN = 'main';\r\nGUI.CLASS_CONTROLLER_ROW = 'cr';\r\nGUI.CLASS_TOO_TALL = 'taller-than-window';\r\nGUI.CLASS_CLOSED = 'closed';\r\nGUI.CLASS_CLOSE_BUTTON = 'close-button';\r\nGUI.CLASS_CLOSE_TOP = 'close-top';\r\nGUI.CLASS_CLOSE_BOTTOM = 'close-bottom';\r\nGUI.CLASS_DRAG = 'drag';\r\nGUI.DEFAULT_WIDTH = 245;\r\nGUI.TEXT_CLOSED = 'Close Controls';\r\nGUI.TEXT_OPEN = 'Open Controls';\r\nGUI._keydownHandler = function (e) {\r\n  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {\r\n    GUI.toggleHide();\r\n  }\r\n};\r\ndom.bind(window, 'keydown', GUI._keydownHandler, false);\r\nCommon.extend(GUI.prototype,\r\n{\r\n  add: function add(object, property) {\r\n    return _add(this, object, property, {\r\n      factoryArgs: Array.prototype.slice.call(arguments, 2)\r\n    });\r\n  },\r\n  addColor: function addColor(object, property) {\r\n    return _add(this, object, property, {\r\n      color: true\r\n    });\r\n  },\r\n  remove: function remove(controller) {\r\n    this.__ul.removeChild(controller.__li);\r\n    this.__controllers.splice(this.__controllers.indexOf(controller), 1);\r\n    var _this = this;\r\n    Common.defer(function () {\r\n      _this.onResize();\r\n    });\r\n  },\r\n  destroy: function destroy() {\r\n    if (this.parent) {\r\n      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');\r\n    }\r\n    if (this.autoPlace) {\r\n      autoPlaceContainer.removeChild(this.domElement);\r\n    }\r\n    var _this = this;\r\n    Common.each(this.__folders, function (subfolder) {\r\n      _this.removeFolder(subfolder);\r\n    });\r\n    dom.unbind(window, 'keydown', GUI._keydownHandler, false);\r\n    removeListeners(this);\r\n  },\r\n  addFolder: function addFolder(name) {\r\n    if (this.__folders[name] !== undefined) {\r\n      throw new Error('You already have a folder in this GUI by the' + ' name \"' + name + '\"');\r\n    }\r\n    var newGuiParams = { name: name, parent: this };\r\n    newGuiParams.autoPlace = this.autoPlace;\r\n    if (this.load &&\r\n    this.load.folders &&\r\n    this.load.folders[name]) {\r\n      newGuiParams.closed = this.load.folders[name].closed;\r\n      newGuiParams.load = this.load.folders[name];\r\n    }\r\n    var gui = new GUI(newGuiParams);\r\n    this.__folders[name] = gui;\r\n    var li = addRow(this, gui.domElement);\r\n    dom.addClass(li, 'folder');\r\n    return gui;\r\n  },\r\n  removeFolder: function removeFolder(folder) {\r\n    this.__ul.removeChild(folder.domElement.parentElement);\r\n    delete this.__folders[folder.name];\r\n    if (this.load &&\r\n    this.load.folders &&\r\n    this.load.folders[folder.name]) {\r\n      delete this.load.folders[folder.name];\r\n    }\r\n    removeListeners(folder);\r\n    var _this = this;\r\n    Common.each(folder.__folders, function (subfolder) {\r\n      folder.removeFolder(subfolder);\r\n    });\r\n    Common.defer(function () {\r\n      _this.onResize();\r\n    });\r\n  },\r\n  open: function open() {\r\n    this.closed = false;\r\n  },\r\n  close: function close() {\r\n    this.closed = true;\r\n  },\r\n  hide: function hide() {\r\n    this.domElement.style.display = 'none';\r\n  },\r\n  show: function show() {\r\n    this.domElement.style.display = '';\r\n  },\r\n  onResize: function onResize() {\r\n    var root = this.getRoot();\r\n    if (root.scrollable) {\r\n      var top = dom.getOffset(root.__ul).top;\r\n      var h = 0;\r\n      Common.each(root.__ul.childNodes, function (node) {\r\n        if (!(root.autoPlace && node === root.__save_row)) {\r\n          h += dom.getHeight(node);\r\n        }\r\n      });\r\n      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\r\n        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\r\n        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\r\n      } else {\r\n        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\r\n        root.__ul.style.height = 'auto';\r\n      }\r\n    }\r\n    if (root.__resize_handle) {\r\n      Common.defer(function () {\r\n        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\r\n      });\r\n    }\r\n    if (root.__closeButton) {\r\n      root.__closeButton.style.width = root.width + 'px';\r\n    }\r\n  },\r\n  onResizeDebounced: Common.debounce(function () {\r\n    this.onResize();\r\n  }, 50),\r\n  remember: function remember() {\r\n    if (Common.isUndefined(SAVE_DIALOGUE)) {\r\n      SAVE_DIALOGUE = new CenteredDiv();\r\n      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;\r\n    }\r\n    if (this.parent) {\r\n      throw new Error('You can only call remember on a top level GUI.');\r\n    }\r\n    var _this = this;\r\n    Common.each(Array.prototype.slice.call(arguments), function (object) {\r\n      if (_this.__rememberedObjects.length === 0) {\r\n        addSaveMenu(_this);\r\n      }\r\n      if (_this.__rememberedObjects.indexOf(object) === -1) {\r\n        _this.__rememberedObjects.push(object);\r\n      }\r\n    });\r\n    if (this.autoPlace) {\r\n      setWidth(this, this.width);\r\n    }\r\n  },\r\n  getRoot: function getRoot() {\r\n    var gui = this;\r\n    while (gui.parent) {\r\n      gui = gui.parent;\r\n    }\r\n    return gui;\r\n  },\r\n  getSaveObject: function getSaveObject() {\r\n    var toReturn = this.load;\r\n    toReturn.closed = this.closed;\r\n    if (this.__rememberedObjects.length > 0) {\r\n      toReturn.preset = this.preset;\r\n      if (!toReturn.remembered) {\r\n        toReturn.remembered = {};\r\n      }\r\n      toReturn.remembered[this.preset] = getCurrentPreset(this);\r\n    }\r\n    toReturn.folders = {};\r\n    Common.each(this.__folders, function (element, key) {\r\n      toReturn.folders[key] = element.getSaveObject();\r\n    });\r\n    return toReturn;\r\n  },\r\n  save: function save() {\r\n    if (!this.load.remembered) {\r\n      this.load.remembered = {};\r\n    }\r\n    this.load.remembered[this.preset] = getCurrentPreset(this);\r\n    markPresetModified(this, false);\r\n    this.saveToLocalStorageIfPossible();\r\n  },\r\n  saveAs: function saveAs(presetName) {\r\n    if (!this.load.remembered) {\r\n      this.load.remembered = {};\r\n      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\r\n    }\r\n    this.load.remembered[presetName] = getCurrentPreset(this);\r\n    this.preset = presetName;\r\n    addPresetOption(this, presetName, true);\r\n    this.saveToLocalStorageIfPossible();\r\n  },\r\n  revert: function revert(gui) {\r\n    Common.each(this.__controllers, function (controller) {\r\n      if (!this.getRoot().load.remembered) {\r\n        controller.setValue(controller.initialValue);\r\n      } else {\r\n        recallSavedValue(gui || this.getRoot(), controller);\r\n      }\r\n      if (controller.__onFinishChange) {\r\n        controller.__onFinishChange.call(controller, controller.getValue());\r\n      }\r\n    }, this);\r\n    Common.each(this.__folders, function (folder) {\r\n      folder.revert(folder);\r\n    });\r\n    if (!gui) {\r\n      markPresetModified(this.getRoot(), false);\r\n    }\r\n  },\r\n  listen: function listen(controller) {\r\n    var init = this.__listening.length === 0;\r\n    this.__listening.push(controller);\r\n    if (init) {\r\n      updateDisplays(this.__listening);\r\n    }\r\n  },\r\n  updateDisplay: function updateDisplay() {\r\n    Common.each(this.__controllers, function (controller) {\r\n      controller.updateDisplay();\r\n    });\r\n    Common.each(this.__folders, function (folder) {\r\n      folder.updateDisplay();\r\n    });\r\n  }\r\n});\r\nfunction addRow(gui, newDom, liBefore) {\r\n  var li = document.createElement('li');\r\n  if (newDom) {\r\n    li.appendChild(newDom);\r\n  }\r\n  if (liBefore) {\r\n    gui.__ul.insertBefore(li, liBefore);\r\n  } else {\r\n    gui.__ul.appendChild(li);\r\n  }\r\n  gui.onResize();\r\n  return li;\r\n}\r\nfunction removeListeners(gui) {\r\n  dom.unbind(window, 'resize', gui.__resizeHandler);\r\n  if (gui.saveToLocalStorageIfPossible) {\r\n    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);\r\n  }\r\n}\r\nfunction markPresetModified(gui, modified) {\r\n  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\r\n  if (modified) {\r\n    opt.innerHTML = opt.value + '*';\r\n  } else {\r\n    opt.innerHTML = opt.value;\r\n  }\r\n}\r\nfunction augmentController(gui, li, controller) {\r\n  controller.__li = li;\r\n  controller.__gui = gui;\r\n  Common.extend(controller, {\r\n    options: function options(_options) {\r\n      if (arguments.length > 1) {\r\n        var nextSibling = controller.__li.nextElementSibling;\r\n        controller.remove();\r\n        return _add(gui, controller.object, controller.property, {\r\n          before: nextSibling,\r\n          factoryArgs: [Common.toArray(arguments)]\r\n        });\r\n      }\r\n      if (Common.isArray(_options) || Common.isObject(_options)) {\r\n        var _nextSibling = controller.__li.nextElementSibling;\r\n        controller.remove();\r\n        return _add(gui, controller.object, controller.property, {\r\n          before: _nextSibling,\r\n          factoryArgs: [_options]\r\n        });\r\n      }\r\n    },\r\n    name: function name(_name) {\r\n      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;\r\n      return controller;\r\n    },\r\n    listen: function listen() {\r\n      controller.__gui.listen(controller);\r\n      return controller;\r\n    },\r\n    remove: function remove() {\r\n      controller.__gui.remove(controller);\r\n      return controller;\r\n    }\r\n  });\r\n  if (controller instanceof NumberControllerSlider) {\r\n    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });\r\n    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {\r\n      var pc = controller[method];\r\n      var pb = box[method];\r\n      controller[method] = box[method] = function () {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        pb.apply(box, args);\r\n        return pc.apply(controller, args);\r\n      };\r\n    });\r\n    dom.addClass(li, 'has-slider');\r\n    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\r\n  } else if (controller instanceof NumberControllerBox) {\r\n    var r = function r(returned) {\r\n      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {\r\n        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;\r\n        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;\r\n        controller.remove();\r\n        var newController = _add(gui, controller.object, controller.property, {\r\n          before: controller.__li.nextElementSibling,\r\n          factoryArgs: [controller.__min, controller.__max, controller.__step]\r\n        });\r\n        newController.name(oldName);\r\n        if (wasListening) newController.listen();\r\n        return newController;\r\n      }\r\n      return returned;\r\n    };\r\n    controller.min = Common.compose(r, controller.min);\r\n    controller.max = Common.compose(r, controller.max);\r\n  } else if (controller instanceof BooleanController) {\r\n    dom.bind(li, 'click', function () {\r\n      dom.fakeEvent(controller.__checkbox, 'click');\r\n    });\r\n    dom.bind(controller.__checkbox, 'click', function (e) {\r\n      e.stopPropagation();\r\n    });\r\n  } else if (controller instanceof FunctionController) {\r\n    dom.bind(li, 'click', function () {\r\n      dom.fakeEvent(controller.__button, 'click');\r\n    });\r\n    dom.bind(li, 'mouseover', function () {\r\n      dom.addClass(controller.__button, 'hover');\r\n    });\r\n    dom.bind(li, 'mouseout', function () {\r\n      dom.removeClass(controller.__button, 'hover');\r\n    });\r\n  } else if (controller instanceof ColorController) {\r\n    dom.addClass(li, 'color');\r\n    controller.updateDisplay = Common.compose(function (val) {\r\n      li.style.borderLeftColor = controller.__color.toString();\r\n      return val;\r\n    }, controller.updateDisplay);\r\n    controller.updateDisplay();\r\n  }\r\n  controller.setValue = Common.compose(function (val) {\r\n    if (gui.getRoot().__preset_select && controller.isModified()) {\r\n      markPresetModified(gui.getRoot(), true);\r\n    }\r\n    return val;\r\n  }, controller.setValue);\r\n}\r\nfunction recallSavedValue(gui, controller) {\r\n  var root = gui.getRoot();\r\n  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);\r\n  if (matchedIndex !== -1) {\r\n    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];\r\n    if (controllerMap === undefined) {\r\n      controllerMap = {};\r\n      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;\r\n    }\r\n    controllerMap[controller.property] = controller;\r\n    if (root.load && root.load.remembered) {\r\n      var presetMap = root.load.remembered;\r\n      var preset = void 0;\r\n      if (presetMap[gui.preset]) {\r\n        preset = presetMap[gui.preset];\r\n      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {\r\n        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];\r\n      } else {\r\n        return;\r\n      }\r\n      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {\r\n        var value = preset[matchedIndex][controller.property];\r\n        controller.initialValue = value;\r\n        controller.setValue(value);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction _add(gui, object, property, params) {\r\n  if (object[property] === undefined) {\r\n    throw new Error('Object \"' + object + '\" has no property \"' + property + '\"');\r\n  }\r\n  var controller = void 0;\r\n  if (params.color) {\r\n    controller = new ColorController(object, property);\r\n  } else {\r\n    var factoryArgs = [object, property].concat(params.factoryArgs);\r\n    controller = ControllerFactory.apply(gui, factoryArgs);\r\n  }\r\n  if (params.before instanceof Controller) {\r\n    params.before = params.before.__li;\r\n  }\r\n  recallSavedValue(gui, controller);\r\n  dom.addClass(controller.domElement, 'c');\r\n  var name = document.createElement('span');\r\n  dom.addClass(name, 'property-name');\r\n  name.innerHTML = controller.property;\r\n  var container = document.createElement('div');\r\n  container.appendChild(name);\r\n  container.appendChild(controller.domElement);\r\n  var li = addRow(gui, container, params.before);\r\n  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\r\n  if (controller instanceof ColorController) {\r\n    dom.addClass(li, 'color');\r\n  } else {\r\n    dom.addClass(li, _typeof(controller.getValue()));\r\n  }\r\n  augmentController(gui, li, controller);\r\n  gui.__controllers.push(controller);\r\n  return controller;\r\n}\r\nfunction getLocalStorageHash(gui, key) {\r\n  return document.location.href + '.' + key;\r\n}\r\nfunction addPresetOption(gui, name, setSelected) {\r\n  var opt = document.createElement('option');\r\n  opt.innerHTML = name;\r\n  opt.value = name;\r\n  gui.__preset_select.appendChild(opt);\r\n  if (setSelected) {\r\n    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\r\n  }\r\n}\r\nfunction showHideExplain(gui, explain) {\r\n  explain.style.display = gui.useLocalStorage ? 'block' : 'none';\r\n}\r\nfunction addSaveMenu(gui) {\r\n  var div = gui.__save_row = document.createElement('li');\r\n  dom.addClass(gui.domElement, 'has-save');\r\n  gui.__ul.insertBefore(div, gui.__ul.firstChild);\r\n  dom.addClass(div, 'save-row');\r\n  var gears = document.createElement('span');\r\n  gears.innerHTML = '&nbsp;';\r\n  dom.addClass(gears, 'button gears');\r\n  var button = document.createElement('span');\r\n  button.innerHTML = 'Save';\r\n  dom.addClass(button, 'button');\r\n  dom.addClass(button, 'save');\r\n  var button2 = document.createElement('span');\r\n  button2.innerHTML = 'New';\r\n  dom.addClass(button2, 'button');\r\n  dom.addClass(button2, 'save-as');\r\n  var button3 = document.createElement('span');\r\n  button3.innerHTML = 'Revert';\r\n  dom.addClass(button3, 'button');\r\n  dom.addClass(button3, 'revert');\r\n  var select = gui.__preset_select = document.createElement('select');\r\n  if (gui.load && gui.load.remembered) {\r\n    Common.each(gui.load.remembered, function (value, key) {\r\n      addPresetOption(gui, key, key === gui.preset);\r\n    });\r\n  } else {\r\n    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\r\n  }\r\n  dom.bind(select, 'change', function () {\r\n    for (var index = 0; index < gui.__preset_select.length; index++) {\r\n      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\r\n    }\r\n    gui.preset = this.value;\r\n  });\r\n  div.appendChild(select);\r\n  div.appendChild(gears);\r\n  div.appendChild(button);\r\n  div.appendChild(button2);\r\n  div.appendChild(button3);\r\n  if (SUPPORTS_LOCAL_STORAGE) {\r\n    var explain = document.getElementById('dg-local-explain');\r\n    var localStorageCheckBox = document.getElementById('dg-local-storage');\r\n    var saveLocally = document.getElementById('dg-save-locally');\r\n    saveLocally.style.display = 'block';\r\n    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\r\n      localStorageCheckBox.setAttribute('checked', 'checked');\r\n    }\r\n    showHideExplain(gui, explain);\r\n    dom.bind(localStorageCheckBox, 'change', function () {\r\n      gui.useLocalStorage = !gui.useLocalStorage;\r\n      showHideExplain(gui, explain);\r\n    });\r\n  }\r\n  var newConstructorTextArea = document.getElementById('dg-new-constructor');\r\n  dom.bind(newConstructorTextArea, 'keydown', function (e) {\r\n    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {\r\n      SAVE_DIALOGUE.hide();\r\n    }\r\n  });\r\n  dom.bind(gears, 'click', function () {\r\n    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\r\n    SAVE_DIALOGUE.show();\r\n    newConstructorTextArea.focus();\r\n    newConstructorTextArea.select();\r\n  });\r\n  dom.bind(button, 'click', function () {\r\n    gui.save();\r\n  });\r\n  dom.bind(button2, 'click', function () {\r\n    var presetName = prompt('Enter a new preset name.');\r\n    if (presetName) {\r\n      gui.saveAs(presetName);\r\n    }\r\n  });\r\n  dom.bind(button3, 'click', function () {\r\n    gui.revert();\r\n  });\r\n}\r\nfunction addResizeHandle(gui) {\r\n  var pmouseX = void 0;\r\n  gui.__resize_handle = document.createElement('div');\r\n  Common.extend(gui.__resize_handle.style, {\r\n    width: '6px',\r\n    marginLeft: '-3px',\r\n    height: '200px',\r\n    cursor: 'ew-resize',\r\n    position: 'absolute'\r\n  });\r\n  function drag(e) {\r\n    e.preventDefault();\r\n    gui.width += pmouseX - e.clientX;\r\n    gui.onResize();\r\n    pmouseX = e.clientX;\r\n    return false;\r\n  }\r\n  function dragStop() {\r\n    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\r\n    dom.unbind(window, 'mousemove', drag);\r\n    dom.unbind(window, 'mouseup', dragStop);\r\n  }\r\n  function dragStart(e) {\r\n    e.preventDefault();\r\n    pmouseX = e.clientX;\r\n    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\r\n    dom.bind(window, 'mousemove', drag);\r\n    dom.bind(window, 'mouseup', dragStop);\r\n    return false;\r\n  }\r\n  dom.bind(gui.__resize_handle, 'mousedown', dragStart);\r\n  dom.bind(gui.__closeButton, 'mousedown', dragStart);\r\n  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\r\n}\r\nfunction setWidth(gui, w) {\r\n  gui.domElement.style.width = w + 'px';\r\n  if (gui.__save_row && gui.autoPlace) {\r\n    gui.__save_row.style.width = w + 'px';\r\n  }\r\n  if (gui.__closeButton) {\r\n    gui.__closeButton.style.width = w + 'px';\r\n  }\r\n}\r\nfunction getCurrentPreset(gui, useInitialValues) {\r\n  var toReturn = {};\r\n  Common.each(gui.__rememberedObjects, function (val, index) {\r\n    var savedValues = {};\r\n    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];\r\n    Common.each(controllerMap, function (controller, property) {\r\n      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();\r\n    });\r\n    toReturn[index] = savedValues;\r\n  });\r\n  return toReturn;\r\n}\r\nfunction setPresetSelectIndex(gui) {\r\n  for (var index = 0; index < gui.__preset_select.length; index++) {\r\n    if (gui.__preset_select[index].value === gui.preset) {\r\n      gui.__preset_select.selectedIndex = index;\r\n    }\r\n  }\r\n}\r\nfunction updateDisplays(controllerArray) {\r\n  if (controllerArray.length !== 0) {\r\n    requestAnimationFrame$1.call(window, function () {\r\n      updateDisplays(controllerArray);\r\n    });\r\n  }\r\n  Common.each(controllerArray, function (c) {\r\n    c.updateDisplay();\r\n  });\r\n}\r\n\r\nvar color = {\r\n  Color: Color,\r\n  math: ColorMath,\r\n  interpret: interpret\r\n};\r\nvar controllers = {\r\n  Controller: Controller,\r\n  BooleanController: BooleanController,\r\n  OptionController: OptionController,\r\n  StringController: StringController,\r\n  NumberController: NumberController,\r\n  NumberControllerBox: NumberControllerBox,\r\n  NumberControllerSlider: NumberControllerSlider,\r\n  FunctionController: FunctionController,\r\n  ColorController: ColorController\r\n};\r\nvar dom$1 = { dom: dom };\r\nvar gui = { GUI: GUI };\r\nvar GUI$1 = GUI;\r\nvar index = {\r\n  color: color,\r\n  controllers: controllers,\r\n  dom: dom$1,\r\n  gui: gui,\r\n  GUI: GUI$1\r\n};\r\n\r\n\r\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (index)));\r\n//# sourceMappingURL=dat.gui.module.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29zY2lsbG9zY29wZS1zaW11bGF0b3IvRDpcXFVzZXJzXFxhc3VzXFxEZXNrdG9wXFx3ZWLpobnnm65cXGRlbW8xXFxub2RlX21vZHVsZXNcXGRhdC5ndWlcXGJ1aWxkXFxkYXQuZ3VpLm1vZHVsZS5qcz9kNDgyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRhYXJ0cy9kYXQuZ3VpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIF9fXyRpbnNlcnRTdHlsZShjc3MpIHtcclxuICBpZiAoIWNzcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcblxyXG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xyXG4gIHN0eWxlLmlubmVySFRNTCA9IGNzcztcclxuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuXHJcbiAgcmV0dXJuIGNzcztcclxufVxyXG5cclxuZnVuY3Rpb24gY29sb3JUb1N0cmluZyAoY29sb3IsIGZvcmNlQ1NTSGV4KSB7XHJcbiAgdmFyIGNvbG9yRm9ybWF0ID0gY29sb3IuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpO1xyXG4gIHZhciByID0gTWF0aC5yb3VuZChjb2xvci5yKTtcclxuICB2YXIgZyA9IE1hdGgucm91bmQoY29sb3IuZyk7XHJcbiAgdmFyIGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIpO1xyXG4gIHZhciBhID0gY29sb3IuYTtcclxuICB2YXIgaCA9IE1hdGgucm91bmQoY29sb3IuaCk7XHJcbiAgdmFyIHMgPSBjb2xvci5zLnRvRml4ZWQoMSk7XHJcbiAgdmFyIHYgPSBjb2xvci52LnRvRml4ZWQoMSk7XHJcbiAgaWYgKGZvcmNlQ1NTSGV4IHx8IGNvbG9yRm9ybWF0ID09PSAnVEhSRUVfQ0hBUl9IRVgnIHx8IGNvbG9yRm9ybWF0ID09PSAnU0lYX0NIQVJfSEVYJykge1xyXG4gICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XHJcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDYpIHtcclxuICAgICAgc3RyID0gJzAnICsgc3RyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcjJyArIHN0cjtcclxuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQicpIHtcclxuICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XHJcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0NTU19SR0JBJykge1xyXG4gICAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xyXG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XHJcbiAgICByZXR1cm4gJzB4JyArIGNvbG9yLmhleC50b1N0cmluZygxNik7XHJcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9BUlJBWScpIHtcclxuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XHJcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfQVJSQVknKSB7XHJcbiAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICddJztcclxuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcclxuICAgIHJldHVybiAne3I6JyArIHIgKyAnLGc6JyArIGcgKyAnLGI6JyArIGIgKyAnfSc7XHJcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfT0JKJykge1xyXG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9JztcclxuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnSFNWX09CSicpIHtcclxuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnfSc7XHJcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xyXG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICcsYTonICsgYSArICd9JztcclxuICB9XHJcbiAgcmV0dXJuICd1bmtub3duIGZvcm1hdCc7XHJcbn1cclxuXHJcbnZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xyXG52YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG52YXIgQ29tbW9uID0ge1xyXG4gIEJSRUFLOiB7fSxcclxuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcclxuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xyXG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcclxuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH0sXHJcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xyXG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIGtleXMgPSB0aGlzLmlzT2JqZWN0KG9iaikgPyBPYmplY3Qua2V5cyhvYmopIDogW107XHJcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSB7XHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9LFxyXG4gIGNvbXBvc2U6IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XHJcbiAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJnc1swXTtcclxuICAgIH07XHJcbiAgfSxcclxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRyLCBzY29wZSkge1xyXG4gICAgaWYgKCFvYmopIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkge1xyXG4gICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcclxuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcclxuICAgICAgdmFyIGtleSA9IHZvaWQgMDtcclxuICAgICAgdmFyIGwgPSB2b2lkIDA7XHJcbiAgICAgIGZvciAoa2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKSB7XHJcbiAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChpdHIuY2FsbChzY29wZSwgb2JqW19rZXldLCBfa2V5KSA9PT0gdGhpcy5CUkVBSykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVmZXI6IGZ1bmN0aW9uIGRlZmVyKGZuYykge1xyXG4gICAgc2V0VGltZW91dChmbmMsIDApO1xyXG4gIH0sXHJcbiAgZGVib3VuY2U6IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHRocmVzaG9sZCwgY2FsbEltbWVkaWF0ZWx5KSB7XHJcbiAgICB2YXIgdGltZW91dCA9IHZvaWQgMDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBvYmogPSB0aGlzO1xyXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcclxuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICBpZiAoIWNhbGxJbW1lZGlhdGVseSkgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjYWxsTm93ID0gY2FsbEltbWVkaWF0ZWx5IHx8ICF0aW1lb3V0O1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XHJcbiAgICAgIGlmIChjYWxsTm93KSB7XHJcbiAgICAgICAgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcclxuICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XHJcbiAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcclxuICB9LFxyXG4gIGlzVW5kZWZpbmVkOiBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcclxuICB9LFxyXG4gIGlzTnVsbDogZnVuY3Rpb24gaXNOdWxsKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcclxuICB9LFxyXG4gIGlzTmFOOiBmdW5jdGlvbiAoX2lzTmFOKSB7XHJcbiAgICBmdW5jdGlvbiBpc05hTihfeCkge1xyXG4gICAgICByZXR1cm4gX2lzTmFOLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBpc05hTi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9pc05hTi50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBpc05hTjtcclxuICB9KGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBpc05hTihvYmopO1xyXG4gIH0pLFxyXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XHJcbiAgfSxcclxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcclxuICB9LFxyXG4gIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IG9iaiArIDA7XHJcbiAgfSxcclxuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAnJztcclxuICB9LFxyXG4gIGlzQm9vbGVhbjogZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xyXG4gIH0sXHJcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBGdW5jdGlvbjtcclxuICB9XHJcbn07XHJcblxyXG52YXIgSU5URVJQUkVUQVRJT05TID0gW1xyXG57XHJcbiAgbGl0bXVzOiBDb21tb24uaXNTdHJpbmcsXHJcbiAgY29udmVyc2lvbnM6IHtcclxuICAgIFRIUkVFX0NIQVJfSEVYOiB7XHJcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcclxuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XHJcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNwYWNlOiAnSEVYJyxcclxuICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSwgMClcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xyXG4gICAgfSxcclxuICAgIFNJWF9DSEFSX0hFWDoge1xyXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcclxuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxyXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpLCAwKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXHJcbiAgICB9LFxyXG4gICAgQ1NTX1JHQjoge1xyXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqXFwpLyk7XHJcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcclxuICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXHJcbiAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxyXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXHJcbiAgICB9LFxyXG4gICAgQ1NTX1JHQkE6IHtcclxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xyXG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JhXFwoXFxzKihcXFMrKVxccyosXFxzKihcXFMrKVxccyosXFxzKihcXFMrKVxccyosXFxzKihcXFMrKVxccypcXCkvKTtcclxuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxyXG4gICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcclxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXHJcbiAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxyXG4gICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXHJcbiAgICB9XHJcbiAgfVxyXG59LFxyXG57XHJcbiAgbGl0bXVzOiBDb21tb24uaXNOdW1iZXIsXHJcbiAgY29udmVyc2lvbnM6IHtcclxuICAgIEhFWDoge1xyXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNwYWNlOiAnSEVYJyxcclxuICAgICAgICAgIGhleDogb3JpZ2luYWwsXHJcbiAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59LFxyXG57XHJcbiAgbGl0bXVzOiBDb21tb24uaXNBcnJheSxcclxuICBjb252ZXJzaW9uczoge1xyXG4gICAgUkdCX0FSUkFZOiB7XHJcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcclxuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXHJcbiAgICAgICAgICByOiBvcmlnaW5hbFswXSxcclxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxyXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl1cclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgUkdCQV9BUlJBWToge1xyXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gNCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXHJcbiAgICAgICAgICByOiBvcmlnaW5hbFswXSxcclxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxyXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl0sXHJcbiAgICAgICAgICBhOiBvcmlnaW5hbFszXVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xyXG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0sXHJcbntcclxuICBsaXRtdXM6IENvbW1vbi5pc09iamVjdCxcclxuICBjb252ZXJzaW9uczoge1xyXG4gICAgUkdCQV9PQko6IHtcclxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xyXG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcclxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcclxuICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcclxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcclxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LFxyXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcjogY29sb3IucixcclxuICAgICAgICAgIGc6IGNvbG9yLmcsXHJcbiAgICAgICAgICBiOiBjb2xvci5iLFxyXG4gICAgICAgICAgYTogY29sb3IuYVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBSR0JfT0JKOiB7XHJcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcclxuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcclxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcclxuICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcclxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LFxyXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcjogY29sb3IucixcclxuICAgICAgICAgIGc6IGNvbG9yLmcsXHJcbiAgICAgICAgICBiOiBjb2xvci5iXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIEhTVkFfT0JKOiB7XHJcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcclxuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXHJcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXHJcbiAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXHJcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXHJcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSxcclxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGg6IGNvbG9yLmgsXHJcbiAgICAgICAgICBzOiBjb2xvci5zLFxyXG4gICAgICAgICAgdjogY29sb3IudixcclxuICAgICAgICAgIGE6IGNvbG9yLmFcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgSFNWX09CSjoge1xyXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXHJcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXHJcbiAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXHJcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSxcclxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGg6IGNvbG9yLmgsXHJcbiAgICAgICAgICBzOiBjb2xvci5zLFxyXG4gICAgICAgICAgdjogY29sb3IudlxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1dO1xyXG52YXIgcmVzdWx0ID0gdm9pZCAwO1xyXG52YXIgdG9SZXR1cm4gPSB2b2lkIDA7XHJcbnZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiBpbnRlcnByZXQoKSB7XHJcbiAgdG9SZXR1cm4gPSBmYWxzZTtcclxuICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IENvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XHJcbiAgQ29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbiAoZmFtaWx5KSB7XHJcbiAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcclxuICAgICAgQ29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbiAoY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcclxuICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xyXG4gICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XHJcbiAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcclxuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcclxuICAgICAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIENvbW1vbi5CUkVBSztcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gdG9SZXR1cm47XHJcbn07XHJcblxyXG52YXIgdG1wQ29tcG9uZW50ID0gdm9pZCAwO1xyXG52YXIgQ29sb3JNYXRoID0ge1xyXG4gIGhzdl90b19yZ2I6IGZ1bmN0aW9uIGhzdl90b19yZ2IoaCwgcywgdikge1xyXG4gICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcclxuICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xyXG4gICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xyXG4gICAgdmFyIHEgPSB2ICogKDEuMCAtIGYgKiBzKTtcclxuICAgIHZhciB0ID0gdiAqICgxLjAgLSAoMS4wIC0gZikgKiBzKTtcclxuICAgIHZhciBjID0gW1t2LCB0LCBwXSwgW3EsIHYsIHBdLCBbcCwgdiwgdF0sIFtwLCBxLCB2XSwgW3QsIHAsIHZdLCBbdiwgcCwgcV1dW2hpXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHI6IGNbMF0gKiAyNTUsXHJcbiAgICAgIGc6IGNbMV0gKiAyNTUsXHJcbiAgICAgIGI6IGNbMl0gKiAyNTVcclxuICAgIH07XHJcbiAgfSxcclxuICByZ2JfdG9faHN2OiBmdW5jdGlvbiByZ2JfdG9faHN2KHIsIGcsIGIpIHtcclxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcclxuICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcclxuICAgIHZhciBoID0gdm9pZCAwO1xyXG4gICAgdmFyIHMgPSB2b2lkIDA7XHJcbiAgICBpZiAobWF4ICE9PSAwKSB7XHJcbiAgICAgIHMgPSBkZWx0YSAvIG1heDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaDogTmFOLFxyXG4gICAgICAgIHM6IDAsXHJcbiAgICAgICAgdjogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHIgPT09IG1heCkge1xyXG4gICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xyXG4gICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcclxuICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcclxuICAgIH1cclxuICAgIGggLz0gNjtcclxuICAgIGlmIChoIDwgMCkge1xyXG4gICAgICBoICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBoOiBoICogMzYwLFxyXG4gICAgICBzOiBzLFxyXG4gICAgICB2OiBtYXggLyAyNTVcclxuICAgIH07XHJcbiAgfSxcclxuICByZ2JfdG9faGV4OiBmdW5jdGlvbiByZ2JfdG9faGV4KHIsIGcsIGIpIHtcclxuICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcclxuICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XHJcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xyXG4gICAgcmV0dXJuIGhleDtcclxuICB9LFxyXG4gIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24gY29tcG9uZW50X2Zyb21faGV4KGhleCwgY29tcG9uZW50SW5kZXgpIHtcclxuICAgIHJldHVybiBoZXggPj4gY29tcG9uZW50SW5kZXggKiA4ICYgMHhGRjtcclxuICB9LFxyXG4gIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24gaGV4X3dpdGhfY29tcG9uZW50KGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCBoZXggJiB+KDB4RkYgPDwgdG1wQ29tcG9uZW50KTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xyXG4gIHJldHVybiB0eXBlb2Ygb2JqO1xyXG59IDogZnVuY3Rpb24gKG9iaikge1xyXG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcclxuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xyXG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xyXG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gIH07XHJcbn0oKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcclxuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XHJcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xyXG5cclxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XHJcblxyXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xyXG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcclxuXHJcbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xyXG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xyXG4gIH1cclxuXHJcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XHJcbiAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcclxuICBpZiAoIXNlbGYpIHtcclxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xyXG59O1xyXG5cclxudmFyIENvbG9yID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIENvbG9yKCkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3IpO1xyXG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XHJcbiAgfVxyXG4gIGNyZWF0ZUNsYXNzKENvbG9yLCBbe1xyXG4gICAga2V5OiAndG9TdHJpbmcnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICd0b0hleFN0cmluZycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXhTdHJpbmcoKSB7XHJcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ3RvT3JpZ2luYWwnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3JpZ2luYWwoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcbiAgcmV0dXJuIENvbG9yO1xyXG59KCk7XHJcbmZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcclxuICAgICAgfVxyXG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcclxuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcclxuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcclxuICAgICAgICBDb2xvci5yZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcclxuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XHJcbiAgICAgIH1cclxuICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XHJcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XHJcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbkNvbG9yLnJlY2FsY3VsYXRlUkdCID0gZnVuY3Rpb24gKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XHJcbiAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XHJcbiAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBDb2xvck1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XHJcbiAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xyXG4gICAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBDb2xvck1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ29ycnVwdGVkIGNvbG9yIHN0YXRlJyk7XHJcbiAgfVxyXG59O1xyXG5Db2xvci5yZWNhbGN1bGF0ZUhTViA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gIHZhciByZXN1bHQgPSBDb2xvck1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcclxuICBDb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIHtcclxuICAgIHM6IHJlc3VsdC5zLFxyXG4gICAgdjogcmVzdWx0LnZcclxuICB9KTtcclxuICBpZiAoIUNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcclxuICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xyXG4gIH0gZWxzZSBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcclxuICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XHJcbiAgfVxyXG59O1xyXG5Db2xvci5DT01QT05FTlRTID0gWydyJywgJ2cnLCAnYicsICdoJywgJ3MnLCAndicsICdoZXgnLCAnYSddO1xyXG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xyXG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xyXG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xyXG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xyXG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xyXG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcclxuICB9LFxyXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcclxuICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xyXG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcclxuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IENvbG9yTWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xyXG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xyXG4gICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XHJcbiAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sbGVyKTtcclxuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcclxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcbiAgICB0aGlzLl9fb25DaGFuZ2UgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGNyZWF0ZUNsYXNzKENvbnRyb2xsZXIsIFt7XHJcbiAgICBrZXk6ICdvbkNoYW5nZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2UoZm5jKSB7XHJcbiAgICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnb25GaW5pc2hDaGFuZ2UnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRmluaXNoQ2hhbmdlKGZuYykge1xyXG4gICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSBmbmM7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ3NldFZhbHVlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgICB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XSA9IG5ld1ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcywgbmV3VmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdnZXRWYWx1ZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdpc01vZGlmaWVkJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01vZGlmaWVkKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWUgIT09IHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgIH1cclxuICB9XSk7XHJcbiAgcmV0dXJuIENvbnRyb2xsZXI7XHJcbn0oKTtcclxuXHJcbnZhciBFVkVOVF9NQVAgPSB7XHJcbiAgSFRNTEV2ZW50czogWydjaGFuZ2UnXSxcclxuICBNb3VzZUV2ZW50czogWydjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXHJcbiAgS2V5Ym9hcmRFdmVudHM6IFsna2V5ZG93biddXHJcbn07XHJcbnZhciBFVkVOVF9NQVBfSU5WID0ge307XHJcbkNvbW1vbi5lYWNoKEVWRU5UX01BUCwgZnVuY3Rpb24gKHYsIGspIHtcclxuICBDb21tb24uZWFjaCh2LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XHJcbiAgfSk7XHJcbn0pO1xyXG52YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xyXG5mdW5jdGlvbiBjc3NWYWx1ZVRvUGl4ZWxzKHZhbCkge1xyXG4gIGlmICh2YWwgPT09ICcwJyB8fCBDb21tb24uaXNVbmRlZmluZWQodmFsKSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIHZhciBtYXRjaCA9IHZhbC5tYXRjaChDU1NfVkFMVUVfUElYRUxTKTtcclxuICBpZiAoIUNvbW1vbi5pc051bGwobWF0Y2gpKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XHJcbiAgfVxyXG4gIHJldHVybiAwO1xyXG59XHJcbnZhciBkb20gPSB7XHJcbiAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlKGVsZW0sIHNlbGVjdGFibGUpIHtcclxuICAgIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbS5zdHlsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcbiAgICBlbGVtLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IDogZnVuY3Rpb24gKCkge307XHJcbiAgICBlbGVtLnN0eWxlLk1velVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xyXG4gICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xyXG4gICAgZWxlbS51bnNlbGVjdGFibGUgPSBzZWxlY3RhYmxlID8gJ29uJyA6ICdvZmYnO1xyXG4gIH0sXHJcbiAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIG1ha2VGdWxsc2NyZWVuKGVsZW0sIGhvciwgdmVydCkge1xyXG4gICAgdmFyIHZlcnRpY2FsID0gdmVydDtcclxuICAgIHZhciBob3Jpem9udGFsID0gaG9yO1xyXG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkge1xyXG4gICAgICBob3Jpem9udGFsID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB7XHJcbiAgICAgIHZlcnRpY2FsID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgaWYgKGhvcml6b250YWwpIHtcclxuICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gMDtcclxuICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAodmVydGljYWwpIHtcclxuICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xyXG4gICAgICBlbGVtLnN0eWxlLmJvdHRvbSA9IDA7XHJcbiAgICB9XHJcbiAgfSxcclxuICBmYWtlRXZlbnQ6IGZ1bmN0aW9uIGZha2VFdmVudChlbGVtLCBldmVudFR5cGUsIHBhcnMsIGF1eCkge1xyXG4gICAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XHJcbiAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xyXG4gICAgaWYgKCFjbGFzc05hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoY2xhc3NOYW1lKTtcclxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XHJcbiAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XHJcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XHJcbiAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSwgd2luZG93LCBwYXJhbXMuY2xpY2tDb3VudCB8fCAxLCAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIGNsaWVudFgsXHJcbiAgICAgICAgICBjbGllbnRZLFxyXG4gICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGluaXQgPSBldnQuaW5pdEtleWJvYXJkRXZlbnQgfHwgZXZ0LmluaXRLZXlFdmVudDtcclxuICAgICAgICAgIENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcclxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcclxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LCBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LCBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQ29tbW9uLmRlZmF1bHRzKGV2dCwgYXV4KTtcclxuICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xyXG4gIH0sXHJcbiAgYmluZDogZnVuY3Rpb24gYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xyXG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xyXG4gICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xyXG4gICAgfSBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb207XHJcbiAgfSxcclxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xyXG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xyXG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xyXG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XHJcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb207XHJcbiAgfSxcclxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xyXG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xyXG4gICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT09IC0xKSB7XHJcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvbTtcclxuICB9LFxyXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcclxuICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSBjbGFzc05hbWUpIHtcclxuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xyXG4gICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBkb207XHJcbiAgfSxcclxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKS50ZXN0KGVsZW0uY2xhc3NOYW1lKSB8fCBmYWxzZTtcclxuICB9LFxyXG4gIGdldFdpZHRoOiBmdW5jdGlvbiBnZXRXaWR0aChlbGVtKSB7XHJcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xyXG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUud2lkdGgpO1xyXG4gIH0sXHJcbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbSkge1xyXG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcclxuICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWJvdHRvbS13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctdG9wJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1ib3R0b20nXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlLmhlaWdodCk7XHJcbiAgfSxcclxuICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xyXG4gICAgdmFyIGVsZW0gPSBlbDtcclxuICAgIHZhciBvZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xyXG4gICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICBvZmZzZXQubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XHJcbiAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcclxuICAgICAgICBlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgIH0gd2hpbGUgKGVsZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9mZnNldDtcclxuICB9LFxyXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZShlbGVtKSB7XHJcbiAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoZWxlbS50eXBlIHx8IGVsZW0uaHJlZik7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIEJvb2xlYW5Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XHJcbiAgaW5oZXJpdHMoQm9vbGVhbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcclxuICBmdW5jdGlvbiBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCb29sZWFuQ29udHJvbGxlcik7XHJcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm9vbGVhbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xyXG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xyXG4gICAgX3RoaXMyLl9fcHJldiA9IF90aGlzMi5nZXRWYWx1ZSgpO1xyXG4gICAgX3RoaXMyLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgX3RoaXMyLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XHJcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcclxuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XHJcbiAgICB9XHJcbiAgICBkb20uYmluZChfdGhpczIuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XHJcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19jaGVja2JveCk7XHJcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xyXG4gICAgcmV0dXJuIF90aGlzMjtcclxuICB9XHJcbiAgY3JlYXRlQ2xhc3MoQm9vbGVhbkNvbnRyb2xsZXIsIFt7XHJcbiAgICBrZXk6ICdzZXRWYWx1ZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xyXG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCB2KTtcclxuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xyXG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgIHJldHVybiB0b1JldHVybjtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xyXG4gICAgICBpZiAodGhpcy5nZXRWYWx1ZSgpID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XHJcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX19wcmV2ID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX19wcmV2ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGdldChCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG4gIHJldHVybiBCb29sZWFuQ29udHJvbGxlcjtcclxufShDb250cm9sbGVyKTtcclxuXHJcbnZhciBPcHRpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XHJcbiAgaW5oZXJpdHMoT3B0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xyXG4gIGZ1bmN0aW9uIE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgb3B0cykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9uQ29udHJvbGxlcik7XHJcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoT3B0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcclxuICAgIHZhciBvcHRpb25zID0gb3B0cztcclxuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcclxuICAgIF90aGlzMi5fX3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xyXG4gICAgaWYgKENvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XHJcbiAgICAgIHZhciBtYXAgPSB7fTtcclxuICAgICAgQ29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xyXG4gICAgICB9KTtcclxuICAgICAgb3B0aW9ucyA9IG1hcDtcclxuICAgIH1cclxuICAgIENvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcclxuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcclxuICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XHJcbiAgICAgIF90aGlzLl9fc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XHJcbiAgICB9KTtcclxuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XHJcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcclxuICAgICAgX3RoaXMuc2V0VmFsdWUoZGVzaXJlZFZhbHVlKTtcclxuICAgIH0pO1xyXG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0KTtcclxuICAgIHJldHVybiBfdGhpczI7XHJcbiAgfVxyXG4gIGNyZWF0ZUNsYXNzKE9wdGlvbkNvbnRyb2xsZXIsIFt7XHJcbiAgICBrZXk6ICdzZXRWYWx1ZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xyXG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XHJcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcclxuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0b1JldHVybjtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xyXG4gICAgICBpZiAoZG9tLmlzQWN0aXZlKHRoaXMuX19zZWxlY3QpKSByZXR1cm4gdGhpcztcclxuICAgICAgdGhpcy5fX3NlbGVjdC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgICAgcmV0dXJuIGdldChPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1dKTtcclxuICByZXR1cm4gT3B0aW9uQ29udHJvbGxlcjtcclxufShDb250cm9sbGVyKTtcclxuXHJcbnZhciBTdHJpbmdDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XHJcbiAgaW5oZXJpdHMoU3RyaW5nQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xyXG4gIGZ1bmN0aW9uIFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nQ29udHJvbGxlcik7XHJcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaW5nQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcclxuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcclxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xyXG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcclxuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcclxuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcclxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcclxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgdGhpcy5ibHVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcclxuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcclxuICAgIHJldHVybiBfdGhpczI7XHJcbiAgfVxyXG4gIGNyZWF0ZUNsYXNzKFN0cmluZ0NvbnRyb2xsZXIsIFt7XHJcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xyXG4gICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XHJcbiAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBnZXQoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XHJcbn0oQ29udHJvbGxlcik7XHJcblxyXG5mdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XHJcbiAgdmFyIF94ID0geC50b1N0cmluZygpO1xyXG4gIGlmIChfeC5pbmRleE9mKCcuJykgPiAtMSkge1xyXG4gICAgcmV0dXJuIF94Lmxlbmd0aCAtIF94LmluZGV4T2YoJy4nKSAtIDE7XHJcbiAgfVxyXG4gIHJldHVybiAwO1xyXG59XHJcbnZhciBOdW1iZXJDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XHJcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xyXG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyKTtcclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XHJcbiAgICB2YXIgX3BhcmFtcyA9IHBhcmFtcyB8fCB7fTtcclxuICAgIF90aGlzLl9fbWluID0gX3BhcmFtcy5taW47XHJcbiAgICBfdGhpcy5fX21heCA9IF9wYXJhbXMubWF4O1xyXG4gICAgX3RoaXMuX19zdGVwID0gX3BhcmFtcy5zdGVwO1xyXG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChfdGhpcy5fX3N0ZXApKSB7XHJcbiAgICAgIGlmIChfdGhpcy5pbml0aWFsVmFsdWUgPT09IDApIHtcclxuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoX3RoaXMuaW5pdGlhbFZhbHVlKSkgLyBNYXRoLkxOMTApKSAvIDEwO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gX3RoaXMuX19zdGVwO1xyXG4gICAgfVxyXG4gICAgX3RoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhfdGhpcy5fX2ltcGxpZWRTdGVwKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlciwgW3tcclxuICAgIGtleTogJ3NldFZhbHVlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XHJcbiAgICAgIHZhciBfdiA9IHY7XHJcbiAgICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgX3YgPCB0aGlzLl9fbWluKSB7XHJcbiAgICAgICAgX3YgPSB0aGlzLl9fbWluO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX19tYXggIT09IHVuZGVmaW5lZCAmJiBfdiA+IHRoaXMuX19tYXgpIHtcclxuICAgICAgICBfdiA9IHRoaXMuX19tYXg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX19zdGVwICE9PSB1bmRlZmluZWQgJiYgX3YgJSB0aGlzLl9fc3RlcCAhPT0gMCkge1xyXG4gICAgICAgIF92ID0gTWF0aC5yb3VuZChfdiAvIHRoaXMuX19zdGVwKSAqIHRoaXMuX19zdGVwO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgX3YpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ21pbicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKG1pblZhbHVlKSB7XHJcbiAgICAgIHRoaXMuX19taW4gPSBtaW5WYWx1ZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnbWF4JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgobWF4VmFsdWUpIHtcclxuICAgICAgdGhpcy5fX21heCA9IG1heFZhbHVlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdzdGVwJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGVwKHN0ZXBWYWx1ZSkge1xyXG4gICAgICB0aGlzLl9fc3RlcCA9IHN0ZXBWYWx1ZTtcclxuICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gc3RlcFZhbHVlO1xyXG4gICAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoc3RlcFZhbHVlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xyXG59KENvbnRyb2xsZXIpO1xyXG5cclxuZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XHJcbiAgdmFyIHRlblRvID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcclxuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHRlblRvKSAvIHRlblRvO1xyXG59XHJcbnZhciBOdW1iZXJDb250cm9sbGVyQm94ID0gZnVuY3Rpb24gKF9OdW1iZXJDb250cm9sbGVyKSB7XHJcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlckJveCwgX051bWJlckNvbnRyb2xsZXIpO1xyXG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyQm94KTtcclxuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyQm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveCkpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSk7XHJcbiAgICBfdGhpczIuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XHJcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XHJcbiAgICB2YXIgcHJldlkgPSB2b2lkIDA7XHJcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcclxuICAgICAgdmFyIGF0dGVtcHRlZCA9IHBhcnNlRmxvYXQoX3RoaXMuX19pbnB1dC52YWx1ZSk7XHJcbiAgICAgIGlmICghQ29tbW9uLmlzTmFOKGF0dGVtcHRlZCkpIHtcclxuICAgICAgICBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcclxuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcclxuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XHJcbiAgICAgIG9uRmluaXNoKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XHJcbiAgICAgIHZhciBkaWZmID0gcHJldlkgLSBlLmNsaWVudFk7XHJcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLmdldFZhbHVlKCkgKyBkaWZmICogX3RoaXMuX19pbXBsaWVkU3RlcCk7XHJcbiAgICAgIHByZXZZID0gZS5jbGllbnRZO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xyXG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcclxuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcclxuICAgICAgb25GaW5pc2goKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcclxuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xyXG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcclxuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XHJcbiAgICB9XHJcbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XHJcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XHJcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xyXG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ibHVyKCk7XHJcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgb25GaW5pc2goKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xyXG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xyXG4gICAgcmV0dXJuIF90aGlzMjtcclxuICB9XHJcbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlckJveCwgW3tcclxuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XHJcbiAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID8gdGhpcy5nZXRWYWx1ZSgpIDogcm91bmRUb0RlY2ltYWwodGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9fcHJlY2lzaW9uKTtcclxuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1dKTtcclxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcclxufShOdW1iZXJDb250cm9sbGVyKTtcclxuXHJcbmZ1bmN0aW9uIG1hcCh2LCBpMSwgaTIsIG8xLCBvMikge1xyXG4gIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XHJcbn1cclxudmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcclxuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBfTnVtYmVyQ29udHJvbGxlcik7XHJcbiAgZnVuY3Rpb24gTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlclNsaWRlcik7XHJcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlclNsaWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pKTtcclxuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcclxuICAgIF90aGlzMi5fX2JhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIF90aGlzMi5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XHJcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XHJcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xyXG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2ZvcmVncm91bmQsICdzbGlkZXItZmcnKTtcclxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcclxuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XHJcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcclxuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XHJcbiAgICAgIG9uTW91c2VEcmFnKGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHZhciBiZ1JlY3QgPSBfdGhpcy5fX2JhY2tncm91bmQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChlLmNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XHJcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xyXG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xyXG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xyXG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcclxuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcclxuICAgICAgb25Ub3VjaE1vdmUoZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XHJcbiAgICAgIHZhciBjbGllbnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XHJcbiAgICAgIHZhciBiZ1JlY3QgPSBfdGhpcy5fX2JhY2tncm91bmQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChjbGllbnRYLCBiZ1JlY3QubGVmdCwgYmdSZWN0LnJpZ2h0LCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XHJcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xyXG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XHJcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XHJcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcclxuICAgIF90aGlzMi5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZm9yZWdyb3VuZCk7XHJcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19iYWNrZ3JvdW5kKTtcclxuICAgIHJldHVybiBfdGhpczI7XHJcbiAgfVxyXG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIFt7XHJcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xyXG4gICAgICB2YXIgcGN0ID0gKHRoaXMuZ2V0VmFsdWUoKSAtIHRoaXMuX19taW4pIC8gKHRoaXMuX19tYXggLSB0aGlzLl9fbWluKTtcclxuICAgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QgKiAxMDAgKyAnJSc7XHJcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XHJcbn0oTnVtYmVyQ29udHJvbGxlcik7XHJcblxyXG52YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XHJcbiAgaW5oZXJpdHMoRnVuY3Rpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XHJcbiAgZnVuY3Rpb24gRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIHRleHQpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQ29udHJvbGxlcik7XHJcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRnVuY3Rpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb25Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XHJcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XHJcbiAgICBfdGhpczIuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIF90aGlzMi5fX2J1dHRvbi5pbm5lckhUTUwgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyAnRmlyZScgOiB0ZXh0O1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIF90aGlzLmZpcmUoKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYnV0dG9uLCAnYnV0dG9uJyk7XHJcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19idXR0b24pO1xyXG4gICAgcmV0dXJuIF90aGlzMjtcclxuICB9XHJcbiAgY3JlYXRlQ2xhc3MoRnVuY3Rpb25Db250cm9sbGVyLCBbe1xyXG4gICAga2V5OiAnZmlyZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xyXG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZ2V0VmFsdWUoKS5jYWxsKHRoaXMub2JqZWN0KTtcclxuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xyXG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XSk7XHJcbiAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcclxufShDb250cm9sbGVyKTtcclxuXHJcbnZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcclxuICBpbmhlcml0cyhDb2xvckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcclxuICBmdW5jdGlvbiBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JDb250cm9sbGVyKTtcclxuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcclxuICAgIF90aGlzMi5fX2NvbG9yID0gbmV3IENvbG9yKF90aGlzMi5nZXRWYWx1ZSgpKTtcclxuICAgIF90aGlzMi5fX3RlbXAgPSBuZXcgQ29sb3IoMCk7XHJcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XHJcbiAgICBfdGhpczIuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKF90aGlzMi5kb21FbGVtZW50LCBmYWxzZSk7XHJcbiAgICBfdGhpczIuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuY2xhc3NOYW1lID0gJ3NlbGVjdG9yJztcclxuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xyXG4gICAgX3RoaXMyLl9fZmllbGRfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgX3RoaXMyLl9fZmllbGRfa25vYi5jbGFzc05hbWUgPSAnZmllbGQta25vYic7XHJcbiAgICBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcclxuICAgIF90aGlzMi5fX2h1ZV9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBfdGhpczIuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xyXG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBfdGhpczIuX19odWVfZmllbGQuY2xhc3NOYW1lID0gJ2h1ZS1maWVsZCc7XHJcbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBfdGhpczIuX19pbnB1dC50eXBlID0gJ3RleHQnO1xyXG4gICAgX3RoaXMyLl9faW5wdXRfdGV4dFNoYWRvdyA9ICcwIDFweCAxcHggJztcclxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgb25CbHVyLmNhbGwodGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcclxuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3RvciwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLCAnZHJhZycpLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19zZWxlY3Rvci5zdHlsZSwge1xyXG4gICAgICB3aWR0aDogJzEyMnB4JyxcclxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxyXG4gICAgICBwYWRkaW5nOiAnM3B4JyxcclxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzIyMicsXHJcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcclxuICAgIH0pO1xyXG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19maWVsZF9rbm9iLnN0eWxlLCB7XHJcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICB3aWR0aDogJzEycHgnLFxyXG4gICAgICBoZWlnaHQ6ICcxMnB4JyxcclxuICAgICAgYm9yZGVyOiBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciArIChfdGhpczIuX19jb2xvci52IDwgMC41ID8gJyNmZmYnIDogJyMwMDAnKSxcclxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjUpJyxcclxuICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXHJcbiAgICAgIHpJbmRleDogMVxyXG4gICAgfSk7XHJcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2h1ZV9rbm9iLnN0eWxlLCB7XHJcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICB3aWR0aDogJzE1cHgnLFxyXG4gICAgICBoZWlnaHQ6ICcycHgnLFxyXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcclxuICAgICAgekluZGV4OiAxXHJcbiAgICB9KTtcclxuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xyXG4gICAgICB3aWR0aDogJzEwMHB4JyxcclxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxyXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXHJcbiAgICAgIG1hcmdpblJpZ2h0OiAnM3B4JyxcclxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXHJcbiAgICB9KTtcclxuICAgIENvbW1vbi5leHRlbmQodmFsdWVGaWVsZC5zdHlsZSwge1xyXG4gICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgYmFja2dyb3VuZDogJ25vbmUnXHJcbiAgICB9KTtcclxuICAgIGxpbmVhckdyYWRpZW50KHZhbHVlRmllbGQsICd0b3AnLCAncmdiYSgwLDAsMCwwKScsICcjMDAwJyk7XHJcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2h1ZV9maWVsZC5zdHlsZSwge1xyXG4gICAgICB3aWR0aDogJzE1cHgnLFxyXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXHJcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcclxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJyxcclxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgIHRvcDogJzNweCcsXHJcbiAgICAgIHJpZ2h0OiAnM3B4J1xyXG4gICAgfSk7XHJcbiAgICBodWVHcmFkaWVudChfdGhpczIuX19odWVfZmllbGQpO1xyXG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19pbnB1dC5zdHlsZSwge1xyXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXHJcbiAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgIGNvbG9yOiAnI2ZmZicsXHJcbiAgICAgIGJvcmRlcjogMCxcclxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxyXG4gICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcclxuICAgIH0pO1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XHJcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XHJcbiAgICBkb20uYmluZChfdGhpczIuX19maWVsZF9rbm9iLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcclxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2ZpZWxkX2tub2IsICd0b3VjaHN0YXJ0JywgZmllbGREb3duKTtcclxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bkgpO1xyXG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faHVlX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bkgpO1xyXG4gICAgZnVuY3Rpb24gZmllbGREb3duKGUpIHtcclxuICAgICAgc2V0U1YoZSk7XHJcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcclxuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0U1YpO1xyXG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcclxuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwU1YpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmllbGREb3duSChlKSB7XHJcbiAgICAgIHNldEgoZSk7XHJcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xyXG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcclxuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBIKTtcclxuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwSCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaWVsZFVwU1YoKSB7XHJcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xyXG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcclxuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcclxuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBTVik7XHJcbiAgICAgIG9uRmluaXNoKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaWVsZFVwSCgpIHtcclxuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcclxuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcclxuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcEgpO1xyXG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xyXG4gICAgICBvbkZpbmlzaCgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xyXG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLnZhbHVlKTtcclxuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcclxuICAgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XHJcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XHJcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQodmFsdWVGaWVsZCk7XHJcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcclxuICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQpO1xyXG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faHVlX2ZpZWxkKTtcclxuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XHJcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XHJcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19zZWxlY3Rvcik7XHJcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xyXG4gICAgZnVuY3Rpb24gc2V0U1YoZSkge1xyXG4gICAgICBpZiAoZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IC0xKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBmaWVsZFJlY3QgPSBfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIHZhciBfcmVmID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxyXG4gICAgICAgICAgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcclxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XHJcbiAgICAgIHZhciBzID0gKGNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xyXG4gICAgICB2YXIgdiA9IDEgLSAoY2xpZW50WSAtIGZpZWxkUmVjdC50b3ApIC8gKGZpZWxkUmVjdC5ib3R0b20gLSBmaWVsZFJlY3QudG9wKTtcclxuICAgICAgaWYgKHYgPiAxKSB7XHJcbiAgICAgICAgdiA9IDE7XHJcbiAgICAgIH0gZWxzZSBpZiAodiA8IDApIHtcclxuICAgICAgICB2ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAocyA+IDEpIHtcclxuICAgICAgICBzID0gMTtcclxuICAgICAgfSBlbHNlIGlmIChzIDwgMCkge1xyXG4gICAgICAgIHMgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XHJcbiAgICAgIF90aGlzLl9fY29sb3IucyA9IHM7XHJcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0SChlKSB7XHJcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICB2YXIgX3JlZjIgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzWzBdIHx8IGUsXHJcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjIuY2xpZW50WTtcclxuICAgICAgdmFyIGggPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XHJcbiAgICAgIGlmIChoID4gMSkge1xyXG4gICAgICAgIGggPSAxO1xyXG4gICAgICB9IGVsc2UgaWYgKGggPCAwKSB7XHJcbiAgICAgICAgaCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcclxuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3RoaXMyO1xyXG4gIH1cclxuICBjcmVhdGVDbGFzcyhDb2xvckNvbnRyb2xsZXIsIFt7XHJcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xyXG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xyXG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcclxuICAgICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICBDb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgICBpZiAoIUNvbW1vbi5pc1VuZGVmaW5lZChpW2NvbXBvbmVudF0pICYmICFDb21tb24uaXNVbmRlZmluZWQodGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkgJiYgaVtjb21wb25lbnRdICE9PSB0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSB7XHJcbiAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIGlmIChtaXNtYXRjaCkge1xyXG4gICAgICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fY29sb3IuX19zdGF0ZSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSwgdGhpcy5fX2NvbG9yLl9fc3RhdGUpO1xyXG4gICAgICB0aGlzLl9fdGVtcC5hID0gMTtcclxuICAgICAgdmFyIGZsaXAgPSB0aGlzLl9fY29sb3IudiA8IDAuNSB8fCB0aGlzLl9fY29sb3IucyA+IDAuNSA/IDI1NSA6IDA7XHJcbiAgICAgIHZhciBfZmxpcCA9IDI1NSAtIGZsaXA7XHJcbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcclxuICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxyXG4gICAgICAgIG1hcmdpblRvcDogMTAwICogKDEgLSB0aGlzLl9fY29sb3IudikgLSA3ICsgJ3B4JyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCksXHJcbiAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX19odWVfa25vYi5zdHlsZS5tYXJnaW5Ub3AgPSAoMSAtIHRoaXMuX19jb2xvci5oIC8gMzYwKSAqIDEwMCArICdweCc7XHJcbiAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xyXG4gICAgICB0aGlzLl9fdGVtcC52ID0gMTtcclxuICAgICAgbGluZWFyR3JhZGllbnQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdsZWZ0JywgJyNmZmYnLCB0aGlzLl9fdGVtcC50b0hleFN0cmluZygpKTtcclxuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fY29sb3IudG9IZXhTdHJpbmcoKSxcclxuICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxyXG4gICAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsLjcpJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XSk7XHJcbiAgcmV0dXJuIENvbG9yQ29udHJvbGxlcjtcclxufShDb250cm9sbGVyKTtcclxudmFyIHZlbmRvcnMgPSBbJy1tb3otJywgJy1vLScsICctd2Via2l0LScsICctbXMtJywgJyddO1xyXG5mdW5jdGlvbiBsaW5lYXJHcmFkaWVudChlbGVtLCB4LCBhLCBiKSB7XHJcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XHJcbiAgQ29tbW9uLmVhY2godmVuZG9ycywgZnVuY3Rpb24gKHZlbmRvcikge1xyXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAnICsgdmVuZG9yICsgJ2xpbmVhci1ncmFkaWVudCgnICsgeCArICcsICcgKyBhICsgJyAwJSwgJyArIGIgKyAnIDEwMCUpOyAnO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGh1ZUdyYWRpZW50KGVsZW0pIHtcclxuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcclxuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTsnO1xyXG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XHJcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XHJcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xyXG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xyXG59XHJcblxyXG52YXIgY3NzID0ge1xyXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBpbmRvYykge1xyXG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xyXG4gICAgdmFyIGxpbmsgPSBkb2MuY3JlYXRlRWxlbWVudCgnbGluaycpO1xyXG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcclxuICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xyXG4gICAgbGluay5ocmVmID0gdXJsO1xyXG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XHJcbiAgfSxcclxuICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChjc3NDb250ZW50LCBpbmRvYykge1xyXG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xyXG4gICAgdmFyIGluamVjdGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgIGluamVjdGVkLnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcclxuICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XHJcbiAgICB0cnkge1xyXG4gICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG52YXIgc2F2ZURpYWxvZ0NvbnRlbnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XHJcblxyXG52YXIgQ29udHJvbGxlckZhY3RvcnkgPSBmdW5jdGlvbiBDb250cm9sbGVyRmFjdG9yeShvYmplY3QsIHByb3BlcnR5KSB7XHJcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XHJcbiAgaWYgKENvbW1vbi5pc0FycmF5KGFyZ3VtZW50c1syXSkgfHwgQ29tbW9uLmlzT2JqZWN0KGFyZ3VtZW50c1syXSkpIHtcclxuICAgIHJldHVybiBuZXcgT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0pO1xyXG4gIH1cclxuICBpZiAoQ29tbW9uLmlzTnVtYmVyKGluaXRpYWxWYWx1ZSkpIHtcclxuICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzJdKSAmJiBDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzNdKSkge1xyXG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcclxuICAgIH1cclxuICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzRdKSkge1xyXG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10sIHN0ZXA6IGFyZ3VtZW50c1s0XSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSB9KTtcclxuICB9XHJcbiAgaWYgKENvbW1vbi5pc1N0cmluZyhpbml0aWFsVmFsdWUpKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XHJcbiAgfVxyXG4gIGlmIChDb21tb24uaXNGdW5jdGlvbihpbml0aWFsVmFsdWUpKSB7XHJcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCAnJyk7XHJcbiAgfVxyXG4gIGlmIChDb21tb24uaXNCb29sZWFuKGluaXRpYWxWYWx1ZSkpIHtcclxuICAgIHJldHVybiBuZXcgQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XHJcbiAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcclxufVxyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG5cclxudmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIENlbnRlcmVkRGl2KCkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VudGVyZWREaXYpO1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLCB7XHJcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgbGVmdDogMCxcclxuICAgICAgZGlzcGxheTogJ25vbmUnLFxyXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcclxuICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInLFxyXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcclxuICAgIH0pO1xyXG4gICAgZG9tLm1ha2VGdWxsc2NyZWVuKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIENvbW1vbi5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XHJcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxyXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXHJcbiAgICAgIHpJbmRleDogJzEwMDEnLFxyXG4gICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnLXdlYmtpdC10cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcicsXHJcbiAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcidcclxuICAgIH0pO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICBkb20uYmluZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIF90aGlzLmhpZGUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVDbGFzcyhDZW50ZXJlZERpdiwgW3tcclxuICAgIGtleTogJ3Nob3cnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xyXG4gICAgICB0aGlzLmxheW91dCgpO1xyXG4gICAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdoaWRlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XHJcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xyXG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcclxuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xyXG4gICAgICB9O1xyXG4gICAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XHJcbiAgICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcclxuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcclxuICAgICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ2xheW91dCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0KCkge1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUubGVmdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIGRvbS5nZXRXaWR0aCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG4gIHJldHVybiBDZW50ZXJlZERpdjtcclxufSgpO1xyXG5cclxudmFyIHN0eWxlU2hlZXQgPSBfX18kaW5zZXJ0U3R5bGUoXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWV7d2lkdGg6MTAwJX0uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCU7cG9zaXRpb246cmVsYXRpdmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjdweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuY3IuY29sb3J7b3ZlcmZsb3c6dmlzaWJsZX0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmNvbG9ye2JvcmRlci1sZWZ0OjNweCBzb2xpZH0uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMkZBMUQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJGQTFENn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJGQTFENjttYXgtd2lkdGg6MTAwJX0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIpO1xyXG5cclxuY3NzLmluamVjdChzdHlsZVNoZWV0KTtcclxudmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xyXG52YXIgSElERV9LRVlfQ09ERSA9IDcyO1xyXG52YXIgQ0xPU0VfQlVUVE9OX0hFSUdIVCA9IDIwO1xyXG52YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xyXG52YXIgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSA9IGZ1bmN0aW9uICgpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KCk7XHJcbnZhciBTQVZFX0RJQUxPR1VFID0gdm9pZCAwO1xyXG52YXIgYXV0b1BsYWNlVmlyZ2luID0gdHJ1ZTtcclxudmFyIGF1dG9QbGFjZUNvbnRhaW5lciA9IHZvaWQgMDtcclxudmFyIGhpZGUgPSBmYWxzZTtcclxudmFyIGhpZGVhYmxlR3VpcyA9IFtdO1xyXG52YXIgR1VJID0gZnVuY3Rpb24gR1VJKHBhcnMpIHtcclxuICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xyXG4gIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIHRoaXMuX191bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XHJcbiAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XHJcbiAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgQ1NTX05BTUVTUEFDRSk7XHJcbiAgdGhpcy5fX2ZvbGRlcnMgPSB7fTtcclxuICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcclxuICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMgPSBbXTtcclxuICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzID0gW107XHJcbiAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xyXG4gIHBhcmFtcyA9IENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcclxuICAgIGNsb3NlT25Ub3A6IGZhbHNlLFxyXG4gICAgYXV0b1BsYWNlOiB0cnVlLFxyXG4gICAgd2lkdGg6IEdVSS5ERUZBVUxUX1dJRFRIXHJcbiAgfSk7XHJcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xyXG4gICAgcmVzaXphYmxlOiBwYXJhbXMuYXV0b1BsYWNlLFxyXG4gICAgaGlkZWFibGU6IHBhcmFtcy5hdXRvUGxhY2VcclxuICB9KTtcclxuICBpZiAoIUNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMubG9hZCkpIHtcclxuICAgIGlmIChwYXJhbXMucHJlc2V0KSB7XHJcbiAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xyXG4gIH1cclxuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5oaWRlYWJsZSkge1xyXG4gICAgaGlkZWFibGVHdWlzLnB1c2godGhpcyk7XHJcbiAgfVxyXG4gIHBhcmFtcy5yZXNpemFibGUgPSBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcclxuICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XHJcbiAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IHRydWU7XHJcbiAgfVxyXG4gIHZhciB1c2VMb2NhbFN0b3JhZ2UgPSBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcclxuICB2YXIgc2F2ZVRvTG9jYWxTdG9yYWdlID0gdm9pZCAwO1xyXG4gIHZhciB0aXRsZVJvdyA9IHZvaWQgMDtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxyXG4gIHtcclxuICAgIHBhcmVudDoge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLnBhcmVudDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNjcm9sbGFibGU6IHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgYXV0b1BsYWNlOiB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2xvc2VPblRvcDoge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlT25Ub3A7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwcmVzZXQ6IHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJvb3QoKS5wcmVzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcclxuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICBfdGhpcy5nZXRSb290KCkucHJlc2V0ID0gdjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0UHJlc2V0U2VsZWN0SW5kZXgodGhpcyk7XHJcbiAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3aWR0aDoge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLndpZHRoO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XHJcbiAgICAgICAgcGFyYW1zLndpZHRoID0gdjtcclxuICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBuYW1lOiB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xyXG4gICAgICAgIHBhcmFtcy5uYW1lID0gdjtcclxuICAgICAgICBpZiAodGl0bGVSb3cpIHtcclxuICAgICAgICAgIHRpdGxlUm93LmlubmVySFRNTCA9IHBhcmFtcy5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNsb3NlZDoge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlZDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xyXG4gICAgICAgIHBhcmFtcy5jbG9zZWQgPSB2O1xyXG4gICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XHJcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xyXG4gICAgICAgIGlmIChfdGhpcy5fX2Nsb3NlQnV0dG9uKSB7XHJcbiAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGxvYWQ6IHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdXNlTG9jYWxTdG9yYWdlOiB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgIHJldHVybiB1c2VMb2NhbFN0b3JhZ2U7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKGJvb2wpIHtcclxuICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xyXG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlID0gYm9vbDtcclxuICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XHJcbiAgICB0aGlzLmNsb3NlZCA9IHBhcmFtcy5jbG9zZWQgfHwgZmFsc2U7XHJcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfTUFJTik7XHJcbiAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XHJcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xyXG4gICAgICBpZiAodXNlTG9jYWxTdG9yYWdlKSB7XHJcbiAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgc2F2ZWRHdWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XHJcbiAgICAgICAgaWYgKHNhdmVkR3VpKSB7XHJcbiAgICAgICAgICBwYXJhbXMubG9hZCA9IEpTT04ucGFyc2Uoc2F2ZWRHdWkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICB0aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gR1VJLlRFWFRfQ0xPU0VEO1xyXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTik7XHJcbiAgICBpZiAocGFyYW1zLmNsb3NlT25Ub3ApIHtcclxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX1RPUCk7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5fX2Nsb3NlQnV0dG9uLCB0aGlzLmRvbUVsZW1lbnQuY2hpbGROb2Rlc1swXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQk9UVE9NKTtcclxuICAgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XHJcbiAgICB9XHJcbiAgICBkb20uYmluZCh0aGlzLl9fY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAocGFyYW1zLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHRpdGxlUm93TmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcclxuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvd05hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcclxuICAgIHRpdGxlUm93ID0gYWRkUm93KF90aGlzLCB0aXRsZVJvd05hbWUpO1xyXG4gICAgdmFyIG9uQ2xpY2tUaXRsZSA9IGZ1bmN0aW9uIG9uQ2xpY2tUaXRsZShlKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xyXG4gICAgZG9tLmFkZENsYXNzKHRpdGxlUm93LCAndGl0bGUnKTtcclxuICAgIGRvbS5iaW5kKHRpdGxlUm93LCAnY2xpY2snLCBvbkNsaWNrVGl0bGUpO1xyXG4gICAgaWYgKCFwYXJhbXMuY2xvc2VkKSB7XHJcbiAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChwYXJhbXMuYXV0b1BsYWNlKSB7XHJcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XHJcbiAgICAgIGlmIChhdXRvUGxhY2VWaXJnaW4pIHtcclxuICAgICAgICBhdXRvUGxhY2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcclxuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXV0b1BsYWNlQ29udGFpbmVyKTtcclxuICAgICAgICBhdXRvUGxhY2VWaXJnaW4gPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBhdXRvUGxhY2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcclxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBfdGhpcy5vblJlc2l6ZURlYm91bmNlZCgpO1xyXG4gIH07XHJcbiAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xyXG4gIGRvbS5iaW5kKHRoaXMuX191bCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XHJcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcclxuICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcclxuICB0aGlzLm9uUmVzaXplKCk7XHJcbiAgaWYgKHBhcmFtcy5yZXNpemFibGUpIHtcclxuICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcclxuICB9XHJcbiAgc2F2ZVRvTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xyXG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnZ3VpJyksIEpTT04uc3RyaW5naWZ5KF90aGlzLmdldFNhdmVPYmplY3QoKSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlID0gc2F2ZVRvTG9jYWxTdG9yYWdlO1xyXG4gIGZ1bmN0aW9uIHJlc2V0V2lkdGgoKSB7XHJcbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcclxuICAgIHJvb3Qud2lkdGggKz0gMTtcclxuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJvb3Qud2lkdGggLT0gMTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcclxuICAgIHJlc2V0V2lkdGgoKTtcclxuICB9XHJcbn07XHJcbkdVSS50b2dnbGVIaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gIGhpZGUgPSAhaGlkZTtcclxuICBDb21tb24uZWFjaChoaWRlYWJsZUd1aXMsIGZ1bmN0aW9uIChndWkpIHtcclxuICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBoaWRlID8gJ25vbmUnIDogJyc7XHJcbiAgfSk7XHJcbn07XHJcbkdVSS5DTEFTU19BVVRPX1BMQUNFID0gJ2EnO1xyXG5HVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIgPSAnYWMnO1xyXG5HVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcclxuR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XID0gJ2NyJztcclxuR1VJLkNMQVNTX1RPT19UQUxMID0gJ3RhbGxlci10aGFuLXdpbmRvdyc7XHJcbkdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcclxuR1VJLkNMQVNTX0NMT1NFX0JVVFRPTiA9ICdjbG9zZS1idXR0b24nO1xyXG5HVUkuQ0xBU1NfQ0xPU0VfVE9QID0gJ2Nsb3NlLXRvcCc7XHJcbkdVSS5DTEFTU19DTE9TRV9CT1RUT00gPSAnY2xvc2UtYm90dG9tJztcclxuR1VJLkNMQVNTX0RSQUcgPSAnZHJhZyc7XHJcbkdVSS5ERUZBVUxUX1dJRFRIID0gMjQ1O1xyXG5HVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xyXG5HVUkuVEVYVF9PUEVOID0gJ09wZW4gQ29udHJvbHMnO1xyXG5HVUkuX2tleWRvd25IYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiYgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09PSBISURFX0tFWV9DT0RFKSkge1xyXG4gICAgR1VJLnRvZ2dsZUhpZGUoKTtcclxuICB9XHJcbn07XHJcbmRvbS5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XHJcbkNvbW1vbi5leHRlbmQoR1VJLnByb3RvdHlwZSxcclxue1xyXG4gIGFkZDogZnVuY3Rpb24gYWRkKG9iamVjdCwgcHJvcGVydHkpIHtcclxuICAgIHJldHVybiBfYWRkKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHtcclxuICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgYWRkQ29sb3I6IGZ1bmN0aW9uIGFkZENvbG9yKG9iamVjdCwgcHJvcGVydHkpIHtcclxuICAgIHJldHVybiBfYWRkKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHtcclxuICAgICAgY29sb3I6IHRydWVcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29udHJvbGxlcikge1xyXG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XHJcbiAgICB0aGlzLl9fY29udHJvbGxlcnMuc3BsaWNlKHRoaXMuX19jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpLCAxKTtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy5vblJlc2l6ZSgpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgcm9vdCBHVUkgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCAuZGVzdHJveSgpLiAnICsgJ0ZvciBzdWJmb2xkZXJzLCB1c2UgZ3VpLnJlbW92ZUZvbGRlcihmb2xkZXIpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcclxuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcclxuICAgICAgX3RoaXMucmVtb3ZlRm9sZGVyKHN1YmZvbGRlcik7XHJcbiAgICB9KTtcclxuICAgIGRvbS51bmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcclxuICAgIHJlbW92ZUxpc3RlbmVycyh0aGlzKTtcclxuICB9LFxyXG4gIGFkZEZvbGRlcjogZnVuY3Rpb24gYWRkRm9sZGVyKG5hbWUpIHtcclxuICAgIGlmICh0aGlzLl9fZm9sZGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICsgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcclxuICAgIH1cclxuICAgIHZhciBuZXdHdWlQYXJhbXMgPSB7IG5hbWU6IG5hbWUsIHBhcmVudDogdGhpcyB9O1xyXG4gICAgbmV3R3VpUGFyYW1zLmF1dG9QbGFjZSA9IHRoaXMuYXV0b1BsYWNlO1xyXG4gICAgaWYgKHRoaXMubG9hZCAmJlxyXG4gICAgdGhpcy5sb2FkLmZvbGRlcnMgJiZcclxuICAgIHRoaXMubG9hZC5mb2xkZXJzW25hbWVdKSB7XHJcbiAgICAgIG5ld0d1aVBhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XHJcbiAgICAgIG5ld0d1aVBhcmFtcy5sb2FkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV07XHJcbiAgICB9XHJcbiAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdHdWlQYXJhbXMpO1xyXG4gICAgdGhpcy5fX2ZvbGRlcnNbbmFtZV0gPSBndWk7XHJcbiAgICB2YXIgbGkgPSBhZGRSb3codGhpcywgZ3VpLmRvbUVsZW1lbnQpO1xyXG4gICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XHJcbiAgICByZXR1cm4gZ3VpO1xyXG4gIH0sXHJcbiAgcmVtb3ZlRm9sZGVyOiBmdW5jdGlvbiByZW1vdmVGb2xkZXIoZm9sZGVyKSB7XHJcbiAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoZm9sZGVyLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCk7XHJcbiAgICBkZWxldGUgdGhpcy5fX2ZvbGRlcnNbZm9sZGVyLm5hbWVdO1xyXG4gICAgaWYgKHRoaXMubG9hZCAmJlxyXG4gICAgdGhpcy5sb2FkLmZvbGRlcnMgJiZcclxuICAgIHRoaXMubG9hZC5mb2xkZXJzW2ZvbGRlci5uYW1lXSkge1xyXG4gICAgICBkZWxldGUgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGlzdGVuZXJzKGZvbGRlcik7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgQ29tbW9uLmVhY2goZm9sZGVyLl9fZm9sZGVycywgZnVuY3Rpb24gKHN1YmZvbGRlcikge1xyXG4gICAgICBmb2xkZXIucmVtb3ZlRm9sZGVyKHN1YmZvbGRlcik7XHJcbiAgICB9KTtcclxuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIF90aGlzLm9uUmVzaXplKCk7XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XHJcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xyXG4gIH0sXHJcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xyXG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xyXG4gIH0sXHJcbiAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcclxuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIH0sXHJcbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcclxuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgfSxcclxuICBvblJlc2l6ZTogZnVuY3Rpb24gb25SZXNpemUoKSB7XHJcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xyXG4gICAgaWYgKHJvb3Quc2Nyb2xsYWJsZSkge1xyXG4gICAgICB2YXIgdG9wID0gZG9tLmdldE9mZnNldChyb290Ll9fdWwpLnRvcDtcclxuICAgICAgdmFyIGggPSAwO1xyXG4gICAgICBDb21tb24uZWFjaChyb290Ll9fdWwuY2hpbGROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAoIShyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKSB7XHJcbiAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XHJcbiAgICAgICAgZG9tLmFkZENsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcclxuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcclxuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocm9vdC5fX3Jlc2l6ZV9oYW5kbGUpIHtcclxuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByb290Ll9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQgPSByb290Ll9fdWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm9vdC5fX2Nsb3NlQnV0dG9uKSB7XHJcbiAgICAgIHJvb3QuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHJvb3Qud2lkdGggKyAncHgnO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgb25SZXNpemVEZWJvdW5jZWQ6IENvbW1vbi5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLm9uUmVzaXplKCk7XHJcbiAgfSwgNTApLFxyXG4gIHJlbWVtYmVyOiBmdW5jdGlvbiByZW1lbWJlcigpIHtcclxuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcclxuICAgICAgU0FWRV9ESUFMT0dVRSA9IG5ldyBDZW50ZXJlZERpdigpO1xyXG4gICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gc2F2ZURpYWxvZ0NvbnRlbnRzO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLicpO1xyXG4gICAgfVxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIENvbW1vbi5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgYWRkU2F2ZU1lbnUoX3RoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcclxuICAgICAgICBfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLnB1c2gob2JqZWN0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcclxuICAgICAgc2V0V2lkdGgodGhpcywgdGhpcy53aWR0aCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBnZXRSb290OiBmdW5jdGlvbiBnZXRSb290KCkge1xyXG4gICAgdmFyIGd1aSA9IHRoaXM7XHJcbiAgICB3aGlsZSAoZ3VpLnBhcmVudCkge1xyXG4gICAgICBndWkgPSBndWkucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGd1aTtcclxuICB9LFxyXG4gIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uIGdldFNhdmVPYmplY3QoKSB7XHJcbiAgICB2YXIgdG9SZXR1cm4gPSB0aGlzLmxvYWQ7XHJcbiAgICB0b1JldHVybi5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcclxuICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0b1JldHVybi5wcmVzZXQgPSB0aGlzLnByZXNldDtcclxuICAgICAgaWYgKCF0b1JldHVybi5yZW1lbWJlcmVkKSB7XHJcbiAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcclxuICAgIH1cclxuICAgIHRvUmV0dXJuLmZvbGRlcnMgPSB7fTtcclxuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XHJcbiAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdG9SZXR1cm47XHJcbiAgfSxcclxuICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xyXG4gICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xyXG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcclxuICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUoKTtcclxuICB9LFxyXG4gIHNhdmVBczogZnVuY3Rpb24gc2F2ZUFzKHByZXNldE5hbWUpIHtcclxuICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcclxuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcclxuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtwcmVzZXROYW1lXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XHJcbiAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XHJcbiAgICBhZGRQcmVzZXRPcHRpb24odGhpcywgcHJlc2V0TmFtZSwgdHJ1ZSk7XHJcbiAgICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUoKTtcclxuICB9LFxyXG4gIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KGd1aSkge1xyXG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbiAoY29udHJvbGxlcikge1xyXG4gICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xyXG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUoY29udHJvbGxlci5pbml0aWFsVmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlKSB7XHJcbiAgICAgICAgY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlLmNhbGwoY29udHJvbGxlciwgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcclxuICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xyXG4gICAgICBmb2xkZXIucmV2ZXJ0KGZvbGRlcik7XHJcbiAgICB9KTtcclxuICAgIGlmICghZ3VpKSB7XHJcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLmdldFJvb3QoKSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4oY29udHJvbGxlcikge1xyXG4gICAgdmFyIGluaXQgPSB0aGlzLl9fbGlzdGVuaW5nLmxlbmd0aCA9PT0gMDtcclxuICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcclxuICAgIGlmIChpbml0KSB7XHJcbiAgICAgIHVwZGF0ZURpc3BsYXlzKHRoaXMuX19saXN0ZW5pbmcpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcclxuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XHJcbiAgICB9KTtcclxuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XHJcbiAgICAgIGZvbGRlci51cGRhdGVEaXNwbGF5KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbn0pO1xyXG5mdW5jdGlvbiBhZGRSb3coZ3VpLCBuZXdEb20sIGxpQmVmb3JlKSB7XHJcbiAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuICBpZiAobmV3RG9tKSB7XHJcbiAgICBsaS5hcHBlbmRDaGlsZChuZXdEb20pO1xyXG4gIH1cclxuICBpZiAobGlCZWZvcmUpIHtcclxuICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgbGlCZWZvcmUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBndWkuX191bC5hcHBlbmRDaGlsZChsaSk7XHJcbiAgfVxyXG4gIGd1aS5vblJlc2l6ZSgpO1xyXG4gIHJldHVybiBsaTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZ3VpKSB7XHJcbiAgZG9tLnVuYmluZCh3aW5kb3csICdyZXNpemUnLCBndWkuX19yZXNpemVIYW5kbGVyKTtcclxuICBpZiAoZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpIHtcclxuICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xyXG4gIHZhciBvcHQgPSBndWkuX19wcmVzZXRfc2VsZWN0W2d1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleF07XHJcbiAgaWYgKG1vZGlmaWVkKSB7XHJcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgJyonO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKSB7XHJcbiAgY29udHJvbGxlci5fX2xpID0gbGk7XHJcbiAgY29udHJvbGxlci5fX2d1aSA9IGd1aTtcclxuICBDb21tb24uZXh0ZW5kKGNvbnRyb2xsZXIsIHtcclxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoX29wdGlvbnMpIHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybiBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcclxuICAgICAgICAgIGJlZm9yZTogbmV4dFNpYmxpbmcsXHJcbiAgICAgICAgICBmYWN0b3J5QXJnczogW0NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKENvbW1vbi5pc0FycmF5KF9vcHRpb25zKSB8fCBDb21tb24uaXNPYmplY3QoX29wdGlvbnMpKSB7XHJcbiAgICAgICAgdmFyIF9uZXh0U2libGluZyA9IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcclxuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XHJcbiAgICAgICAgICBiZWZvcmU6IF9uZXh0U2libGluZyxcclxuICAgICAgICAgIGZhY3RvcnlBcmdzOiBbX29wdGlvbnNdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKF9uYW1lKSB7XHJcbiAgICAgIGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPSBfbmFtZTtcclxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XHJcbiAgICB9LFxyXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XHJcbiAgICAgIGNvbnRyb2xsZXIuX19ndWkubGlzdGVuKGNvbnRyb2xsZXIpO1xyXG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcclxuICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XHJcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlclNsaWRlcikge1xyXG4gICAgdmFyIGJveCA9IG5ldyBOdW1iZXJDb250cm9sbGVyQm94KGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7IG1pbjogY29udHJvbGxlci5fX21pbiwgbWF4OiBjb250cm9sbGVyLl9fbWF4LCBzdGVwOiBjb250cm9sbGVyLl9fc3RlcCB9KTtcclxuICAgIENvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZScsICdzdGVwJywgJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICB2YXIgcGMgPSBjb250cm9sbGVyW21ldGhvZF07XHJcbiAgICAgIHZhciBwYiA9IGJveFttZXRob2RdO1xyXG4gICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcGIuYXBwbHkoYm94LCBhcmdzKTtcclxuICAgICAgICByZXR1cm4gcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcclxuICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoYm94LmRvbUVsZW1lbnQsIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XHJcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlckJveCkge1xyXG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHJldHVybmVkKSB7XHJcbiAgICAgIGlmIChDb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21pbikgJiYgQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19tYXgpKSB7XHJcbiAgICAgICAgdmFyIG9sZE5hbWUgPSBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MO1xyXG4gICAgICAgIHZhciB3YXNMaXN0ZW5pbmcgPSBjb250cm9sbGVyLl9fZ3VpLl9fbGlzdGVuaW5nLmluZGV4T2YoY29udHJvbGxlcikgPiAtMTtcclxuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xyXG4gICAgICAgIHZhciBuZXdDb250cm9sbGVyID0gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XHJcbiAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXHJcbiAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbnRyb2xsZXIuX19taW4sIGNvbnRyb2xsZXIuX19tYXgsIGNvbnRyb2xsZXIuX19zdGVwXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5ld0NvbnRyb2xsZXIubmFtZShvbGROYW1lKTtcclxuICAgICAgICBpZiAod2FzTGlzdGVuaW5nKSBuZXdDb250cm9sbGVyLmxpc3RlbigpO1xyXG4gICAgICAgIHJldHVybiBuZXdDb250cm9sbGVyO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXR1cm5lZDtcclxuICAgIH07XHJcbiAgICBjb250cm9sbGVyLm1pbiA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcclxuICAgIGNvbnRyb2xsZXIubWF4ID0gQ29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5tYXgpO1xyXG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEJvb2xlYW5Db250cm9sbGVyKSB7XHJcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJyk7XHJcbiAgICB9KTtcclxuICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xyXG4gICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fYnV0dG9uLCAnY2xpY2snKTtcclxuICAgIH0pO1xyXG4gICAgZG9tLmJpbmQobGksICdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcclxuICAgIH0pO1xyXG4gICAgZG9tLmJpbmQobGksICdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XHJcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xyXG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICBsaS5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBjb250cm9sbGVyLl9fY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XHJcbiAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcclxuICB9XHJcbiAgY29udHJvbGxlci5zZXRWYWx1ZSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIGlmIChndWkuZ2V0Um9vdCgpLl9fcHJlc2V0X3NlbGVjdCAmJiBjb250cm9sbGVyLmlzTW9kaWZpZWQoKSkge1xyXG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLmdldFJvb3QoKSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG4gIH0sIGNvbnRyb2xsZXIuc2V0VmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKSB7XHJcbiAgdmFyIHJvb3QgPSBndWkuZ2V0Um9vdCgpO1xyXG4gIHZhciBtYXRjaGVkSW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XHJcbiAgaWYgKG1hdGNoZWRJbmRleCAhPT0gLTEpIHtcclxuICAgIHZhciBjb250cm9sbGVyTWFwID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdO1xyXG4gICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb250cm9sbGVyTWFwID0ge307XHJcbiAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZEluZGV4XSA9IGNvbnRyb2xsZXJNYXA7XHJcbiAgICB9XHJcbiAgICBjb250cm9sbGVyTWFwW2NvbnRyb2xsZXIucHJvcGVydHldID0gY29udHJvbGxlcjtcclxuICAgIGlmIChyb290LmxvYWQgJiYgcm9vdC5sb2FkLnJlbWVtYmVyZWQpIHtcclxuICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xyXG4gICAgICB2YXIgcHJlc2V0ID0gdm9pZCAwO1xyXG4gICAgICBpZiAocHJlc2V0TWFwW2d1aS5wcmVzZXRdKSB7XHJcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW2d1aS5wcmVzZXRdO1xyXG4gICAgICB9IGVsc2UgaWYgKHByZXNldE1hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdKSB7XHJcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZEluZGV4XSAmJiBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcHJlc2V0W21hdGNoZWRJbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV07XHJcbiAgICAgICAgY29udHJvbGxlci5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBfYWRkKGd1aSwgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XHJcbiAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgXCInICsgb2JqZWN0ICsgJ1wiIGhhcyBubyBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIicpO1xyXG4gIH1cclxuICB2YXIgY29udHJvbGxlciA9IHZvaWQgMDtcclxuICBpZiAocGFyYW1zLmNvbG9yKSB7XHJcbiAgICBjb250cm9sbGVyID0gbmV3IENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGZhY3RvcnlBcmdzID0gW29iamVjdCwgcHJvcGVydHldLmNvbmNhdChwYXJhbXMuZmFjdG9yeUFyZ3MpO1xyXG4gICAgY29udHJvbGxlciA9IENvbnRyb2xsZXJGYWN0b3J5LmFwcGx5KGd1aSwgZmFjdG9yeUFyZ3MpO1xyXG4gIH1cclxuICBpZiAocGFyYW1zLmJlZm9yZSBpbnN0YW5jZW9mIENvbnRyb2xsZXIpIHtcclxuICAgIHBhcmFtcy5iZWZvcmUgPSBwYXJhbXMuYmVmb3JlLl9fbGk7XHJcbiAgfVxyXG4gIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKTtcclxuICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5kb21FbGVtZW50LCAnYycpO1xyXG4gIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gIGRvbS5hZGRDbGFzcyhuYW1lLCAncHJvcGVydHktbmFtZScpO1xyXG4gIG5hbWUuaW5uZXJIVE1MID0gY29udHJvbGxlci5wcm9wZXJ0eTtcclxuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sbGVyLmRvbUVsZW1lbnQpO1xyXG4gIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XHJcbiAgZG9tLmFkZENsYXNzKGxpLCBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cpO1xyXG4gIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XHJcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkb20uYWRkQ2xhc3MobGksIF90eXBlb2YoY29udHJvbGxlci5nZXRWYWx1ZSgpKSk7XHJcbiAgfVxyXG4gIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpO1xyXG4gIGd1aS5fX2NvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XHJcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksIGtleSkge1xyXG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xyXG59XHJcbmZ1bmN0aW9uIGFkZFByZXNldE9wdGlvbihndWksIG5hbWUsIHNldFNlbGVjdGVkKSB7XHJcbiAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xyXG4gIG9wdC5pbm5lckhUTUwgPSBuYW1lO1xyXG4gIG9wdC52YWx1ZSA9IG5hbWU7XHJcbiAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xyXG4gIGlmIChzZXRTZWxlY3RlZCkge1xyXG4gICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGggLSAxO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKSB7XHJcbiAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XHJcbn1cclxuZnVuY3Rpb24gYWRkU2F2ZU1lbnUoZ3VpKSB7XHJcbiAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuICBkb20uYWRkQ2xhc3MoZ3VpLmRvbUVsZW1lbnQsICdoYXMtc2F2ZScpO1xyXG4gIGd1aS5fX3VsLmluc2VydEJlZm9yZShkaXYsIGd1aS5fX3VsLmZpcnN0Q2hpbGQpO1xyXG4gIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xyXG4gIHZhciBnZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICBnZWFycy5pbm5lckhUTUwgPSAnJm5ic3A7JztcclxuICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcclxuICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gIGJ1dHRvbi5pbm5lckhUTUwgPSAnU2F2ZSc7XHJcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xyXG4gIGRvbS5hZGRDbGFzcyhidXR0b24sICdzYXZlJyk7XHJcbiAgdmFyIGJ1dHRvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcclxuICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ2J1dHRvbicpO1xyXG4gIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnc2F2ZS1hcycpO1xyXG4gIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gIGJ1dHRvbjMuaW5uZXJIVE1MID0gJ1JldmVydCc7XHJcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdidXR0b24nKTtcclxuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xyXG4gIHZhciBzZWxlY3QgPSBndWkuX19wcmVzZXRfc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XHJcbiAgaWYgKGd1aS5sb2FkICYmIGd1aS5sb2FkLnJlbWVtYmVyZWQpIHtcclxuICAgIENvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgIGFkZFByZXNldE9wdGlvbihndWksIGtleSwga2V5ID09PSBndWkucHJlc2V0KTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUsIGZhbHNlKTtcclxuICB9XHJcbiAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLmlubmVySFRNTCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ3VpLnByZXNldCA9IHRoaXMudmFsdWU7XHJcbiAgfSk7XHJcbiAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XHJcbiAgZGl2LmFwcGVuZENoaWxkKGdlYXJzKTtcclxuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcclxuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XHJcbiAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjMpO1xyXG4gIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XHJcbiAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XHJcbiAgICB2YXIgbG9jYWxTdG9yYWdlQ2hlY2tCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtc3RvcmFnZScpO1xyXG4gICAgdmFyIHNhdmVMb2NhbGx5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLXNhdmUtbG9jYWxseScpO1xyXG4gICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcclxuICAgICAgbG9jYWxTdG9yYWdlQ2hlY2tCb3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcclxuICAgIH1cclxuICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xyXG4gICAgZG9tLmJpbmQobG9jYWxTdG9yYWdlQ2hlY2tCb3gsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcclxuICAgICAgc2hvd0hpZGVFeHBsYWluKGd1aSwgZXhwbGFpbik7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgdmFyIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbmV3LWNvbnN0cnVjdG9yJyk7XHJcbiAgZG9tLmJpbmQobmV3Q29uc3RydWN0b3JUZXh0QXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09PSA2NykpIHtcclxuICAgICAgU0FWRV9ESUFMT0dVRS5oaWRlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgZG9tLmJpbmQoZ2VhcnMsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuaW5uZXJIVE1MID0gSlNPTi5zdHJpbmdpZnkoZ3VpLmdldFNhdmVPYmplY3QoKSwgdW5kZWZpbmVkLCAyKTtcclxuICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xyXG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5mb2N1cygpO1xyXG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5zZWxlY3QoKTtcclxuICB9KTtcclxuICBkb20uYmluZChidXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGd1aS5zYXZlKCk7XHJcbiAgfSk7XHJcbiAgZG9tLmJpbmQoYnV0dG9uMiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHByZXNldE5hbWUgPSBwcm9tcHQoJ0VudGVyIGEgbmV3IHByZXNldCBuYW1lLicpO1xyXG4gICAgaWYgKHByZXNldE5hbWUpIHtcclxuICAgICAgZ3VpLnNhdmVBcyhwcmVzZXROYW1lKTtcclxuICAgIH1cclxuICB9KTtcclxuICBkb20uYmluZChidXR0b24zLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBndWkucmV2ZXJ0KCk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlKGd1aSkge1xyXG4gIHZhciBwbW91c2VYID0gdm9pZCAwO1xyXG4gIGd1aS5fX3Jlc2l6ZV9oYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBDb21tb24uZXh0ZW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUsIHtcclxuICAgIHdpZHRoOiAnNnB4JyxcclxuICAgIG1hcmdpbkxlZnQ6ICctM3B4JyxcclxuICAgIGhlaWdodDogJzIwMHB4JyxcclxuICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXHJcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xyXG4gIH0pO1xyXG4gIGZ1bmN0aW9uIGRyYWcoZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgZ3VpLndpZHRoICs9IHBtb3VzZVggLSBlLmNsaWVudFg7XHJcbiAgICBndWkub25SZXNpemUoKTtcclxuICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGRyYWdTdG9wKCkge1xyXG4gICAgZG9tLnJlbW92ZUNsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XHJcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xyXG4gICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xyXG4gIH1cclxuICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcclxuICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xyXG4gICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XHJcbiAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBkb20uYmluZChndWkuX19yZXNpemVfaGFuZGxlLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcclxuICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XHJcbiAgZ3VpLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsIGd1aS5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcclxuICBndWkuZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xyXG4gIGlmIChndWkuX19zYXZlX3JvdyAmJiBndWkuYXV0b1BsYWNlKSB7XHJcbiAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xyXG4gIH1cclxuICBpZiAoZ3VpLl9fY2xvc2VCdXR0b24pIHtcclxuICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XHJcbiAgdmFyIHRvUmV0dXJuID0ge307XHJcbiAgQ29tbW9uLmVhY2goZ3VpLl9fcmVtZW1iZXJlZE9iamVjdHMsIGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XHJcbiAgICB2YXIgc2F2ZWRWYWx1ZXMgPSB7fTtcclxuICAgIHZhciBjb250cm9sbGVyTWFwID0gZ3VpLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW2luZGV4XTtcclxuICAgIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJNYXAsIGZ1bmN0aW9uIChjb250cm9sbGVyLCBwcm9wZXJ0eSkge1xyXG4gICAgICBzYXZlZFZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XHJcbiAgICB9KTtcclxuICAgIHRvUmV0dXJuW2luZGV4XSA9IHNhdmVkVmFsdWVzO1xyXG4gIH0pO1xyXG4gIHJldHVybiB0b1JldHVybjtcclxufVxyXG5mdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcclxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgIGlmIChndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZSA9PT0gZ3VpLnByZXNldCkge1xyXG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KSB7XHJcbiAgaWYgKGNvbnRyb2xsZXJBcnJheS5sZW5ndGggIT09IDApIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgQ29tbW9uLmVhY2goY29udHJvbGxlckFycmF5LCBmdW5jdGlvbiAoYykge1xyXG4gICAgYy51cGRhdGVEaXNwbGF5KCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciBjb2xvciA9IHtcclxuICBDb2xvcjogQ29sb3IsXHJcbiAgbWF0aDogQ29sb3JNYXRoLFxyXG4gIGludGVycHJldDogaW50ZXJwcmV0XHJcbn07XHJcbnZhciBjb250cm9sbGVycyA9IHtcclxuICBDb250cm9sbGVyOiBDb250cm9sbGVyLFxyXG4gIEJvb2xlYW5Db250cm9sbGVyOiBCb29sZWFuQ29udHJvbGxlcixcclxuICBPcHRpb25Db250cm9sbGVyOiBPcHRpb25Db250cm9sbGVyLFxyXG4gIFN0cmluZ0NvbnRyb2xsZXI6IFN0cmluZ0NvbnRyb2xsZXIsXHJcbiAgTnVtYmVyQ29udHJvbGxlcjogTnVtYmVyQ29udHJvbGxlcixcclxuICBOdW1iZXJDb250cm9sbGVyQm94OiBOdW1iZXJDb250cm9sbGVyQm94LFxyXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXI6IE51bWJlckNvbnRyb2xsZXJTbGlkZXIsXHJcbiAgRnVuY3Rpb25Db250cm9sbGVyOiBGdW5jdGlvbkNvbnRyb2xsZXIsXHJcbiAgQ29sb3JDb250cm9sbGVyOiBDb2xvckNvbnRyb2xsZXJcclxufTtcclxudmFyIGRvbSQxID0geyBkb206IGRvbSB9O1xyXG52YXIgZ3VpID0geyBHVUk6IEdVSSB9O1xyXG52YXIgR1VJJDEgPSBHVUk7XHJcbnZhciBpbmRleCA9IHtcclxuICBjb2xvcjogY29sb3IsXHJcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxyXG4gIGRvbTogZG9tJDEsXHJcbiAgZ3VpOiBndWksXHJcbiAgR1VJOiBHVUkkMVxyXG59O1xyXG5cclxuZXhwb3J0IHsgY29sb3IsIGNvbnRyb2xsZXJzLCBkb20kMSBhcyBkb20sIGd1aSwgR1VJJDEgYXMgR1VJIH07XHJcbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXQuZ3VpLm1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///121\n")},134:module=>{eval('\r\n\r\n/* istanbul ignore next  */\r\nfunction insertStyleElement(options) {\r\n  var element = document.createElement("style");\r\n  options.setAttributes(element, options.attributes);\r\n  options.insert(element, options.options);\r\n  return element;\r\n}\r\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NjaWxsb3Njb3BlLXNpbXVsYXRvci9EOlxcVXNlcnNcXGFzdXNcXERlc2t0b3BcXHdlYumhueebrlxcZGVtbzFcXG5vZGVfbW9kdWxlc1xcc3R5bGUtbG9hZGVyXFxkaXN0XFxydW50aW1lXFxpbnNlcnRTdHlsZUVsZW1lbnQuanM/M2E2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xyXG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///134\n')},147:module=>{eval('\r\n\r\n/* istanbul ignore next  */\r\nfunction apply(styleElement, options, obj) {\r\n  var css = "";\r\n  if (obj.supports) {\r\n    css += "@supports (".concat(obj.supports, ") {");\r\n  }\r\n  if (obj.media) {\r\n    css += "@media ".concat(obj.media, " {");\r\n  }\r\n  var needLayer = typeof obj.layer !== "undefined";\r\n  if (needLayer) {\r\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\r\n  }\r\n  css += obj.css;\r\n  if (needLayer) {\r\n    css += "}";\r\n  }\r\n  if (obj.media) {\r\n    css += "}";\r\n  }\r\n  if (obj.supports) {\r\n    css += "}";\r\n  }\r\n  var sourceMap = obj.sourceMap;\r\n  if (sourceMap && typeof btoa !== "undefined") {\r\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\r\n  }\r\n\r\n  // For old IE\r\n  /* istanbul ignore if  */\r\n  options.styleTagTransform(css, styleElement, options.options);\r\n}\r\nfunction removeStyleElement(styleElement) {\r\n  // istanbul ignore if\r\n  if (styleElement.parentNode === null) {\r\n    return false;\r\n  }\r\n  styleElement.parentNode.removeChild(styleElement);\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction domAPI(options) {\r\n  if (typeof document === "undefined") {\r\n    return {\r\n      update: function update() {},\r\n      remove: function remove() {}\r\n    };\r\n  }\r\n  var styleElement = options.insertStyleElement(options);\r\n  return {\r\n    update: function update(obj) {\r\n      apply(styleElement, options, obj);\r\n    },\r\n    remove: function remove() {\r\n      removeStyleElement(styleElement);\r\n    }\r\n  };\r\n}\r\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NjaWxsb3Njb3BlLXNpbXVsYXRvci9EOlxcVXNlcnNcXGFzdXNcXERlc2t0b3BcXHdlYumhueebrlxcZGVtbzFcXG5vZGVfbW9kdWxlc1xcc3R5bGUtbG9hZGVyXFxkaXN0XFxydW50aW1lXFxzdHlsZURvbUFQSS5qcz9kODhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXHJcbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XHJcbiAgdmFyIGNzcyA9IFwiXCI7XHJcbiAgaWYgKG9iai5zdXBwb3J0cykge1xyXG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcclxuICB9XHJcbiAgaWYgKG9iai5tZWRpYSkge1xyXG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XHJcbiAgfVxyXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xyXG4gIGlmIChuZWVkTGF5ZXIpIHtcclxuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcclxuICB9XHJcbiAgY3NzICs9IG9iai5jc3M7XHJcbiAgaWYgKG5lZWRMYXllcikge1xyXG4gICAgY3NzICs9IFwifVwiO1xyXG4gIH1cclxuICBpZiAob2JqLm1lZGlhKSB7XHJcbiAgICBjc3MgKz0gXCJ9XCI7XHJcbiAgfVxyXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcclxuICAgIGNzcyArPSBcIn1cIjtcclxuICB9XHJcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XHJcbiAgfVxyXG5cclxuICAvLyBGb3Igb2xkIElFXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xyXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxyXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG59XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cclxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcclxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxyXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xyXG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XHJcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///147\n')},202:module=>{eval('\r\n\r\nvar stylesInDOM = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n  var result = -1;\r\n  for (var i = 0; i < stylesInDOM.length; i++) {\r\n    if (stylesInDOM[i].identifier === identifier) {\r\n      result = i;\r\n      break;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n  var idCountMap = {};\r\n  var identifiers = [];\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i];\r\n    var id = options.base ? item[0] + options.base : item[0];\r\n    var count = idCountMap[id] || 0;\r\n    var identifier = "".concat(id, " ").concat(count);\r\n    idCountMap[id] = count + 1;\r\n    var indexByIdentifier = getIndexByIdentifier(identifier);\r\n    var obj = {\r\n      css: item[1],\r\n      media: item[2],\r\n      sourceMap: item[3],\r\n      supports: item[4],\r\n      layer: item[5]\r\n    };\r\n    if (indexByIdentifier !== -1) {\r\n      stylesInDOM[indexByIdentifier].references++;\r\n      stylesInDOM[indexByIdentifier].updater(obj);\r\n    } else {\r\n      var updater = addElementStyle(obj, options);\r\n      options.byIndex = i;\r\n      stylesInDOM.splice(i, 0, {\r\n        identifier: identifier,\r\n        updater: updater,\r\n        references: 1\r\n      });\r\n    }\r\n    identifiers.push(identifier);\r\n  }\r\n  return identifiers;\r\n}\r\nfunction addElementStyle(obj, options) {\r\n  var api = options.domAPI(options);\r\n  api.update(obj);\r\n  var updater = function updater(newObj) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\r\n        return;\r\n      }\r\n      api.update(obj = newObj);\r\n    } else {\r\n      api.remove();\r\n    }\r\n  };\r\n  return updater;\r\n}\r\nmodule.exports = function (list, options) {\r\n  options = options || {};\r\n  list = list || [];\r\n  var lastIdentifiers = modulesToDom(list, options);\r\n  return function update(newList) {\r\n    newList = newList || [];\r\n    for (var i = 0; i < lastIdentifiers.length; i++) {\r\n      var identifier = lastIdentifiers[i];\r\n      var index = getIndexByIdentifier(identifier);\r\n      stylesInDOM[index].references--;\r\n    }\r\n    var newLastIdentifiers = modulesToDom(newList, options);\r\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\r\n      var _identifier = lastIdentifiers[_i];\r\n      var _index = getIndexByIdentifier(_identifier);\r\n      if (stylesInDOM[_index].references === 0) {\r\n        stylesInDOM[_index].updater();\r\n        stylesInDOM.splice(_index, 1);\r\n      }\r\n    }\r\n    lastIdentifiers = newLastIdentifiers;\r\n  };\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29zY2lsbG9zY29wZS1zaW11bGF0b3IvRDpcXFVzZXJzXFxhc3VzXFxEZXNrdG9wXFx3ZWLpobnnm65cXGRlbW8xXFxub2RlX21vZHVsZXNcXHN0eWxlLWxvYWRlclxcZGlzdFxccnVudGltZVxcaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzdjNjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcclxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xyXG4gIHZhciByZXN1bHQgPSAtMTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xyXG4gICAgICByZXN1bHQgPSBpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xyXG4gIHZhciBpZENvdW50TWFwID0ge307XHJcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XHJcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcclxuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XHJcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcclxuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xyXG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XHJcbiAgICB2YXIgb2JqID0ge1xyXG4gICAgICBjc3M6IGl0ZW1bMV0sXHJcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxyXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXHJcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxyXG4gICAgICBsYXllcjogaXRlbVs1XVxyXG4gICAgfTtcclxuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcclxuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcclxuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XHJcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XHJcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XHJcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcclxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxyXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xyXG4gIH1cclxuICByZXR1cm4gaWRlbnRpZmllcnM7XHJcbn1cclxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcclxuICBhcGkudXBkYXRlKG9iaik7XHJcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xyXG4gICAgaWYgKG5ld09iaikge1xyXG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFwaS5yZW1vdmUoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiB1cGRhdGVyO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBsaXN0ID0gbGlzdCB8fCBbXTtcclxuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xyXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcclxuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XHJcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XHJcbiAgICB9XHJcbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcclxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcclxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xyXG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xyXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XHJcbiAgfTtcclxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///202\n')},244:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GS: () => (/* binding */ Easing),\n/* harmony export */   K: () => (/* binding */ Tween),\n/* harmony export */   YJ: () => (/* binding */ Group)\n/* harmony export */ });\n/* unused harmony exports Interpolation, Sequence, VERSION, add, default, getAll, nextId, now, remove, removeAll, update */\n/**\r\n * The Ease class provides a collection of easing functions for use with tween.js.\r\n */\r\nvar Easing = Object.freeze({\r\n    Linear: Object.freeze({\r\n        None: function (amount) {\r\n            return amount;\r\n        },\r\n        In: function (amount) {\r\n            return amount;\r\n        },\r\n        Out: function (amount) {\r\n            return amount;\r\n        },\r\n        InOut: function (amount) {\r\n            return amount;\r\n        },\r\n    }),\r\n    Quadratic: Object.freeze({\r\n        In: function (amount) {\r\n            return amount * amount;\r\n        },\r\n        Out: function (amount) {\r\n            return amount * (2 - amount);\r\n        },\r\n        InOut: function (amount) {\r\n            if ((amount *= 2) < 1) {\r\n                return 0.5 * amount * amount;\r\n            }\r\n            return -0.5 * (--amount * (amount - 2) - 1);\r\n        },\r\n    }),\r\n    Cubic: Object.freeze({\r\n        In: function (amount) {\r\n            return amount * amount * amount;\r\n        },\r\n        Out: function (amount) {\r\n            return --amount * amount * amount + 1;\r\n        },\r\n        InOut: function (amount) {\r\n            if ((amount *= 2) < 1) {\r\n                return 0.5 * amount * amount * amount;\r\n            }\r\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\r\n        },\r\n    }),\r\n    Quartic: Object.freeze({\r\n        In: function (amount) {\r\n            return amount * amount * amount * amount;\r\n        },\r\n        Out: function (amount) {\r\n            return 1 - --amount * amount * amount * amount;\r\n        },\r\n        InOut: function (amount) {\r\n            if ((amount *= 2) < 1) {\r\n                return 0.5 * amount * amount * amount * amount;\r\n            }\r\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\r\n        },\r\n    }),\r\n    Quintic: Object.freeze({\r\n        In: function (amount) {\r\n            return amount * amount * amount * amount * amount;\r\n        },\r\n        Out: function (amount) {\r\n            return --amount * amount * amount * amount * amount + 1;\r\n        },\r\n        InOut: function (amount) {\r\n            if ((amount *= 2) < 1) {\r\n                return 0.5 * amount * amount * amount * amount * amount;\r\n            }\r\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\r\n        },\r\n    }),\r\n    Sinusoidal: Object.freeze({\r\n        In: function (amount) {\r\n            return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\r\n        },\r\n        Out: function (amount) {\r\n            return Math.sin((amount * Math.PI) / 2);\r\n        },\r\n        InOut: function (amount) {\r\n            return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\r\n        },\r\n    }),\r\n    Exponential: Object.freeze({\r\n        In: function (amount) {\r\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\r\n        },\r\n        Out: function (amount) {\r\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\r\n        },\r\n        InOut: function (amount) {\r\n            if (amount === 0) {\r\n                return 0;\r\n            }\r\n            if (amount === 1) {\r\n                return 1;\r\n            }\r\n            if ((amount *= 2) < 1) {\r\n                return 0.5 * Math.pow(1024, amount - 1);\r\n            }\r\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\r\n        },\r\n    }),\r\n    Circular: Object.freeze({\r\n        In: function (amount) {\r\n            return 1 - Math.sqrt(1 - amount * amount);\r\n        },\r\n        Out: function (amount) {\r\n            return Math.sqrt(1 - --amount * amount);\r\n        },\r\n        InOut: function (amount) {\r\n            if ((amount *= 2) < 1) {\r\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\r\n            }\r\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\r\n        },\r\n    }),\r\n    Elastic: Object.freeze({\r\n        In: function (amount) {\r\n            if (amount === 0) {\r\n                return 0;\r\n            }\r\n            if (amount === 1) {\r\n                return 1;\r\n            }\r\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\r\n        },\r\n        Out: function (amount) {\r\n            if (amount === 0) {\r\n                return 0;\r\n            }\r\n            if (amount === 1) {\r\n                return 1;\r\n            }\r\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\r\n        },\r\n        InOut: function (amount) {\r\n            if (amount === 0) {\r\n                return 0;\r\n            }\r\n            if (amount === 1) {\r\n                return 1;\r\n            }\r\n            amount *= 2;\r\n            if (amount < 1) {\r\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\r\n            }\r\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\r\n        },\r\n    }),\r\n    Back: Object.freeze({\r\n        In: function (amount) {\r\n            var s = 1.70158;\r\n            return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\r\n        },\r\n        Out: function (amount) {\r\n            var s = 1.70158;\r\n            return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;\r\n        },\r\n        InOut: function (amount) {\r\n            var s = 1.70158 * 1.525;\r\n            if ((amount *= 2) < 1) {\r\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\r\n            }\r\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\r\n        },\r\n    }),\r\n    Bounce: Object.freeze({\r\n        In: function (amount) {\r\n            return 1 - Easing.Bounce.Out(1 - amount);\r\n        },\r\n        Out: function (amount) {\r\n            if (amount < 1 / 2.75) {\r\n                return 7.5625 * amount * amount;\r\n            }\r\n            else if (amount < 2 / 2.75) {\r\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\r\n            }\r\n            else if (amount < 2.5 / 2.75) {\r\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\r\n            }\r\n            else {\r\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\r\n            }\r\n        },\r\n        InOut: function (amount) {\r\n            if (amount < 0.5) {\r\n                return Easing.Bounce.In(amount * 2) * 0.5;\r\n            }\r\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\r\n        },\r\n    }),\r\n    generatePow: function (power) {\r\n        if (power === void 0) { power = 4; }\r\n        power = power < Number.EPSILON ? Number.EPSILON : power;\r\n        power = power > 10000 ? 10000 : power;\r\n        return {\r\n            In: function (amount) {\r\n                return Math.pow(amount, power);\r\n            },\r\n            Out: function (amount) {\r\n                return 1 - Math.pow((1 - amount), power);\r\n            },\r\n            InOut: function (amount) {\r\n                if (amount < 0.5) {\r\n                    return Math.pow((amount * 2), power) / 2;\r\n                }\r\n                return (1 - Math.pow((2 - amount * 2), power)) / 2 + 0.5;\r\n            },\r\n        };\r\n    },\r\n});\r\n\r\nvar now = function () { return performance.now(); };\r\n\r\n/**\r\n * Controlling groups of tweens\r\n *\r\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\r\n * In these cases, you may want to create your own smaller groups of tween\r\n */\r\nvar Group = /** @class */ (function () {\r\n    function Group() {\r\n        var tweens = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tweens[_i] = arguments[_i];\r\n        }\r\n        this._tweens = {};\r\n        this._tweensAddedDuringUpdate = {};\r\n        this.add.apply(this, tweens);\r\n    }\r\n    Group.prototype.getAll = function () {\r\n        var _this = this;\r\n        return Object.keys(this._tweens).map(function (tweenId) { return _this._tweens[tweenId]; });\r\n    };\r\n    Group.prototype.removeAll = function () {\r\n        this._tweens = {};\r\n    };\r\n    Group.prototype.add = function () {\r\n        var _a;\r\n        var tweens = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tweens[_i] = arguments[_i];\r\n        }\r\n        for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {\r\n            var tween = tweens_1[_b];\r\n            // Remove from any other group first, a tween can only be in one group at a time.\r\n            // @ts-expect-error library internal access\r\n            (_a = tween._group) === null || _a === void 0 ? void 0 : _a.remove(tween);\r\n            // @ts-expect-error library internal access\r\n            tween._group = this;\r\n            this._tweens[tween.getId()] = tween;\r\n            this._tweensAddedDuringUpdate[tween.getId()] = tween;\r\n        }\r\n    };\r\n    Group.prototype.remove = function () {\r\n        var tweens = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tweens[_i] = arguments[_i];\r\n        }\r\n        for (var _a = 0, tweens_2 = tweens; _a < tweens_2.length; _a++) {\r\n            var tween = tweens_2[_a];\r\n            // @ts-expect-error library internal access\r\n            tween._group = undefined;\r\n            delete this._tweens[tween.getId()];\r\n            delete this._tweensAddedDuringUpdate[tween.getId()];\r\n        }\r\n    };\r\n    /** Return true if all tweens in the group are not paused or playing. */\r\n    Group.prototype.allStopped = function () {\r\n        return this.getAll().every(function (tween) { return !tween.isPlaying(); });\r\n    };\r\n    Group.prototype.update = function (time, preserve) {\r\n        if (time === void 0) { time = now(); }\r\n        if (preserve === void 0) { preserve = true; }\r\n        var tweenIds = Object.keys(this._tweens);\r\n        if (tweenIds.length === 0)\r\n            return;\r\n        // Tweens are updated in \"batches\". If you add a new tween during an\r\n        // update, then the new tween will be updated in the next batch.\r\n        // If you remove a tween during an update, it may or may not be updated.\r\n        // However, if the removed tween was added during the current batch,\r\n        // then it will not be updated.\r\n        while (tweenIds.length > 0) {\r\n            this._tweensAddedDuringUpdate = {};\r\n            for (var i = 0; i < tweenIds.length; i++) {\r\n                var tween = this._tweens[tweenIds[i]];\r\n                var autoStart = !preserve;\r\n                if (tween && tween.update(time, autoStart) === false && !preserve)\r\n                    this.remove(tween);\r\n            }\r\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\r\n        }\r\n    };\r\n    return Group;\r\n}());\r\n\r\n/**\r\n *\r\n */\r\nvar Interpolation = {\r\n    Linear: function (v, k) {\r\n        var m = v.length - 1;\r\n        var f = m * k;\r\n        var i = Math.floor(f);\r\n        var fn = Interpolation.Utils.Linear;\r\n        if (k < 0) {\r\n            return fn(v[0], v[1], f);\r\n        }\r\n        if (k > 1) {\r\n            return fn(v[m], v[m - 1], m - f);\r\n        }\r\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\r\n    },\r\n    Bezier: function (v, k) {\r\n        var b = 0;\r\n        var n = v.length - 1;\r\n        var pw = Math.pow;\r\n        var bn = Interpolation.Utils.Bernstein;\r\n        for (var i = 0; i <= n; i++) {\r\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\r\n        }\r\n        return b;\r\n    },\r\n    CatmullRom: function (v, k) {\r\n        var m = v.length - 1;\r\n        var f = m * k;\r\n        var i = Math.floor(f);\r\n        var fn = Interpolation.Utils.CatmullRom;\r\n        if (v[0] === v[m]) {\r\n            if (k < 0) {\r\n                i = Math.floor((f = m * (1 + k)));\r\n            }\r\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\r\n        }\r\n        else {\r\n            if (k < 0) {\r\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\r\n            }\r\n            if (k > 1) {\r\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\r\n            }\r\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\r\n        }\r\n    },\r\n    Utils: {\r\n        Linear: function (p0, p1, t) {\r\n            return (p1 - p0) * t + p0;\r\n        },\r\n        Bernstein: function (n, i) {\r\n            var fc = Interpolation.Utils.Factorial;\r\n            return fc(n) / fc(i) / fc(n - i);\r\n        },\r\n        Factorial: (function () {\r\n            var a = [1];\r\n            return function (n) {\r\n                var s = 1;\r\n                if (a[n]) {\r\n                    return a[n];\r\n                }\r\n                for (var i = n; i > 1; i--) {\r\n                    s *= i;\r\n                }\r\n                a[n] = s;\r\n                return s;\r\n            };\r\n        })(),\r\n        CatmullRom: function (p0, p1, p2, p3, t) {\r\n            var v0 = (p2 - p0) * 0.5;\r\n            var v1 = (p3 - p1) * 0.5;\r\n            var t2 = t * t;\r\n            var t3 = t * t2;\r\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n        },\r\n    },\r\n};\r\n\r\n/**\r\n * Utils\r\n */\r\nvar Sequence = /** @class */ (function () {\r\n    function Sequence() {\r\n    }\r\n    Sequence.nextId = function () {\r\n        return Sequence._nextId++;\r\n    };\r\n    Sequence._nextId = 0;\r\n    return Sequence;\r\n}());\r\n\r\nvar mainGroup = new Group();\r\n\r\n/**\r\n * Tween.js - Licensed under the MIT license\r\n * https://github.com/tweenjs/tween.js\r\n * ----------------------------------------------\r\n *\r\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\r\n * Thank you all, you're awesome!\r\n */\r\nvar Tween = /** @class */ (function () {\r\n    function Tween(object, group) {\r\n        this._isPaused = false;\r\n        this._pauseStart = 0;\r\n        this._valuesStart = {};\r\n        this._valuesEnd = {};\r\n        this._valuesStartRepeat = {};\r\n        this._duration = 1000;\r\n        this._isDynamic = false;\r\n        this._initialRepeat = 0;\r\n        this._repeat = 0;\r\n        this._yoyo = false;\r\n        this._isPlaying = false;\r\n        this._reversed = false;\r\n        this._delayTime = 0;\r\n        this._startTime = 0;\r\n        this._easingFunction = Easing.Linear.None;\r\n        this._interpolationFunction = Interpolation.Linear;\r\n        // eslint-disable-next-line\r\n        this._chainedTweens = [];\r\n        this._onStartCallbackFired = false;\r\n        this._onEveryStartCallbackFired = false;\r\n        this._id = Sequence.nextId();\r\n        this._isChainStopped = false;\r\n        this._propertiesAreSetUp = false;\r\n        this._goToEnd = false;\r\n        this._object = object;\r\n        if (typeof group === 'object') {\r\n            this._group = group;\r\n            group.add(this);\r\n        }\r\n        // Use \"true\" to restore old behavior (will be removed in future release).\r\n        else if (group === true) {\r\n            this._group = mainGroup;\r\n            mainGroup.add(this);\r\n        }\r\n    }\r\n    Tween.prototype.getId = function () {\r\n        return this._id;\r\n    };\r\n    Tween.prototype.isPlaying = function () {\r\n        return this._isPlaying;\r\n    };\r\n    Tween.prototype.isPaused = function () {\r\n        return this._isPaused;\r\n    };\r\n    Tween.prototype.getDuration = function () {\r\n        return this._duration;\r\n    };\r\n    Tween.prototype.to = function (target, duration) {\r\n        if (duration === void 0) { duration = 1000; }\r\n        if (this._isPlaying)\r\n            throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');\r\n        this._valuesEnd = target;\r\n        this._propertiesAreSetUp = false;\r\n        this._duration = duration < 0 ? 0 : duration;\r\n        return this;\r\n    };\r\n    Tween.prototype.duration = function (duration) {\r\n        if (duration === void 0) { duration = 1000; }\r\n        this._duration = duration < 0 ? 0 : duration;\r\n        return this;\r\n    };\r\n    Tween.prototype.dynamic = function (dynamic) {\r\n        if (dynamic === void 0) { dynamic = false; }\r\n        this._isDynamic = dynamic;\r\n        return this;\r\n    };\r\n    Tween.prototype.start = function (time, overrideStartingValues) {\r\n        if (time === void 0) { time = now(); }\r\n        if (overrideStartingValues === void 0) { overrideStartingValues = false; }\r\n        if (this._isPlaying) {\r\n            return this;\r\n        }\r\n        this._repeat = this._initialRepeat;\r\n        if (this._reversed) {\r\n            // If we were reversed (f.e. using the yoyo feature) then we need to\r\n            // flip the tween direction back to forward.\r\n            this._reversed = false;\r\n            for (var property in this._valuesStartRepeat) {\r\n                this._swapEndStartRepeatValues(property);\r\n                this._valuesStart[property] = this._valuesStartRepeat[property];\r\n            }\r\n        }\r\n        this._isPlaying = true;\r\n        this._isPaused = false;\r\n        this._onStartCallbackFired = false;\r\n        this._onEveryStartCallbackFired = false;\r\n        this._isChainStopped = false;\r\n        this._startTime = time;\r\n        this._startTime += this._delayTime;\r\n        if (!this._propertiesAreSetUp || overrideStartingValues) {\r\n            this._propertiesAreSetUp = true;\r\n            // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\r\n            if (!this._isDynamic) {\r\n                var tmp = {};\r\n                for (var prop in this._valuesEnd)\r\n                    tmp[prop] = this._valuesEnd[prop];\r\n                this._valuesEnd = tmp;\r\n            }\r\n            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);\r\n        }\r\n        return this;\r\n    };\r\n    Tween.prototype.startFromCurrentValues = function (time) {\r\n        return this.start(time, true);\r\n    };\r\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {\r\n        for (var property in _valuesEnd) {\r\n            var startValue = _object[property];\r\n            var startValueIsArray = Array.isArray(startValue);\r\n            var propType = startValueIsArray ? 'array' : typeof startValue;\r\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\r\n            // If `to()` specifies a property that doesn't exist in the source object,\r\n            // we should not set that property in the object\r\n            if (propType === 'undefined' || propType === 'function') {\r\n                continue;\r\n            }\r\n            // Check if an Array was provided as property value\r\n            if (isInterpolationList) {\r\n                var endValues = _valuesEnd[property];\r\n                if (endValues.length === 0) {\r\n                    continue;\r\n                }\r\n                // Handle an array of relative values.\r\n                // Creates a local copy of the Array with the start value at the front\r\n                var temp = [startValue];\r\n                for (var i = 0, l = endValues.length; i < l; i += 1) {\r\n                    var value = this._handleRelativeValue(startValue, endValues[i]);\r\n                    if (isNaN(value)) {\r\n                        isInterpolationList = false;\r\n                        console.warn('Found invalid interpolation list. Skipping.');\r\n                        break;\r\n                    }\r\n                    temp.push(value);\r\n                }\r\n                if (isInterpolationList) {\r\n                    // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.\r\n                    _valuesEnd[property] = temp;\r\n                    // }\r\n                }\r\n            }\r\n            // handle the deepness of the values\r\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\r\n                _valuesStart[property] = startValueIsArray ? [] : {};\r\n                var nestedObject = startValue;\r\n                for (var prop in nestedObject) {\r\n                    _valuesStart[property][prop] = nestedObject[prop];\r\n                }\r\n                // TODO? repeat nested values? And yoyo? And array values?\r\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {};\r\n                var endValues = _valuesEnd[property];\r\n                // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\r\n                if (!this._isDynamic) {\r\n                    var tmp = {};\r\n                    for (var prop in endValues)\r\n                        tmp[prop] = endValues[prop];\r\n                    _valuesEnd[property] = endValues = tmp;\r\n                }\r\n                this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);\r\n            }\r\n            else {\r\n                // Save the starting value, but only once unless override is requested.\r\n                if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {\r\n                    _valuesStart[property] = startValue;\r\n                }\r\n                if (!startValueIsArray) {\r\n                    // eslint-disable-next-line\r\n                    // @ts-ignore FIXME?\r\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\r\n                }\r\n                if (isInterpolationList) {\r\n                    // eslint-disable-next-line\r\n                    // @ts-ignore FIXME?\r\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\r\n                }\r\n                else {\r\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Tween.prototype.stop = function () {\r\n        if (!this._isChainStopped) {\r\n            this._isChainStopped = true;\r\n            this.stopChainedTweens();\r\n        }\r\n        if (!this._isPlaying) {\r\n            return this;\r\n        }\r\n        this._isPlaying = false;\r\n        this._isPaused = false;\r\n        if (this._onStopCallback) {\r\n            this._onStopCallback(this._object);\r\n        }\r\n        return this;\r\n    };\r\n    Tween.prototype.end = function () {\r\n        this._goToEnd = true;\r\n        this.update(this._startTime + this._duration);\r\n        return this;\r\n    };\r\n    Tween.prototype.pause = function (time) {\r\n        if (time === void 0) { time = now(); }\r\n        if (this._isPaused || !this._isPlaying) {\r\n            return this;\r\n        }\r\n        this._isPaused = true;\r\n        this._pauseStart = time;\r\n        return this;\r\n    };\r\n    Tween.prototype.resume = function (time) {\r\n        if (time === void 0) { time = now(); }\r\n        if (!this._isPaused || !this._isPlaying) {\r\n            return this;\r\n        }\r\n        this._isPaused = false;\r\n        this._startTime += time - this._pauseStart;\r\n        this._pauseStart = 0;\r\n        return this;\r\n    };\r\n    Tween.prototype.stopChainedTweens = function () {\r\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\r\n            this._chainedTweens[i].stop();\r\n        }\r\n        return this;\r\n    };\r\n    Tween.prototype.group = function (group) {\r\n        if (!group) {\r\n            console.warn('tween.group() without args has been removed, use group.add(tween) instead.');\r\n            return this;\r\n        }\r\n        group.add(this);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the tween from whichever group it is in.\r\n     */\r\n    Tween.prototype.remove = function () {\r\n        var _a;\r\n        (_a = this._group) === null || _a === void 0 ? void 0 : _a.remove(this);\r\n        return this;\r\n    };\r\n    Tween.prototype.delay = function (amount) {\r\n        if (amount === void 0) { amount = 0; }\r\n        this._delayTime = amount;\r\n        return this;\r\n    };\r\n    Tween.prototype.repeat = function (times) {\r\n        if (times === void 0) { times = 0; }\r\n        this._initialRepeat = times;\r\n        this._repeat = times;\r\n        return this;\r\n    };\r\n    Tween.prototype.repeatDelay = function (amount) {\r\n        this._repeatDelayTime = amount;\r\n        return this;\r\n    };\r\n    Tween.prototype.yoyo = function (yoyo) {\r\n        if (yoyo === void 0) { yoyo = false; }\r\n        this._yoyo = yoyo;\r\n        return this;\r\n    };\r\n    Tween.prototype.easing = function (easingFunction) {\r\n        if (easingFunction === void 0) { easingFunction = Easing.Linear.None; }\r\n        this._easingFunction = easingFunction;\r\n        return this;\r\n    };\r\n    Tween.prototype.interpolation = function (interpolationFunction) {\r\n        if (interpolationFunction === void 0) { interpolationFunction = Interpolation.Linear; }\r\n        this._interpolationFunction = interpolationFunction;\r\n        return this;\r\n    };\r\n    // eslint-disable-next-line\r\n    Tween.prototype.chain = function () {\r\n        var tweens = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tweens[_i] = arguments[_i];\r\n        }\r\n        this._chainedTweens = tweens;\r\n        return this;\r\n    };\r\n    Tween.prototype.onStart = function (callback) {\r\n        this._onStartCallback = callback;\r\n        return this;\r\n    };\r\n    Tween.prototype.onEveryStart = function (callback) {\r\n        this._onEveryStartCallback = callback;\r\n        return this;\r\n    };\r\n    Tween.prototype.onUpdate = function (callback) {\r\n        this._onUpdateCallback = callback;\r\n        return this;\r\n    };\r\n    Tween.prototype.onRepeat = function (callback) {\r\n        this._onRepeatCallback = callback;\r\n        return this;\r\n    };\r\n    Tween.prototype.onComplete = function (callback) {\r\n        this._onCompleteCallback = callback;\r\n        return this;\r\n    };\r\n    Tween.prototype.onStop = function (callback) {\r\n        this._onStopCallback = callback;\r\n        return this;\r\n    };\r\n    /**\r\n     * @returns true if the tween is still playing after the update, false\r\n     * otherwise (calling update on a paused tween still returns true because\r\n     * it is still playing, just paused).\r\n     *\r\n     * @param autoStart - When true, calling update will implicitly call start()\r\n     * as well. Note, if you stop() or end() the tween, but are still calling\r\n     * update(), it will start again!\r\n     */\r\n    Tween.prototype.update = function (time, autoStart) {\r\n        var _this = this;\r\n        var _a;\r\n        if (time === void 0) { time = now(); }\r\n        if (autoStart === void 0) { autoStart = Tween.autoStartOnUpdate; }\r\n        if (this._isPaused)\r\n            return true;\r\n        var property;\r\n        if (!this._goToEnd && !this._isPlaying) {\r\n            if (autoStart)\r\n                this.start(time, true);\r\n            else\r\n                return false;\r\n        }\r\n        this._goToEnd = false;\r\n        if (time < this._startTime) {\r\n            return true;\r\n        }\r\n        if (this._onStartCallbackFired === false) {\r\n            if (this._onStartCallback) {\r\n                this._onStartCallback(this._object);\r\n            }\r\n            this._onStartCallbackFired = true;\r\n        }\r\n        if (this._onEveryStartCallbackFired === false) {\r\n            if (this._onEveryStartCallback) {\r\n                this._onEveryStartCallback(this._object);\r\n            }\r\n            this._onEveryStartCallbackFired = true;\r\n        }\r\n        var elapsedTime = time - this._startTime;\r\n        var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);\r\n        var totalTime = this._duration + this._repeat * durationAndDelay;\r\n        var calculateElapsedPortion = function () {\r\n            if (_this._duration === 0)\r\n                return 1;\r\n            if (elapsedTime > totalTime) {\r\n                return 1;\r\n            }\r\n            var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);\r\n            var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;\r\n            // TODO use %?\r\n            // const timeIntoCurrentRepeat = elapsedTime % durationAndDelay\r\n            var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);\r\n            if (portion === 0 && elapsedTime === _this._duration) {\r\n                return 1;\r\n            }\r\n            return portion;\r\n        };\r\n        var elapsed = calculateElapsedPortion();\r\n        var value = this._easingFunction(elapsed);\r\n        // properties transformations\r\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\r\n        if (this._onUpdateCallback) {\r\n            this._onUpdateCallback(this._object, elapsed);\r\n        }\r\n        if (this._duration === 0 || elapsedTime >= this._duration) {\r\n            if (this._repeat > 0) {\r\n                var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);\r\n                if (isFinite(this._repeat)) {\r\n                    this._repeat -= completeCount;\r\n                }\r\n                // Reassign starting values, restart by making startTime = now\r\n                for (property in this._valuesStartRepeat) {\r\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\r\n                        this._valuesStartRepeat[property] =\r\n                            // eslint-disable-next-line\r\n                            // @ts-ignore FIXME?\r\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\r\n                    }\r\n                    if (this._yoyo) {\r\n                        this._swapEndStartRepeatValues(property);\r\n                    }\r\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\r\n                }\r\n                if (this._yoyo) {\r\n                    this._reversed = !this._reversed;\r\n                }\r\n                this._startTime += durationAndDelay * completeCount;\r\n                if (this._onRepeatCallback) {\r\n                    this._onRepeatCallback(this._object);\r\n                }\r\n                this._onEveryStartCallbackFired = false;\r\n                return true;\r\n            }\r\n            else {\r\n                if (this._onCompleteCallback) {\r\n                    this._onCompleteCallback(this._object);\r\n                }\r\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\r\n                    // Make the chained tweens start exactly at the time they should,\r\n                    // even if the `update()` method was called way past the duration of the tween\r\n                    this._chainedTweens[i].start(this._startTime + this._duration, false);\r\n                }\r\n                this._isPlaying = false;\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\r\n        for (var property in _valuesEnd) {\r\n            // Don't update properties that do not exist in the source object\r\n            if (_valuesStart[property] === undefined) {\r\n                continue;\r\n            }\r\n            var start = _valuesStart[property] || 0;\r\n            var end = _valuesEnd[property];\r\n            var startIsArray = Array.isArray(_object[property]);\r\n            var endIsArray = Array.isArray(end);\r\n            var isInterpolationList = !startIsArray && endIsArray;\r\n            if (isInterpolationList) {\r\n                _object[property] = this._interpolationFunction(end, value);\r\n            }\r\n            else if (typeof end === 'object' && end) {\r\n                // eslint-disable-next-line\r\n                // @ts-ignore FIXME?\r\n                this._updateProperties(_object[property], start, end, value);\r\n            }\r\n            else {\r\n                // Parses relative end values with start as base (e.g.: +10, -3)\r\n                end = this._handleRelativeValue(start, end);\r\n                // Protect against non numeric properties.\r\n                if (typeof end === 'number') {\r\n                    // eslint-disable-next-line\r\n                    // @ts-ignore FIXME?\r\n                    _object[property] = start + (end - start) * value;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Tween.prototype._handleRelativeValue = function (start, end) {\r\n        if (typeof end !== 'string') {\r\n            return end;\r\n        }\r\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\r\n            return start + parseFloat(end);\r\n        }\r\n        return parseFloat(end);\r\n    };\r\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\r\n        var tmp = this._valuesStartRepeat[property];\r\n        var endValue = this._valuesEnd[property];\r\n        if (typeof endValue === 'string') {\r\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\r\n        }\r\n        else {\r\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\r\n        }\r\n        this._valuesEnd[property] = tmp;\r\n    };\r\n    Tween.autoStartOnUpdate = false;\r\n    return Tween;\r\n}());\r\n\r\nvar VERSION = '25.0.0';\r\n\r\n/**\r\n * Tween.js - Licensed under the MIT license\r\n * https://github.com/tweenjs/tween.js\r\n * ----------------------------------------------\r\n *\r\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\r\n * Thank you all, you're awesome!\r\n */\r\nvar nextId = Sequence.nextId;\r\n/**\r\n * Controlling groups of tweens\r\n *\r\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\r\n * In these cases, you may want to create your own smaller groups of tweens.\r\n */\r\nvar TWEEN = mainGroup;\r\n// This is the best way to export things in a way that's compatible with both ES\r\n// Modules and CommonJS, without build hacks, and so as not to break the\r\n// existing API.\r\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\r\n/**\r\n * @deprecated The global TWEEN Group will be removed in a following major\r\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n * group.\r\n *\r\n * Old code:\r\n *\r\n * ```js\r\n * import * as TWEEN from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new TWEEN.Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   TWEEN.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n *\r\n * New code:\r\n *\r\n * ```js\r\n * import {Tween, Group} from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * const group = new Group()\r\n * group.add(tween)\r\n * group.add(tween2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   group.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n */\r\nvar getAll = TWEEN.getAll.bind(TWEEN);\r\n/**\r\n * @deprecated The global TWEEN Group will be removed in a following major\r\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n * group.\r\n *\r\n * Old code:\r\n *\r\n * ```js\r\n * import * as TWEEN from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new TWEEN.Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   TWEEN.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n *\r\n * New code:\r\n *\r\n * ```js\r\n * import {Tween, Group} from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * const group = new Group()\r\n * group.add(tween)\r\n * group.add(tween2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   group.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n */\r\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\r\n/**\r\n * @deprecated The global TWEEN Group will be removed in a following major\r\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n * group.\r\n *\r\n * Old code:\r\n *\r\n * ```js\r\n * import * as TWEEN from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new TWEEN.Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   TWEEN.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n *\r\n * New code:\r\n *\r\n * ```js\r\n * import {Tween, Group} from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * const group = new Group()\r\n * group.add(tween)\r\n * group.add(tween2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   group.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n */\r\nvar add = TWEEN.add.bind(TWEEN);\r\n/**\r\n * @deprecated The global TWEEN Group will be removed in a following major\r\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n * group.\r\n *\r\n * Old code:\r\n *\r\n * ```js\r\n * import * as TWEEN from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new TWEEN.Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   TWEEN.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n *\r\n * New code:\r\n *\r\n * ```js\r\n * import {Tween, Group} from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * const group = new Group()\r\n * group.add(tween)\r\n * group.add(tween2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   group.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n */\r\nvar remove = TWEEN.remove.bind(TWEEN);\r\n/**\r\n * @deprecated The global TWEEN Group will be removed in a following major\r\n * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n * group.\r\n *\r\n * Old code:\r\n *\r\n * ```js\r\n * import * as TWEEN from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new TWEEN.Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   TWEEN.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n *\r\n * New code:\r\n *\r\n * ```js\r\n * import {Tween, Group} from '@tweenjs/tween.js'\r\n *\r\n * //...\r\n *\r\n * const tween = new Tween(obj)\r\n * const tween2 = new TWEEN.Tween(obj2)\r\n *\r\n * //...\r\n *\r\n * const group = new Group()\r\n * group.add(tween)\r\n * group.add(tween2)\r\n *\r\n * //...\r\n *\r\n * requestAnimationFrame(function loop(time) {\r\n *   group.update(time)\r\n *   requestAnimationFrame(loop)\r\n * })\r\n * ```\r\n */\r\nvar update = TWEEN.update.bind(TWEEN);\r\nvar exports = {\r\n    Easing: Easing,\r\n    Group: Group,\r\n    Interpolation: Interpolation,\r\n    now: now,\r\n    Sequence: Sequence,\r\n    nextId: nextId,\r\n    Tween: Tween,\r\n    VERSION: VERSION,\r\n    /**\r\n     * @deprecated The global TWEEN Group will be removed in a following major\r\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n     * group.\r\n     *\r\n     * Old code:\r\n     *\r\n     * ```js\r\n     * import * as TWEEN from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new TWEEN.Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   TWEEN.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     *\r\n     * New code:\r\n     *\r\n     * ```js\r\n     * import {Tween, Group} from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * const group = new Group()\r\n     * group.add(tween)\r\n     * group.add(tween2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   group.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     */\r\n    getAll: getAll,\r\n    /**\r\n     * @deprecated The global TWEEN Group will be removed in a following major\r\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n     * group.\r\n     *\r\n     * Old code:\r\n     *\r\n     * ```js\r\n     * import * as TWEEN from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new TWEEN.Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   TWEEN.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     *\r\n     * New code:\r\n     *\r\n     * ```js\r\n     * import {Tween, Group} from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * const group = new Group()\r\n     * group.add(tween)\r\n     * group.add(tween2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   group.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     */\r\n    removeAll: removeAll,\r\n    /**\r\n     * @deprecated The global TWEEN Group will be removed in a following major\r\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n     * group.\r\n     *\r\n     * Old code:\r\n     *\r\n     * ```js\r\n     * import * as TWEEN from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new TWEEN.Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   TWEEN.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     *\r\n     * New code:\r\n     *\r\n     * ```js\r\n     * import {Tween, Group} from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * const group = new Group()\r\n     * group.add(tween)\r\n     * group.add(tween2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   group.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     */\r\n    add: add,\r\n    /**\r\n     * @deprecated The global TWEEN Group will be removed in a following major\r\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n     * group.\r\n     *\r\n     * Old code:\r\n     *\r\n     * ```js\r\n     * import * as TWEEN from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new TWEEN.Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   TWEEN.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     *\r\n     * New code:\r\n     *\r\n     * ```js\r\n     * import {Tween, Group} from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * const group = new Group()\r\n     * group.add(tween)\r\n     * group.add(tween2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   group.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     */\r\n    remove: remove,\r\n    /**\r\n     * @deprecated The global TWEEN Group will be removed in a following major\r\n     * release. To migrate, create a `new Group()` instead of using `TWEEN` as a\r\n     * group.\r\n     *\r\n     * Old code:\r\n     *\r\n     * ```js\r\n     * import * as TWEEN from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new TWEEN.Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   TWEEN.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     *\r\n     * New code:\r\n     *\r\n     * ```js\r\n     * import {Tween, Group} from '@tweenjs/tween.js'\r\n     *\r\n     * //...\r\n     *\r\n     * const tween = new Tween(obj)\r\n     * const tween2 = new TWEEN.Tween(obj2)\r\n     *\r\n     * //...\r\n     *\r\n     * const group = new Group()\r\n     * group.add(tween)\r\n     * group.add(tween2)\r\n     *\r\n     * //...\r\n     *\r\n     * requestAnimationFrame(function loop(time) {\r\n     *   group.update(time)\r\n     *   requestAnimationFrame(loop)\r\n     * })\r\n     * ```\r\n     */\r\n    update: update,\r\n};\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29zY2lsbG9zY29wZS1zaW11bGF0b3IvRDpcXFVzZXJzXFxhc3VzXFxEZXNrdG9wXFx3ZWLpobnnm65cXGRlbW8xXFxub2RlX21vZHVsZXNcXEB0d2VlbmpzXFx0d2Vlbi5qc1xcZGlzdFxcdHdlZW4uZXNtLmpzPzYxOGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCB0d2Vlbi5qcy5cclxuICovXHJcbnZhciBFYXNpbmcgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIExpbmVhcjogT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgTm9uZTogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgfSksXHJcbiAgICBRdWFkcmF0aWM6IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqICgyIC0gYW1vdW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgtLWFtb3VudCAqIChhbW91bnQgLSAyKSAtIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIEN1YmljOiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogYW1vdW50ICsgMik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgUXVhcnRpYzogT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMSAtIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgLSAyKTtcclxuICAgICAgICB9LFxyXG4gICAgfSksXHJcbiAgICBRdWludGljOiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICsgMik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgU2ludXNvaWRhbDogT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNpbigoKDEuMCAtIGFtb3VudCkgKiBNYXRoLlBJKSAvIDIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbigoYW1vdW50ICogTWF0aC5QSSkgLyAyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguc2luKE1hdGguUEkgKiAoMC41IC0gYW1vdW50KSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIEV4cG9uZW50aWFsOiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGFtb3VudCAtIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGFtb3VudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoYW1vdW50IC0gMSkpICsgMik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgQ2lyY3VsYXI6IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBhbW91bnQgKiBhbW91bnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tYW1vdW50ICogYW1vdW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBhbW91bnQgKiBhbW91bnQpIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChhbW91bnQgLT0gMikgKiBhbW91bnQpICsgMSk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgRWxhc3RpYzogT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAxMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KSAqIE1hdGguc2luKChhbW91bnQgLSAwLjEpICogNSAqIE1hdGguUEkpICsgMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFtb3VudCAqPSAyO1xyXG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiBNYXRoLnBvdygyLCAxMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMiwgLTEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpICsgMTtcclxuICAgICAgICB9LFxyXG4gICAgfSksXHJcbiAgICBCYWNrOiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XHJcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDEgPyAxIDogYW1vdW50ICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgLSBzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XHJcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyAwIDogLS1hbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCArIHMpICsgMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xyXG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAoYW1vdW50ICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgLSBzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgKyBzKSArIDIpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIEJvdW5jZTogT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLSBFYXNpbmcuQm91bmNlLk91dCgxIC0gYW1vdW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMSAvIDIuNzUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYW1vdW50IDwgMiAvIDIuNzUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoYW1vdW50IC09IDEuNSAvIDIuNzUpICogYW1vdW50ICsgMC43NTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyLjUgLyAyLjc1KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjI1IC8gMi43NSkgKiBhbW91bnQgKyAwLjkzNzU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjYyNSAvIDIuNzUpICogYW1vdW50ICsgMC45ODQzNzU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPCAwLjUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFYXNpbmcuQm91bmNlLkluKGFtb3VudCAqIDIpICogMC41O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBFYXNpbmcuQm91bmNlLk91dChhbW91bnQgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgZ2VuZXJhdGVQb3c6IGZ1bmN0aW9uIChwb3dlcikge1xyXG4gICAgICAgIGlmIChwb3dlciA9PT0gdm9pZCAwKSB7IHBvd2VyID0gNDsgfVxyXG4gICAgICAgIHBvd2VyID0gcG93ZXIgPCBOdW1iZXIuRVBTSUxPTiA/IE51bWJlci5FUFNJTE9OIDogcG93ZXI7XHJcbiAgICAgICAgcG93ZXIgPSBwb3dlciA+IDEwMDAwID8gMTAwMDAgOiBwb3dlcjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KGFtb3VudCwgcG93ZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coKDEgLSBhbW91bnQpLCBwb3dlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW1vdW50IDwgMC41KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KChhbW91bnQgKiAyKSwgcG93ZXIpIC8gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAoMSAtIE1hdGgucG93KCgyIC0gYW1vdW50ICogMiksIHBvd2VyKSkgLyAyICsgMC41O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcclxuXHJcbnZhciBub3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcclxuXHJcbi8qKlxyXG4gKiBDb250cm9sbGluZyBncm91cHMgb2YgdHdlZW5zXHJcbiAqXHJcbiAqIFVzaW5nIHRoZSBUV0VFTiBzaW5nbGV0b24gdG8gbWFuYWdlIHlvdXIgdHdlZW5zIGNhbiBjYXVzZSBpc3N1ZXMgaW4gbGFyZ2UgYXBwcyB3aXRoIG1hbnkgY29tcG9uZW50cy5cclxuICogSW4gdGhlc2UgY2FzZXMsIHlvdSBtYXkgd2FudCB0byBjcmVhdGUgeW91ciBvd24gc21hbGxlciBncm91cHMgb2YgdHdlZW5cclxuICovXHJcbnZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEdyb3VwKCkge1xyXG4gICAgICAgIHZhciB0d2VlbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB0d2VlbnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHdlZW5zID0ge307XHJcbiAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcclxuICAgICAgICB0aGlzLmFkZC5hcHBseSh0aGlzLCB0d2VlbnMpO1xyXG4gICAgfVxyXG4gICAgR3JvdXAucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnMpLm1hcChmdW5jdGlvbiAodHdlZW5JZCkgeyByZXR1cm4gX3RoaXMuX3R3ZWVuc1t0d2VlbklkXTsgfSk7XHJcbiAgICB9O1xyXG4gICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl90d2VlbnMgPSB7fTtcclxuICAgIH07XHJcbiAgICBHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgdHdlZW5zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdHdlZW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgdHdlZW5zXzEgPSB0d2VlbnM7IF9iIDwgdHdlZW5zXzEubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgIHZhciB0d2VlbiA9IHR3ZWVuc18xW19iXTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYW55IG90aGVyIGdyb3VwIGZpcnN0LCBhIHR3ZWVuIGNhbiBvbmx5IGJlIGluIG9uZSBncm91cCBhdCBhIHRpbWUuXHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbGlicmFyeSBpbnRlcm5hbCBhY2Nlc3NcclxuICAgICAgICAgICAgKF9hID0gdHdlZW4uX2dyb3VwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKHR3ZWVuKTtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsaWJyYXJ5IGludGVybmFsIGFjY2Vzc1xyXG4gICAgICAgICAgICB0d2Vlbi5fZ3JvdXAgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcclxuICAgICAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGVbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHdlZW5zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdHdlZW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgdHdlZW5zXzIgPSB0d2VlbnM7IF9hIDwgdHdlZW5zXzIubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0d2VlbiA9IHR3ZWVuc18yW19hXTtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsaWJyYXJ5IGludGVybmFsIGFjY2Vzc1xyXG4gICAgICAgICAgICB0d2Vlbi5fZ3JvdXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZVt0d2Vlbi5nZXRJZCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIFJldHVybiB0cnVlIGlmIGFsbCB0d2VlbnMgaW4gdGhlIGdyb3VwIGFyZSBub3QgcGF1c2VkIG9yIHBsYXlpbmcuICovXHJcbiAgICBHcm91cC5wcm90b3R5cGUuYWxsU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoKS5ldmVyeShmdW5jdGlvbiAodHdlZW4pIHsgcmV0dXJuICF0d2Vlbi5pc1BsYXlpbmcoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgR3JvdXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBwcmVzZXJ2ZSkge1xyXG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XHJcbiAgICAgICAgaWYgKHByZXNlcnZlID09PSB2b2lkIDApIHsgcHJlc2VydmUgPSB0cnVlOyB9XHJcbiAgICAgICAgdmFyIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKTtcclxuICAgICAgICBpZiAodHdlZW5JZHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gVHdlZW5zIGFyZSB1cGRhdGVkIGluIFwiYmF0Y2hlc1wiLiBJZiB5b3UgYWRkIGEgbmV3IHR3ZWVuIGR1cmluZyBhblxyXG4gICAgICAgIC8vIHVwZGF0ZSwgdGhlbiB0aGUgbmV3IHR3ZWVuIHdpbGwgYmUgdXBkYXRlZCBpbiB0aGUgbmV4dCBiYXRjaC5cclxuICAgICAgICAvLyBJZiB5b3UgcmVtb3ZlIGEgdHdlZW4gZHVyaW5nIGFuIHVwZGF0ZSwgaXQgbWF5IG9yIG1heSBub3QgYmUgdXBkYXRlZC5cclxuICAgICAgICAvLyBIb3dldmVyLCBpZiB0aGUgcmVtb3ZlZCB0d2VlbiB3YXMgYWRkZWQgZHVyaW5nIHRoZSBjdXJyZW50IGJhdGNoLFxyXG4gICAgICAgIC8vIHRoZW4gaXQgd2lsbCBub3QgYmUgdXBkYXRlZC5cclxuICAgICAgICB3aGlsZSAodHdlZW5JZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3ZWVuSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF1dG9TdGFydCA9ICFwcmVzZXJ2ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0d2VlbiAmJiB0d2Vlbi51cGRhdGUodGltZSwgYXV0b1N0YXJ0KSA9PT0gZmFsc2UgJiYgIXByZXNlcnZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHR3ZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEdyb3VwO1xyXG59KCkpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG52YXIgSW50ZXJwb2xhdGlvbiA9IHtcclxuICAgIExpbmVhcjogZnVuY3Rpb24gKHYsIGspIHtcclxuICAgICAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgZiA9IG0gKiBrO1xyXG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcclxuICAgICAgICB2YXIgZm4gPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkxpbmVhcjtcclxuICAgICAgICBpZiAoayA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKHZbMF0sIHZbMV0sIGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoayA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbih2W2ldLCB2W2kgKyAxID4gbSA/IG0gOiBpICsgMV0sIGYgLSBpKTtcclxuICAgIH0sXHJcbiAgICBCZXppZXI6IGZ1bmN0aW9uICh2LCBrKSB7XHJcbiAgICAgICAgdmFyIGIgPSAwO1xyXG4gICAgICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBwdyA9IE1hdGgucG93O1xyXG4gICAgICAgIHZhciBibiA9IEludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKykge1xyXG4gICAgICAgICAgICBiICs9IHB3KDEgLSBrLCBuIC0gaSkgKiBwdyhrLCBpKSAqIHZbaV0gKiBibihuLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGI7XHJcbiAgICB9LFxyXG4gICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHYsIGspIHtcclxuICAgICAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgZiA9IG0gKiBrO1xyXG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcclxuICAgICAgICB2YXIgZm4gPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XHJcbiAgICAgICAgaWYgKHZbMF0gPT09IHZbbV0pIHtcclxuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gTWF0aC5mbG9vcigoZiA9IG0gKiAoMSArIGspKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZuKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoayA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2WzBdIC0gKGZuKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoZm4odlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdLCBmIC0gbSkgLSB2W21dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm4odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgVXRpbHM6IHtcclxuICAgICAgICBMaW5lYXI6IGZ1bmN0aW9uIChwMCwgcDEsIHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEJlcm5zdGVpbjogZnVuY3Rpb24gKG4sIGkpIHtcclxuICAgICAgICAgICAgdmFyIGZjID0gSW50ZXJwb2xhdGlvbi5VdGlscy5GYWN0b3JpYWw7XHJcbiAgICAgICAgICAgIHJldHVybiBmYyhuKSAvIGZjKGkpIC8gZmMobiAtIGkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgRmFjdG9yaWFsOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IFsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYVtuXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhW25dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPiAxOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzICo9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhW25dID0gcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKCksXHJcbiAgICAgICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCB0KSB7XHJcbiAgICAgICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcclxuICAgICAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xyXG4gICAgICAgICAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgICAgICAgICAgdmFyIHQzID0gdCAqIHQyO1xyXG4gICAgICAgICAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogVXRpbHNcclxuICovXHJcbnZhciBTZXF1ZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlcXVlbmNlKCkge1xyXG4gICAgfVxyXG4gICAgU2VxdWVuY2UubmV4dElkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBTZXF1ZW5jZS5fbmV4dElkKys7XHJcbiAgICB9O1xyXG4gICAgU2VxdWVuY2UuX25leHRJZCA9IDA7XHJcbiAgICByZXR1cm4gU2VxdWVuY2U7XHJcbn0oKSk7XHJcblxyXG52YXIgbWFpbkdyb3VwID0gbmV3IEdyb3VwKCk7XHJcblxyXG4vKipcclxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanNcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanMvZ3JhcGhzL2NvbnRyaWJ1dG9ycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBjb250cmlidXRvcnMuXHJcbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxyXG4gKi9cclxudmFyIFR3ZWVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHdlZW4ob2JqZWN0LCBncm91cCkge1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnQgPSB7fTtcclxuICAgICAgICB0aGlzLl92YWx1ZXNFbmQgPSB7fTtcclxuICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMDtcclxuICAgICAgICB0aGlzLl9pc0R5bmFtaWMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pbml0aWFsUmVwZWF0ID0gMDtcclxuICAgICAgICB0aGlzLl9yZXBlYXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3lveW8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IEVhc2luZy5MaW5lYXIuTm9uZTtcclxuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBJbnRlcnBvbGF0aW9uLkxpbmVhcjtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gW107XHJcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faWQgPSBTZXF1ZW5jZS5uZXh0SWQoKTtcclxuICAgICAgICB0aGlzLl9pc0NoYWluU3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXNBcmVTZXRVcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2dvVG9FbmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBncm91cCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcclxuICAgICAgICAgICAgZ3JvdXAuYWRkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVc2UgXCJ0cnVlXCIgdG8gcmVzdG9yZSBvbGQgYmVoYXZpb3IgKHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZSkuXHJcbiAgICAgICAgZWxzZSBpZiAoZ3JvdXAgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXAgPSBtYWluR3JvdXA7XHJcbiAgICAgICAgICAgIG1haW5Hcm91cC5hZGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVHdlZW4ucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BhdXNlZDtcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uICh0YXJnZXQsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAxMDAwOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNhbGwgVHdlZW4udG8oKSB3aGlsZSBUd2VlbiBpcyBhbHJlYWR5IHN0YXJ0ZWQgb3IgcGF1c2VkLiBTdG9wIHRoZSBUd2VlbiBmaXJzdC4nKTtcclxuICAgICAgICB0aGlzLl92YWx1ZXNFbmQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0FyZVNldFVwID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiA8IDAgPyAwIDogZHVyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAxMDAwOyB9XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiA8IDAgPyAwIDogZHVyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLmR5bmFtaWMgPSBmdW5jdGlvbiAoZHluYW1pYykge1xyXG4gICAgICAgIGlmIChkeW5hbWljID09PSB2b2lkIDApIHsgZHluYW1pYyA9IGZhbHNlOyB9XHJcbiAgICAgICAgdGhpcy5faXNEeW5hbWljID0gZHluYW1pYztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xyXG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XHJcbiAgICAgICAgaWYgKG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMgPT09IHZvaWQgMCkgeyBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aGlzLl9pbml0aWFsUmVwZWF0O1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXZlcnNlZCkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHJldmVyc2VkIChmLmUuIHVzaW5nIHRoZSB5b3lvIGZlYXR1cmUpIHRoZW4gd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSB0d2VlbiBkaXJlY3Rpb24gYmFjayB0byBmb3J3YXJkLlxyXG4gICAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSArPSB0aGlzLl9kZWxheVRpbWU7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzQXJlU2V0VXAgfHwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzQXJlU2V0VXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBJZiBkeW5hbWljIGlzIG5vdCBlbmFibGVkLCBjbG9uZSB0aGUgZW5kIHZhbHVlcyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXNzZWQtaW4gZW5kIHZhbHVlcy5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0R5bmFtaWMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fdmFsdWVzRW5kKVxyXG4gICAgICAgICAgICAgICAgICAgIHRtcFtwcm9wXSA9IHRoaXMuX3ZhbHVlc0VuZFtwcm9wXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXModGhpcy5fb2JqZWN0LCB0aGlzLl92YWx1ZXNTdGFydCwgdGhpcy5fdmFsdWVzRW5kLCB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5zdGFydEZyb21DdXJyZW50VmFsdWVzID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCh0aW1lLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3NldHVwUHJvcGVydGllcyA9IGZ1bmN0aW9uIChfb2JqZWN0LCBfdmFsdWVzU3RhcnQsIF92YWx1ZXNFbmQsIF92YWx1ZXNTdGFydFJlcGVhdCwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xyXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBfb2JqZWN0W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWVJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzdGFydFZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyAnYXJyYXknIDogdHlwZW9mIHN0YXJ0VmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0VmFsdWVJc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xyXG4gICAgICAgICAgICAvLyBJZiBgdG8oKWAgc3BlY2lmaWVzIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0LFxyXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgbm90IHNldCB0aGF0IHByb3BlcnR5IGluIHRoZSBvYmplY3RcclxuICAgICAgICAgICAgaWYgKHByb3BUeXBlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXHJcbiAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kVmFsdWVzID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFuIGFycmF5IG9mIHJlbGF0aXZlIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZXMgYSBsb2NhbCBjb3B5IG9mIHRoZSBBcnJheSB3aXRoIHRoZSBzdGFydCB2YWx1ZSBhdCB0aGUgZnJvbnRcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gW3N0YXJ0VmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbmRWYWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5faGFuZGxlUmVsYXRpdmVWYWx1ZShzdGFydFZhbHVlLCBlbmRWYWx1ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnRlcnBvbGF0aW9uTGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvdW5kIGludmFsaWQgaW50ZXJwb2xhdGlvbiBsaXN0LiBTa2lwcGluZy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHsgLy8gaGFuZGxlIGVuZCB2YWx1ZXMgb25seSB0aGUgZmlyc3QgdGltZS4gTk9UIE5FRURFRD8gc2V0dXBQcm9wZXJ0aWVzIGlzIG5vdyBndWFyZGVkIGJ5IF9wcm9wZXJ0aWVzQXJlU2V0VXAuXHJcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGRlZXBuZXNzIG9mIHRoZSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKChwcm9wVHlwZSA9PT0gJ29iamVjdCcgfHwgc3RhcnRWYWx1ZUlzQXJyYXkpICYmIHN0YXJ0VmFsdWUgJiYgIWlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcclxuICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlSXNBcnJheSA/IFtdIDoge307XHJcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkT2JqZWN0ID0gc3RhcnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbmVzdGVkT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XVtwcm9wXSA9IG5lc3RlZE9iamVjdFtwcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8/IHJlcGVhdCBuZXN0ZWQgdmFsdWVzPyBBbmQgeW95bz8gQW5kIGFycmF5IHZhbHVlcz9cclxuICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlSXNBcnJheSA/IFtdIDoge307XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kVmFsdWVzID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkeW5hbWljIGlzIG5vdCBlbmFibGVkLCBjbG9uZSB0aGUgZW5kIHZhbHVlcyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXNzZWQtaW4gZW5kIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNEeW5hbWljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZW5kVmFsdWVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBbcHJvcF0gPSBlbmRWYWx1ZXNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSBlbmRWYWx1ZXMgPSB0bXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXMobmVzdGVkT2JqZWN0LCBfdmFsdWVzU3RhcnRbcHJvcGVydHldLCBlbmRWYWx1ZXMsIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0sIG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgc3RhcnRpbmcgdmFsdWUsIGJ1dCBvbmx5IG9uY2UgdW5sZXNzIG92ZXJyaWRlIGlzIHJlcXVlc3RlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9PT0gJ3VuZGVmaW5lZCcgfHwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydFZhbHVlSXNBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XHJcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cclxuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV0uc2xpY2UoKS5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNDaGFpblN0b3BwZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BDaGFpbmVkVHdlZW5zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLl9vblN0b3BDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9vblN0b3BDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2dvVG9FbmQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gdGltZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3coKTsgfVxyXG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGltZSAtIHRoaXMuX3BhdXNlU3RhcnQ7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLnN0b3BDaGFpbmVkVHdlZW5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gdGhpcy5fY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgIGlmICghZ3JvdXApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0d2Vlbi5ncm91cCgpIHdpdGhvdXQgYXJncyBoYXMgYmVlbiByZW1vdmVkLCB1c2UgZ3JvdXAuYWRkKHR3ZWVuKSBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXAuYWRkKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgdHdlZW4gZnJvbSB3aGljaGV2ZXIgZ3JvdXAgaXQgaXMgaW4uXHJcbiAgICAgKi9cclxuICAgIFR3ZWVuLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuX2dyb3VwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIHsgYW1vdW50ID0gMDsgfVxyXG4gICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IGFtb3VudDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XHJcbiAgICAgICAgaWYgKHRpbWVzID09PSB2b2lkIDApIHsgdGltZXMgPSAwOyB9XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbFJlcGVhdCA9IHRpbWVzO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHRpbWVzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICB0aGlzLl9yZXBlYXREZWxheVRpbWUgPSBhbW91bnQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLnlveW8gPSBmdW5jdGlvbiAoeW95bykge1xyXG4gICAgICAgIGlmICh5b3lvID09PSB2b2lkIDApIHsgeW95byA9IGZhbHNlOyB9XHJcbiAgICAgICAgdGhpcy5feW95byA9IHlveW87XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLmVhc2luZyA9IGZ1bmN0aW9uIChlYXNpbmdGdW5jdGlvbikge1xyXG4gICAgICAgIGlmIChlYXNpbmdGdW5jdGlvbiA9PT0gdm9pZCAwKSB7IGVhc2luZ0Z1bmN0aW9uID0gRWFzaW5nLkxpbmVhci5Ob25lOyB9XHJcbiAgICAgICAgdGhpcy5fZWFzaW5nRnVuY3Rpb24gPSBlYXNpbmdGdW5jdGlvbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuaW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uRnVuY3Rpb24pIHtcclxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkZ1bmN0aW9uID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gSW50ZXJwb2xhdGlvbi5MaW5lYXI7IH1cclxuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHR3ZWVucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHR3ZWVuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gdHdlZW5zO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLm9uRXZlcnlTdGFydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fb25VcGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5vblJlcGVhdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9vblN0b3BDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdlZW4gaXMgc3RpbGwgcGxheWluZyBhZnRlciB0aGUgdXBkYXRlLCBmYWxzZVxyXG4gICAgICogb3RoZXJ3aXNlIChjYWxsaW5nIHVwZGF0ZSBvbiBhIHBhdXNlZCB0d2VlbiBzdGlsbCByZXR1cm5zIHRydWUgYmVjYXVzZVxyXG4gICAgICogaXQgaXMgc3RpbGwgcGxheWluZywganVzdCBwYXVzZWQpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdXRvU3RhcnQgLSBXaGVuIHRydWUsIGNhbGxpbmcgdXBkYXRlIHdpbGwgaW1wbGljaXRseSBjYWxsIHN0YXJ0KClcclxuICAgICAqIGFzIHdlbGwuIE5vdGUsIGlmIHlvdSBzdG9wKCkgb3IgZW5kKCkgdGhlIHR3ZWVuLCBidXQgYXJlIHN0aWxsIGNhbGxpbmdcclxuICAgICAqIHVwZGF0ZSgpLCBpdCB3aWxsIHN0YXJ0IGFnYWluIVxyXG4gICAgICovXHJcbiAgICBUd2Vlbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRpbWUsIGF1dG9TdGFydCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XHJcbiAgICAgICAgaWYgKGF1dG9TdGFydCA9PT0gdm9pZCAwKSB7IGF1dG9TdGFydCA9IFR3ZWVuLmF1dG9TdGFydE9uVXBkYXRlOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB2YXIgcHJvcGVydHk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nb1RvRW5kICYmICF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGF1dG9TdGFydClcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQodGltZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aW1lIDwgdGhpcy5fc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vblN0YXJ0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gdGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcclxuICAgICAgICB2YXIgZHVyYXRpb25BbmREZWxheSA9IHRoaXMuX2R1cmF0aW9uICsgKChfYSA9IHRoaXMuX3JlcGVhdERlbGF5VGltZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fZGVsYXlUaW1lKTtcclxuICAgICAgICB2YXIgdG90YWxUaW1lID0gdGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXQgKiBkdXJhdGlvbkFuZERlbGF5O1xyXG4gICAgICAgIHZhciBjYWxjdWxhdGVFbGFwc2VkUG9ydGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLl9kdXJhdGlvbiA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPiB0b3RhbFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0aW1lc1JlcGVhdGVkID0gTWF0aC50cnVuYyhlbGFwc2VkVGltZSAvIGR1cmF0aW9uQW5kRGVsYXkpO1xyXG4gICAgICAgICAgICB2YXIgdGltZUludG9DdXJyZW50UmVwZWF0ID0gZWxhcHNlZFRpbWUgLSB0aW1lc1JlcGVhdGVkICogZHVyYXRpb25BbmREZWxheTtcclxuICAgICAgICAgICAgLy8gVE9ETyB1c2UgJT9cclxuICAgICAgICAgICAgLy8gY29uc3QgdGltZUludG9DdXJyZW50UmVwZWF0ID0gZWxhcHNlZFRpbWUgJSBkdXJhdGlvbkFuZERlbGF5XHJcbiAgICAgICAgICAgIHZhciBwb3J0aW9uID0gTWF0aC5taW4odGltZUludG9DdXJyZW50UmVwZWF0IC8gX3RoaXMuX2R1cmF0aW9uLCAxKTtcclxuICAgICAgICAgICAgaWYgKHBvcnRpb24gPT09IDAgJiYgZWxhcHNlZFRpbWUgPT09IF90aGlzLl9kdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBvcnRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZWxhcHNlZCA9IGNhbGN1bGF0ZUVsYXBzZWRQb3J0aW9uKCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZWFzaW5nRnVuY3Rpb24oZWxhcHNlZCk7XHJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0cmFuc2Zvcm1hdGlvbnNcclxuICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX29iamVjdCwgdGhpcy5fdmFsdWVzU3RhcnQsIHRoaXMuX3ZhbHVlc0VuZCwgdmFsdWUpO1xyXG4gICAgICAgIGlmICh0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uVXBkYXRlQ2FsbGJhY2sodGhpcy5fb2JqZWN0LCBlbGFwc2VkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2R1cmF0aW9uID09PSAwIHx8IGVsYXBzZWRUaW1lID49IHRoaXMuX2R1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVDb3VudCA9IE1hdGgubWluKE1hdGgudHJ1bmMoKGVsYXBzZWRUaW1lIC0gdGhpcy5fZHVyYXRpb24pIC8gZHVyYXRpb25BbmREZWxheSkgKyAxLCB0aGlzLl9yZXBlYXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHRoaXMuX3JlcGVhdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQgLT0gY29tcGxldGVDb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlYXNzaWduIHN0YXJ0aW5nIHZhbHVlcywgcmVzdGFydCBieSBtYWtpbmcgc3RhcnRUaW1lID0gbm93XHJcbiAgICAgICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl95b3lvICYmIHR5cGVvZiB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdCh0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3lveW8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3lveW8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9ICF0aGlzLl9yZXZlcnNlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSArPSBkdXJhdGlvbkFuZERlbGF5ICogY29tcGxldGVDb3VudDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vblJlcGVhdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25SZXBlYXRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IHRoaXMuX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgY2hhaW5lZCB0d2VlbnMgc3RhcnQgZXhhY3RseSBhdCB0aGUgdGltZSB0aGV5IHNob3VsZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBgdXBkYXRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIHdheSBwYXN0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zW2ldLnN0YXJ0KHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3VwZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCB2YWx1ZSkge1xyXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHByb3BlcnRpZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3RcclxuICAgICAgICAgICAgaWYgKF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgIHZhciBzdGFydElzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9vYmplY3RbcHJvcGVydHldKTtcclxuICAgICAgICAgICAgdmFyIGVuZElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGVuZCk7XHJcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0SXNBcnJheSAmJiBlbmRJc0FycmF5O1xyXG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgX29iamVjdFtwcm9wZXJ0eV0gPSB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24oZW5kLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ29iamVjdCcgJiYgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKF9vYmplY3RbcHJvcGVydHldLCBzdGFydCwgZW5kLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZXMgcmVsYXRpdmUgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IGFzIGJhc2UgKGUuZy46ICsxMCwgLTMpXHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLl9oYW5kbGVSZWxhdGl2ZVZhbHVlKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vbiBudW1lcmljIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xyXG4gICAgICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVHdlZW4ucHJvdG90eXBlLl9oYW5kbGVSZWxhdGl2ZVZhbHVlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZC5jaGFyQXQoMCkgPT09ICcrJyB8fCBlbmQuY2hhckF0KDApID09PSAnLScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbmQpO1xyXG4gICAgfTtcclxuICAgIFR3ZWVuLnByb3RvdHlwZS5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcclxuICAgICAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kVmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSArIHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSA9IHRtcDtcclxuICAgIH07XHJcbiAgICBUd2Vlbi5hdXRvU3RhcnRPblVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIFR3ZWVuO1xyXG59KCkpO1xyXG5cclxudmFyIFZFUlNJT04gPSAnMjUuMC4wJztcclxuXHJcbi8qKlxyXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cclxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXHJcbiAqL1xyXG52YXIgbmV4dElkID0gU2VxdWVuY2UubmV4dElkO1xyXG4vKipcclxuICogQ29udHJvbGxpbmcgZ3JvdXBzIG9mIHR3ZWVuc1xyXG4gKlxyXG4gKiBVc2luZyB0aGUgVFdFRU4gc2luZ2xldG9uIHRvIG1hbmFnZSB5b3VyIHR3ZWVucyBjYW4gY2F1c2UgaXNzdWVzIGluIGxhcmdlIGFwcHMgd2l0aCBtYW55IGNvbXBvbmVudHMuXHJcbiAqIEluIHRoZXNlIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gY3JlYXRlIHlvdXIgb3duIHNtYWxsZXIgZ3JvdXBzIG9mIHR3ZWVucy5cclxuICovXHJcbnZhciBUV0VFTiA9IG1haW5Hcm91cDtcclxuLy8gVGhpcyBpcyB0aGUgYmVzdCB3YXkgdG8gZXhwb3J0IHRoaW5ncyBpbiBhIHdheSB0aGF0J3MgY29tcGF0aWJsZSB3aXRoIGJvdGggRVNcclxuLy8gTW9kdWxlcyBhbmQgQ29tbW9uSlMsIHdpdGhvdXQgYnVpbGQgaGFja3MsIGFuZCBzbyBhcyBub3QgdG8gYnJlYWsgdGhlXHJcbi8vIGV4aXN0aW5nIEFQSS5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE5NjEjaXNzdWVjb21tZW50LTQyMzAzNzg4MVxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcclxuICogcmVsZWFzZS4gVG8gbWlncmF0ZSwgY3JlYXRlIGEgYG5ldyBHcm91cCgpYCBpbnN0ZWFkIG9mIHVzaW5nIGBUV0VFTmAgYXMgYVxyXG4gKiBncm91cC5cclxuICpcclxuICogT2xkIGNvZGU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGltcG9ydCAqIGFzIFRXRUVOIGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiBjb25zdCB0d2VlbiA9IG5ldyBUV0VFTi5Ud2VlbihvYmopXHJcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XHJcbiAqICAgVFdFRU4udXBkYXRlKHRpbWUpXHJcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOZXcgY29kZTpcclxuICpcclxuICogYGBganNcclxuICogaW1wb3J0IHtUd2VlbiwgR3JvdXB9IGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiBjb25zdCB0d2VlbiA9IG5ldyBUd2VlbihvYmopXHJcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpXHJcbiAqIGdyb3VwLmFkZCh0d2VlbilcclxuICogZ3JvdXAuYWRkKHR3ZWVuMilcclxuICpcclxuICogLy8uLi5cclxuICpcclxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gKiAgIGdyb3VwLnVwZGF0ZSh0aW1lKVxyXG4gKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBnZXRBbGwgPSBUV0VFTi5nZXRBbGwuYmluZChUV0VFTik7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBUaGUgZ2xvYmFsIFRXRUVOIEdyb3VwIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZvbGxvd2luZyBtYWpvclxyXG4gKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXHJcbiAqIGdyb3VwLlxyXG4gKlxyXG4gKiBPbGQgY29kZTpcclxuICpcclxuICogYGBganNcclxuICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcclxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICogICBUV0VFTi51cGRhdGUodGltZSlcclxuICogICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIE5ldyBjb2RlOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcclxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcclxuICogZ3JvdXAuYWRkKHR3ZWVuKVxyXG4gKiBncm91cC5hZGQodHdlZW4yKVxyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XHJcbiAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXHJcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIHJlbW92ZUFsbCA9IFRXRUVOLnJlbW92ZUFsbC5iaW5kKFRXRUVOKTtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIFRoZSBnbG9iYWwgVFdFRU4gR3JvdXAgd2lsbCBiZSByZW1vdmVkIGluIGEgZm9sbG93aW5nIG1ham9yXHJcbiAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcclxuICogZ3JvdXAuXHJcbiAqXHJcbiAqIE9sZCBjb2RlOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICpcclxuICogLy8uLi5cclxuICpcclxuICogY29uc3QgdHdlZW4gPSBuZXcgVFdFRU4uVHdlZW4ob2JqKVxyXG4gKiBjb25zdCB0d2VlbjIgPSBuZXcgVFdFRU4uVHdlZW4ob2JqMilcclxuICpcclxuICogLy8uLi5cclxuICpcclxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gKiAgIFRXRUVOLnVwZGF0ZSh0aW1lKVxyXG4gKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogTmV3IGNvZGU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICpcclxuICogLy8uLi5cclxuICpcclxuICogY29uc3QgdHdlZW4gPSBuZXcgVHdlZW4ob2JqKVxyXG4gKiBjb25zdCB0d2VlbjIgPSBuZXcgVFdFRU4uVHdlZW4ob2JqMilcclxuICpcclxuICogLy8uLi5cclxuICpcclxuICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxyXG4gKiBncm91cC5hZGQodHdlZW4pXHJcbiAqIGdyb3VwLmFkZCh0d2VlbjIpXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICogICBncm91cC51cGRhdGUodGltZSlcclxuICogICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG52YXIgYWRkID0gVFdFRU4uYWRkLmJpbmQoVFdFRU4pO1xyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcclxuICogcmVsZWFzZS4gVG8gbWlncmF0ZSwgY3JlYXRlIGEgYG5ldyBHcm91cCgpYCBpbnN0ZWFkIG9mIHVzaW5nIGBUV0VFTmAgYXMgYVxyXG4gKiBncm91cC5cclxuICpcclxuICogT2xkIGNvZGU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGltcG9ydCAqIGFzIFRXRUVOIGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiBjb25zdCB0d2VlbiA9IG5ldyBUV0VFTi5Ud2VlbihvYmopXHJcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XHJcbiAqICAgVFdFRU4udXBkYXRlKHRpbWUpXHJcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOZXcgY29kZTpcclxuICpcclxuICogYGBganNcclxuICogaW1wb3J0IHtUd2VlbiwgR3JvdXB9IGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJ1xyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiBjb25zdCB0d2VlbiA9IG5ldyBUd2VlbihvYmopXHJcbiAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpXHJcbiAqIGdyb3VwLmFkZCh0d2VlbilcclxuICogZ3JvdXAuYWRkKHR3ZWVuMilcclxuICpcclxuICogLy8uLi5cclxuICpcclxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gKiAgIGdyb3VwLnVwZGF0ZSh0aW1lKVxyXG4gKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICovXHJcbnZhciByZW1vdmUgPSBUV0VFTi5yZW1vdmUuYmluZChUV0VFTik7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBUaGUgZ2xvYmFsIFRXRUVOIEdyb3VwIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZvbGxvd2luZyBtYWpvclxyXG4gKiByZWxlYXNlLiBUbyBtaWdyYXRlLCBjcmVhdGUgYSBgbmV3IEdyb3VwKClgIGluc3RlYWQgb2YgdXNpbmcgYFRXRUVOYCBhcyBhXHJcbiAqIGdyb3VwLlxyXG4gKlxyXG4gKiBPbGQgY29kZTpcclxuICpcclxuICogYGBganNcclxuICogaW1wb3J0ICogYXMgVFdFRU4gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcclxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICogICBUV0VFTi51cGRhdGUodGltZSlcclxuICogICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIE5ldyBjb2RlOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpbXBvcnQge1R3ZWVuLCBHcm91cH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcclxuICogY29uc3QgdHdlZW4yID0gbmV3IFRXRUVOLlR3ZWVuKG9iajIpXHJcbiAqXHJcbiAqIC8vLi4uXHJcbiAqXHJcbiAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKClcclxuICogZ3JvdXAuYWRkKHR3ZWVuKVxyXG4gKiBncm91cC5hZGQodHdlZW4yKVxyXG4gKlxyXG4gKiAvLy4uLlxyXG4gKlxyXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCh0aW1lKSB7XHJcbiAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXHJcbiAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIHVwZGF0ZSA9IFRXRUVOLnVwZGF0ZS5iaW5kKFRXRUVOKTtcclxudmFyIGV4cG9ydHMgPSB7XHJcbiAgICBFYXNpbmc6IEVhc2luZyxcclxuICAgIEdyb3VwOiBHcm91cCxcclxuICAgIEludGVycG9sYXRpb246IEludGVycG9sYXRpb24sXHJcbiAgICBub3c6IG5vdyxcclxuICAgIFNlcXVlbmNlOiBTZXF1ZW5jZSxcclxuICAgIG5leHRJZDogbmV4dElkLFxyXG4gICAgVHdlZW46IFR3ZWVuLFxyXG4gICAgVkVSU0lPTjogVkVSU0lPTixcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcclxuICAgICAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcclxuICAgICAqIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIE9sZCBjb2RlOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gICAgICogICBUV0VFTi51cGRhdGUodGltZSlcclxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTmV3IGNvZGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICAgICAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXHJcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBnZXRBbGw6IGdldEFsbCxcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcclxuICAgICAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcclxuICAgICAqIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIE9sZCBjb2RlOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gICAgICogICBUV0VFTi51cGRhdGUodGltZSlcclxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTmV3IGNvZGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICAgICAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXHJcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICByZW1vdmVBbGw6IHJlbW92ZUFsbCxcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcclxuICAgICAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcclxuICAgICAqIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIE9sZCBjb2RlOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gICAgICogICBUV0VFTi51cGRhdGUodGltZSlcclxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTmV3IGNvZGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICAgICAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXHJcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBhZGQ6IGFkZCxcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcclxuICAgICAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcclxuICAgICAqIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIE9sZCBjb2RlOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gICAgICogICBUV0VFTi51cGRhdGUodGltZSlcclxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTmV3IGNvZGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICAgICAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXHJcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICByZW1vdmU6IHJlbW92ZSxcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGdsb2JhbCBUV0VFTiBHcm91cCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmb2xsb3dpbmcgbWFqb3JcclxuICAgICAqIHJlbGVhc2UuIFRvIG1pZ3JhdGUsIGNyZWF0ZSBhIGBuZXcgR3JvdXAoKWAgaW5zdGVhZCBvZiB1c2luZyBgVFdFRU5gIGFzIGFcclxuICAgICAqIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIE9sZCBjb2RlOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBpbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFRXRUVOLlR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AodGltZSkge1xyXG4gICAgICogICBUV0VFTi51cGRhdGUodGltZSlcclxuICAgICAqICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTmV3IGNvZGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGltcG9ydCB7VHdlZW4sIEdyb3VwfSBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcydcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHR3ZWVuID0gbmV3IFR3ZWVuKG9iailcclxuICAgICAqIGNvbnN0IHR3ZWVuMiA9IG5ldyBUV0VFTi5Ud2VlbihvYmoyKVxyXG4gICAgICpcclxuICAgICAqIC8vLi4uXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuKVxyXG4gICAgICogZ3JvdXAuYWRkKHR3ZWVuMilcclxuICAgICAqXHJcbiAgICAgKiAvLy4uLlxyXG4gICAgICpcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKHRpbWUpIHtcclxuICAgICAqICAgZ3JvdXAudXBkYXRlKHRpbWUpXHJcbiAgICAgKiAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB1cGRhdGU6IHVwZGF0ZSxcclxufTtcclxuXHJcbmV4cG9ydCB7IEVhc2luZywgR3JvdXAsIEludGVycG9sYXRpb24sIFNlcXVlbmNlLCBUd2VlbiwgVkVSU0lPTiwgYWRkLCBleHBvcnRzIGFzIGRlZmF1bHQsIGdldEFsbCwgbmV4dElkLCBub3csIHJlbW92ZSwgcmVtb3ZlQWxsLCB1cGRhdGUgfTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///244\n")},464:module=>{eval('\r\n\r\nmodule.exports = function (item) {\r\n  var content = item[1];\r\n  var cssMapping = item[3];\r\n  if (!cssMapping) {\r\n    return content;\r\n  }\r\n  if (typeof btoa === "function") {\r\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\r\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\r\n    var sourceMapping = "/*# ".concat(data, " */");\r\n    return [content].concat([sourceMapping]).join("\\n");\r\n  }\r\n  return [content].join("\\n");\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NjaWxsb3Njb3BlLXNpbXVsYXRvci9EOlxcVXNlcnNcXGFzdXNcXERlc2t0b3BcXHdlYumhueebrlxcZGVtbzFcXG5vZGVfbW9kdWxlc1xcY3NzLWxvYWRlclxcZGlzdFxccnVudGltZVxcc291cmNlTWFwcy5qcz9iOGNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcclxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XHJcbiAgaWYgKCFjc3NNYXBwaW5nKSB7XHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcclxuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcclxuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xyXG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xyXG4gIH1cclxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XHJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///464\n')},472:module=>{eval('\r\n\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function (cssWithMappingToString) {\r\n  var list = [];\r\n\r\n  // return the list of modules as css string\r\n  list.toString = function toString() {\r\n    return this.map(function (item) {\r\n      var content = "";\r\n      var needLayer = typeof item[5] !== "undefined";\r\n      if (item[4]) {\r\n        content += "@supports (".concat(item[4], ") {");\r\n      }\r\n      if (item[2]) {\r\n        content += "@media ".concat(item[2], " {");\r\n      }\r\n      if (needLayer) {\r\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\r\n      }\r\n      content += cssWithMappingToString(item);\r\n      if (needLayer) {\r\n        content += "}";\r\n      }\r\n      if (item[2]) {\r\n        content += "}";\r\n      }\r\n      if (item[4]) {\r\n        content += "}";\r\n      }\r\n      return content;\r\n    }).join("");\r\n  };\r\n\r\n  // import a list of modules into the list\r\n  list.i = function i(modules, media, dedupe, supports, layer) {\r\n    if (typeof modules === "string") {\r\n      modules = [[null, modules, undefined]];\r\n    }\r\n    var alreadyImportedModules = {};\r\n    if (dedupe) {\r\n      for (var k = 0; k < this.length; k++) {\r\n        var id = this[k][0];\r\n        if (id != null) {\r\n          alreadyImportedModules[id] = true;\r\n        }\r\n      }\r\n    }\r\n    for (var _k = 0; _k < modules.length; _k++) {\r\n      var item = [].concat(modules[_k]);\r\n      if (dedupe && alreadyImportedModules[item[0]]) {\r\n        continue;\r\n      }\r\n      if (typeof layer !== "undefined") {\r\n        if (typeof item[5] === "undefined") {\r\n          item[5] = layer;\r\n        } else {\r\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\r\n          item[5] = layer;\r\n        }\r\n      }\r\n      if (media) {\r\n        if (!item[2]) {\r\n          item[2] = media;\r\n        } else {\r\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\r\n          item[2] = media;\r\n        }\r\n      }\r\n      if (supports) {\r\n        if (!item[4]) {\r\n          item[4] = "".concat(supports);\r\n        } else {\r\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\r\n          item[4] = supports;\r\n        }\r\n      }\r\n      list.push(item);\r\n    }\r\n  };\r\n  return list;\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NjaWxsb3Njb3BlLXNpbXVsYXRvci9EOlxcVXNlcnNcXGFzdXNcXERlc2t0b3BcXHdlYumhueebrlxcZGVtbzFcXG5vZGVfbW9kdWxlc1xcY3NzLWxvYWRlclxcZGlzdFxccnVudGltZVxcYXBpLmpzP2M1ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKlxyXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XHJcbiAgdmFyIGxpc3QgPSBbXTtcclxuXHJcbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XHJcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcclxuICAgICAgaWYgKGl0ZW1bNF0pIHtcclxuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGl0ZW1bMl0pIHtcclxuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcclxuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XHJcbiAgICAgIH1cclxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xyXG4gICAgICBpZiAobmVlZExheWVyKSB7XHJcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXRlbVsyXSkge1xyXG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGl0ZW1bNF0pIHtcclxuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgfSkuam9pbihcIlwiKTtcclxuICB9O1xyXG5cclxuICAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XHJcbiAgICB9XHJcbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG4gICAgaWYgKGRlZHVwZSkge1xyXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xyXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcclxuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xyXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XHJcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChtZWRpYSkge1xyXG4gICAgICAgIGlmICghaXRlbVsyXSkge1xyXG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcclxuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN1cHBvcnRzKSB7XHJcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XHJcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xyXG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4gbGlzdDtcclxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///472\n')},505:module=>{eval('\r\n\r\nvar memo = {};\r\n\r\n/* istanbul ignore next  */\r\nfunction getTarget(target) {\r\n  if (typeof memo[target] === "undefined") {\r\n    var styleTarget = document.querySelector(target);\r\n\r\n    // Special case to return head of iframe instead of iframe itself\r\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n      try {\r\n        // This will throw an exception if access to iframe is blocked\r\n        // due to cross-origin restrictions\r\n        styleTarget = styleTarget.contentDocument.head;\r\n      } catch (e) {\r\n        // istanbul ignore next\r\n        styleTarget = null;\r\n      }\r\n    }\r\n    memo[target] = styleTarget;\r\n  }\r\n  return memo[target];\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction insertBySelector(insert, style) {\r\n  var target = getTarget(insert);\r\n  if (!target) {\r\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\r\n  }\r\n  target.appendChild(style);\r\n}\r\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NjaWxsb3Njb3BlLXNpbXVsYXRvci9EOlxcVXNlcnNcXGFzdXNcXERlc2t0b3BcXHdlYumhueebrlxcZGVtbzFcXG5vZGVfbW9kdWxlc1xcc3R5bGUtbG9hZGVyXFxkaXN0XFxydW50aW1lXFxpbnNlcnRCeVNlbGVjdG9yLmpzPzc1MmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbWVtbyA9IHt9O1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXHJcbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcclxuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xyXG5cclxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXHJcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcclxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xyXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XHJcbiAgfVxyXG4gIHJldHVybiBtZW1vW3RhcmdldF07XHJcbn1cclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xyXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcclxuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XHJcbiAgaWYgKCF0YXJnZXQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XHJcbiAgfVxyXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///505\n')},523:module=>{eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction styleTagTransform(css, styleElement) {\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css;\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc2NpbGxvc2NvcGUtc2ltdWxhdG9yL0Q6XFxVc2Vyc1xcYXN1c1xcRGVza3RvcFxcd2Vi6aG555uuXFxkZW1vMVxcbm9kZV9tb2R1bGVzXFxzdHlsZS1sb2FkZXJcXGRpc3RcXHJ1bnRpbWVcXHN0eWxlVGFnVHJhbnNmb3JtLmpzPzEwYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cclxuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcclxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgfVxyXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG4gIH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///523\n")},562:(module,__unused_webpack_exports,__webpack_require__)=>{eval('\r\n\r\n/* istanbul ignore next  */\r\nfunction setAttributesWithoutAttributes(styleElement) {\r\n  var nonce =  true ? __webpack_require__.nc : 0;\r\n  if (nonce) {\r\n    styleElement.setAttribute("nonce", nonce);\r\n  }\r\n}\r\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NjaWxsb3Njb3BlLXNpbXVsYXRvci9EOlxcVXNlcnNcXGFzdXNcXERlc2t0b3BcXHdlYumhueebrlxcZGVtbzFcXG5vZGVfbW9kdWxlc1xcc3R5bGUtbG9hZGVyXFxkaXN0XFxydW50aW1lXFxzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ODEyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xyXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XHJcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xyXG4gIGlmIChub25jZSkge1xyXG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///562\n')},782:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ay: () => (/* binding */ Vue)\n/* harmony export */ });\n/* unused harmony exports EffectScope, computed, customRef, defineAsyncComponent, defineComponent, del, effectScope, getCurrentInstance, getCurrentScope, h, inject, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, mergeDefaults, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onScopeDispose, onServerPrefetch, onUnmounted, onUpdated, provide, proxyRefs, reactive, readonly, ref, set, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, useAttrs, useCssModule, useCssVars, useListeners, useSlots, version, watch, watchEffect, watchPostEffect, watchSyncEffect */\n/*!\r\n * Vue.js v2.7.16\r\n * (c) 2014-2023 Evan You\r\n * Released under the MIT License.\r\n */\r\nvar emptyObject = Object.freeze({});\r\nvar isArray = Array.isArray;\r\n// These helpers produce better VM code in JS engines due to their\r\n// explicitness and function inlining.\r\nfunction isUndef(v) {\r\n    return v === undefined || v === null;\r\n}\r\nfunction isDef(v) {\r\n    return v !== undefined && v !== null;\r\n}\r\nfunction isTrue(v) {\r\n    return v === true;\r\n}\r\nfunction isFalse(v) {\r\n    return v === false;\r\n}\r\n/**\r\n * Check if value is primitive.\r\n */\r\nfunction isPrimitive(value) {\r\n    return (typeof value === 'string' ||\r\n        typeof value === 'number' ||\r\n        // $flow-disable-line\r\n        typeof value === 'symbol' ||\r\n        typeof value === 'boolean');\r\n}\r\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * Quick object check - this is primarily used to tell\r\n * objects from primitive values when we know the value\r\n * is a JSON-compliant type.\r\n */\r\nfunction isObject(obj) {\r\n    return obj !== null && typeof obj === 'object';\r\n}\r\n/**\r\n * Get the raw type string of a value, e.g., [object Object].\r\n */\r\nvar _toString = Object.prototype.toString;\r\nfunction toRawType(value) {\r\n    return _toString.call(value).slice(8, -1);\r\n}\r\n/**\r\n * Strict object type check. Only returns true\r\n * for plain JavaScript objects.\r\n */\r\nfunction isPlainObject(obj) {\r\n    return _toString.call(obj) === '[object Object]';\r\n}\r\nfunction isRegExp(v) {\r\n    return _toString.call(v) === '[object RegExp]';\r\n}\r\n/**\r\n * Check if val is a valid array index.\r\n */\r\nfunction isValidArrayIndex(val) {\r\n    var n = parseFloat(String(val));\r\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\r\n}\r\nfunction isPromise(val) {\r\n    return (isDef(val) &&\r\n        typeof val.then === 'function' &&\r\n        typeof val.catch === 'function');\r\n}\r\n/**\r\n * Convert a value to a string that is actually rendered.\r\n */\r\nfunction toString(val) {\r\n    return val == null\r\n        ? ''\r\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n}\r\nfunction replacer(_key, val) {\r\n    // avoid circular deps from v3\r\n    if (val && val.__v_isRef) {\r\n        return val.value;\r\n    }\r\n    return val;\r\n}\r\n/**\r\n * Convert an input value to a number for persistence.\r\n * If the conversion fails, return original string.\r\n */\r\nfunction toNumber(val) {\r\n    var n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n}\r\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    var map = Object.create(null);\r\n    var list = str.split(',');\r\n    for (var i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };\r\n}\r\n/**\r\n * Check if a tag is a built-in tag.\r\n */\r\nvar isBuiltInTag = makeMap('slot,component', true);\r\n/**\r\n * Check if an attribute is a reserved attribute.\r\n */\r\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\r\n/**\r\n * Remove an item from an array.\r\n */\r\nfunction remove$2(arr, item) {\r\n    var len = arr.length;\r\n    if (len) {\r\n        // fast path for the only / last item\r\n        if (item === arr[len - 1]) {\r\n            arr.length = len - 1;\r\n            return;\r\n        }\r\n        var index = arr.indexOf(item);\r\n        if (index > -1) {\r\n            return arr.splice(index, 1);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Check whether an object has the property.\r\n */\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwn(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n}\r\n/**\r\n * Create a cached version of a pure function.\r\n */\r\nfunction cached(fn) {\r\n    var cache = Object.create(null);\r\n    return function cachedFn(str) {\r\n        var hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    };\r\n}\r\n/**\r\n * Camelize a hyphen-delimited string.\r\n */\r\nvar camelizeRE = /-(\\w)/g;\r\nvar camelize = cached(function (str) {\r\n    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });\r\n});\r\n/**\r\n * Capitalize a string.\r\n */\r\nvar capitalize = cached(function (str) {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n});\r\n/**\r\n * Hyphenate a camelCase string.\r\n */\r\nvar hyphenateRE = /\\B([A-Z])/g;\r\nvar hyphenate = cached(function (str) {\r\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\r\n});\r\n/**\r\n * Simple bind polyfill for environments that do not support it,\r\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\r\n * since native bind is now performant enough in most browsers.\r\n * But removing it would mean breaking code that was able to run in\r\n * PhantomJS 1.x, so this must be kept for backward compatibility.\r\n */\r\n/* istanbul ignore next */\r\nfunction polyfillBind(fn, ctx) {\r\n    function boundFn(a) {\r\n        var l = arguments.length;\r\n        return l\r\n            ? l > 1\r\n                ? fn.apply(ctx, arguments)\r\n                : fn.call(ctx, a)\r\n            : fn.call(ctx);\r\n    }\r\n    boundFn._length = fn.length;\r\n    return boundFn;\r\n}\r\nfunction nativeBind(fn, ctx) {\r\n    return fn.bind(ctx);\r\n}\r\n// @ts-expect-error bind cannot be `undefined`\r\nvar bind$1 = Function.prototype.bind ? nativeBind : polyfillBind;\r\n/**\r\n * Convert an Array-like object to a real Array.\r\n */\r\nfunction toArray(list, start) {\r\n    start = start || 0;\r\n    var i = list.length - start;\r\n    var ret = new Array(i);\r\n    while (i--) {\r\n        ret[i] = list[i + start];\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Mix properties into target object.\r\n */\r\nfunction extend(to, _from) {\r\n    for (var key in _from) {\r\n        to[key] = _from[key];\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Merge an Array of Objects into a single Object.\r\n */\r\nfunction toObject(arr) {\r\n    var res = {};\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (arr[i]) {\r\n            extend(res, arr[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/* eslint-disable no-unused-vars */\r\n/**\r\n * Perform no operation.\r\n * Stubbing args to make Flow happy without leaving useless transpiled code\r\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\r\n */\r\nfunction noop(a, b, c) { }\r\n/**\r\n * Always return false.\r\n */\r\nvar no = function (a, b, c) { return false; };\r\n/* eslint-enable no-unused-vars */\r\n/**\r\n * Return the same value.\r\n */\r\nvar identity = function (_) { return _; };\r\n/**\r\n * Generate a string containing static keys from compiler modules.\r\n */\r\nfunction genStaticKeys$1(modules) {\r\n    return modules\r\n        .reduce(function (keys, m) { return keys.concat(m.staticKeys || []); }, [])\r\n        .join(',');\r\n}\r\n/**\r\n * Check if two values are loosely equal - that is,\r\n * if they are plain objects, do they have the same shape?\r\n */\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    var isObjectA = isObject(a);\r\n    var isObjectB = isObject(b);\r\n    if (isObjectA && isObjectB) {\r\n        try {\r\n            var isArrayA = Array.isArray(a);\r\n            var isArrayB = Array.isArray(b);\r\n            if (isArrayA && isArrayB) {\r\n                return (a.length === b.length &&\r\n                    a.every(function (e, i) {\r\n                        return looseEqual(e, b[i]);\r\n                    }));\r\n            }\r\n            else if (a instanceof Date && b instanceof Date) {\r\n                return a.getTime() === b.getTime();\r\n            }\r\n            else if (!isArrayA && !isArrayB) {\r\n                var keysA = Object.keys(a);\r\n                var keysB = Object.keys(b);\r\n                return (keysA.length === keysB.length &&\r\n                    keysA.every(function (key) {\r\n                        return looseEqual(a[key], b[key]);\r\n                    }));\r\n            }\r\n            else {\r\n                /* istanbul ignore next */\r\n                return false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            /* istanbul ignore next */\r\n            return false;\r\n        }\r\n    }\r\n    else if (!isObjectA && !isObjectB) {\r\n        return String(a) === String(b);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Return the first index at which a loosely equal value can be\r\n * found in the array (if value is a plain object, the array must\r\n * contain an object of the same shape), or -1 if it is not present.\r\n */\r\nfunction looseIndexOf(arr, val) {\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (looseEqual(arr[i], val))\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Ensure a function is called only once.\r\n */\r\nfunction once(fn) {\r\n    var called = false;\r\n    return function () {\r\n        if (!called) {\r\n            called = true;\r\n            fn.apply(this, arguments);\r\n        }\r\n    };\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\r\nfunction hasChanged(x, y) {\r\n    if (x === y) {\r\n        return x === 0 && 1 / x !== 1 / y;\r\n    }\r\n    else {\r\n        return x === x || y === y;\r\n    }\r\n}\r\n\r\nvar SSR_ATTR = 'data-server-rendered';\r\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\r\nvar LIFECYCLE_HOOKS = [\r\n    'beforeCreate',\r\n    'created',\r\n    'beforeMount',\r\n    'mounted',\r\n    'beforeUpdate',\r\n    'updated',\r\n    'beforeDestroy',\r\n    'destroyed',\r\n    'activated',\r\n    'deactivated',\r\n    'errorCaptured',\r\n    'serverPrefetch',\r\n    'renderTracked',\r\n    'renderTriggered'\r\n];\r\n\r\nvar config = {\r\n    /**\r\n     * Option merge strategies (used in core/util/options)\r\n     */\r\n    // $flow-disable-line\r\n    optionMergeStrategies: Object.create(null),\r\n    /**\r\n     * Whether to suppress warnings.\r\n     */\r\n    silent: false,\r\n    /**\r\n     * Show production mode tip message on boot?\r\n     */\r\n    productionTip: \"production\" !== 'production',\r\n    /**\r\n     * Whether to enable devtools\r\n     */\r\n    devtools: \"production\" !== 'production',\r\n    /**\r\n     * Whether to record perf\r\n     */\r\n    performance: false,\r\n    /**\r\n     * Error handler for watcher errors\r\n     */\r\n    errorHandler: null,\r\n    /**\r\n     * Warn handler for watcher warns\r\n     */\r\n    warnHandler: null,\r\n    /**\r\n     * Ignore certain custom elements\r\n     */\r\n    ignoredElements: [],\r\n    /**\r\n     * Custom user key aliases for v-on\r\n     */\r\n    // $flow-disable-line\r\n    keyCodes: Object.create(null),\r\n    /**\r\n     * Check if a tag is reserved so that it cannot be registered as a\r\n     * component. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedTag: no,\r\n    /**\r\n     * Check if an attribute is reserved so that it cannot be used as a component\r\n     * prop. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedAttr: no,\r\n    /**\r\n     * Check if a tag is an unknown element.\r\n     * Platform-dependent.\r\n     */\r\n    isUnknownElement: no,\r\n    /**\r\n     * Get the namespace of an element\r\n     */\r\n    getTagNamespace: noop,\r\n    /**\r\n     * Parse the real tag name for the specific platform.\r\n     */\r\n    parsePlatformTagName: identity,\r\n    /**\r\n     * Check if an attribute must be bound using property, e.g. value\r\n     * Platform-dependent.\r\n     */\r\n    mustUseProp: no,\r\n    /**\r\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\r\n     * This will significantly reduce performance if set to false.\r\n     */\r\n    async: true,\r\n    /**\r\n     * Exposed for legacy reasons\r\n     */\r\n    _lifecycleHooks: LIFECYCLE_HOOKS\r\n};\r\n\r\n/**\r\n * unicode letters used for parsing html tags, component names and property paths.\r\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\r\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\r\n */\r\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\r\n/**\r\n * Check if a string starts with $ or _\r\n */\r\nfunction isReserved(str) {\r\n    var c = (str + '').charCodeAt(0);\r\n    return c === 0x24 || c === 0x5f;\r\n}\r\n/**\r\n * Define a property.\r\n */\r\nfunction def(obj, key, val, enumerable) {\r\n    Object.defineProperty(obj, key, {\r\n        value: val,\r\n        enumerable: !!enumerable,\r\n        writable: true,\r\n        configurable: true\r\n    });\r\n}\r\n/**\r\n * Parse simple path.\r\n */\r\nvar bailRE = new RegExp(\"[^\".concat(unicodeRegExp.source, \".$_\\\\d]\"));\r\nfunction parsePath(path) {\r\n    if (bailRE.test(path)) {\r\n        return;\r\n    }\r\n    var segments = path.split('.');\r\n    return function (obj) {\r\n        for (var i = 0; i < segments.length; i++) {\r\n            if (!obj)\r\n                return;\r\n            obj = obj[segments[i]];\r\n        }\r\n        return obj;\r\n    };\r\n}\r\n\r\n// can we use __proto__?\r\nvar hasProto = '__proto__' in {};\r\n// Browser environment sniffing\r\nvar inBrowser = typeof window !== 'undefined';\r\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\r\nvar isIE = UA && /msie|trident/.test(UA);\r\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\nvar isEdge = UA && UA.indexOf('edge/') > 0;\r\nUA && UA.indexOf('android') > 0;\r\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\r\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\r\nUA && /phantomjs/.test(UA);\r\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\r\n// Firefox has a \"watch\" function on Object.prototype...\r\n// @ts-expect-error firebox support\r\nvar nativeWatch = {}.watch;\r\nvar supportsPassive = false;\r\nif (inBrowser) {\r\n    try {\r\n        var opts = {};\r\n        Object.defineProperty(opts, 'passive', {\r\n            get: function () {\r\n                /* istanbul ignore next */\r\n                supportsPassive = true;\r\n            }\r\n        }); // https://github.com/facebook/flow/issues/285\r\n        window.addEventListener('test-passive', null, opts);\r\n    }\r\n    catch (e) { }\r\n}\r\n// this needs to be lazy-evaled because vue may be required before\r\n// vue-server-renderer can set VUE_ENV\r\nvar _isServer;\r\nvar isServerRendering = function () {\r\n    if (_isServer === undefined) {\r\n        /* istanbul ignore if */\r\n        if (!inBrowser && typeof __webpack_require__.g !== 'undefined') {\r\n            // detect presence of vue-server-renderer and avoid\r\n            // Webpack shimming the process\r\n            _isServer =\r\n                __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';\r\n        }\r\n        else {\r\n            _isServer = false;\r\n        }\r\n    }\r\n    return _isServer;\r\n};\r\n// detect devtools\r\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\r\n/* istanbul ignore next */\r\nfunction isNative(Ctor) {\r\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\r\n}\r\nvar hasSymbol = typeof Symbol !== 'undefined' &&\r\n    isNative(Symbol) &&\r\n    typeof Reflect !== 'undefined' &&\r\n    isNative(Reflect.ownKeys);\r\nvar _Set; // $flow-disable-line\r\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\r\n    // use native Set when available.\r\n    _Set = Set;\r\n}\r\nelse {\r\n    // a non-standard Set polyfill that only works with primitive keys.\r\n    _Set = /** @class */ (function () {\r\n        function Set() {\r\n            this.set = Object.create(null);\r\n        }\r\n        Set.prototype.has = function (key) {\r\n            return this.set[key] === true;\r\n        };\r\n        Set.prototype.add = function (key) {\r\n            this.set[key] = true;\r\n        };\r\n        Set.prototype.clear = function () {\r\n            this.set = Object.create(null);\r\n        };\r\n        return Set;\r\n    }());\r\n}\r\n\r\nvar currentInstance = null;\r\n/**\r\n * This is exposed for compatibility with v3 (e.g. some functions in VueUse\r\n * relies on it). Do not use this internally, just use `currentInstance`.\r\n *\r\n * @internal this function needs manual type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction getCurrentInstance() {\r\n    return currentInstance && { proxy: currentInstance };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction setCurrentInstance(vm) {\r\n    if (vm === void 0) { vm = null; }\r\n    if (!vm)\r\n        currentInstance && currentInstance._scope.off();\r\n    currentInstance = vm;\r\n    vm && vm._scope.on();\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nvar VNode = /** @class */ (function () {\r\n    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\r\n        this.tag = tag;\r\n        this.data = data;\r\n        this.children = children;\r\n        this.text = text;\r\n        this.elm = elm;\r\n        this.ns = undefined;\r\n        this.context = context;\r\n        this.fnContext = undefined;\r\n        this.fnOptions = undefined;\r\n        this.fnScopeId = undefined;\r\n        this.key = data && data.key;\r\n        this.componentOptions = componentOptions;\r\n        this.componentInstance = undefined;\r\n        this.parent = undefined;\r\n        this.raw = false;\r\n        this.isStatic = false;\r\n        this.isRootInsert = true;\r\n        this.isComment = false;\r\n        this.isCloned = false;\r\n        this.isOnce = false;\r\n        this.asyncFactory = asyncFactory;\r\n        this.asyncMeta = undefined;\r\n        this.isAsyncPlaceholder = false;\r\n    }\r\n    Object.defineProperty(VNode.prototype, \"child\", {\r\n        // DEPRECATED: alias for componentInstance for backwards compat.\r\n        /* istanbul ignore next */\r\n        get: function () {\r\n            return this.componentInstance;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return VNode;\r\n}());\r\nvar createEmptyVNode = function (text) {\r\n    if (text === void 0) { text = ''; }\r\n    var node = new VNode();\r\n    node.text = text;\r\n    node.isComment = true;\r\n    return node;\r\n};\r\nfunction createTextVNode(val) {\r\n    return new VNode(undefined, undefined, undefined, String(val));\r\n}\r\n// optimized shallow clone\r\n// used for static nodes and slot nodes because they may be reused across\r\n// multiple renders, cloning them avoids errors when DOM manipulations rely\r\n// on their elm reference.\r\nfunction cloneVNode(vnode) {\r\n    var cloned = new VNode(vnode.tag, vnode.data, \r\n    // #7975\r\n    // clone children array to avoid mutating original in case of cloning\r\n    // a child.\r\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\r\n    cloned.ns = vnode.ns;\r\n    cloned.isStatic = vnode.isStatic;\r\n    cloned.key = vnode.key;\r\n    cloned.isComment = vnode.isComment;\r\n    cloned.fnContext = vnode.fnContext;\r\n    cloned.fnOptions = vnode.fnOptions;\r\n    cloned.fnScopeId = vnode.fnScopeId;\r\n    cloned.asyncMeta = vnode.asyncMeta;\r\n    cloned.isCloned = true;\r\n    return cloned;\r\n}\r\n\r\n/* not type checking this file because flow doesn't play well with Proxy */\r\nvar initProxy;\r\nif (false) // removed by dead control flow\n{ var getHandler_1, hasHandler_1, isBuiltInModifier_1, hasProxy_1, warnReservedPrefix_1, warnNonPresent_1, allowedGlobals_1; }\r\n\r\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nvar uid$2 = 0;\r\nvar pendingCleanupDeps = [];\r\nvar cleanupDeps = function () {\r\n    for (var i = 0; i < pendingCleanupDeps.length; i++) {\r\n        var dep = pendingCleanupDeps[i];\r\n        dep.subs = dep.subs.filter(function (s) { return s; });\r\n        dep._pending = false;\r\n    }\r\n    pendingCleanupDeps.length = 0;\r\n};\r\n/**\r\n * A dep is an observable that can have multiple\r\n * directives subscribing to it.\r\n * @internal\r\n */\r\nvar Dep = /** @class */ (function () {\r\n    function Dep() {\r\n        // pending subs cleanup\r\n        this._pending = false;\r\n        this.id = uid$2++;\r\n        this.subs = [];\r\n    }\r\n    Dep.prototype.addSub = function (sub) {\r\n        this.subs.push(sub);\r\n    };\r\n    Dep.prototype.removeSub = function (sub) {\r\n        // #12696 deps with massive amount of subscribers are extremely slow to\r\n        // clean up in Chromium\r\n        // to workaround this, we unset the sub for now, and clear them on\r\n        // next scheduler flush.\r\n        this.subs[this.subs.indexOf(sub)] = null;\r\n        if (!this._pending) {\r\n            this._pending = true;\r\n            pendingCleanupDeps.push(this);\r\n        }\r\n    };\r\n    Dep.prototype.depend = function (info) {\r\n        if (Dep.target) {\r\n            Dep.target.addDep(this);\r\n            if (false) // removed by dead control flow\n{}\r\n        }\r\n    };\r\n    Dep.prototype.notify = function (info) {\r\n        // stabilize the subscriber list first\r\n        var subs = this.subs.filter(function (s) { return s; });\r\n        if (false) // removed by dead control flow\n{}\r\n        for (var i = 0, l = subs.length; i < l; i++) {\r\n            var sub = subs[i];\r\n            if (false) // removed by dead control flow\n{}\r\n            sub.update();\r\n        }\r\n    };\r\n    return Dep;\r\n}());\r\n// The current target watcher being evaluated.\r\n// This is globally unique because only one watcher\r\n// can be evaluated at a time.\r\nDep.target = null;\r\nvar targetStack = [];\r\nfunction pushTarget(target) {\r\n    targetStack.push(target);\r\n    Dep.target = target;\r\n}\r\nfunction popTarget() {\r\n    targetStack.pop();\r\n    Dep.target = targetStack[targetStack.length - 1];\r\n}\r\n\r\n/*\r\n * not type checking this file because flow doesn't play well with\r\n * dynamically accessing methods on Array prototype\r\n */\r\nvar arrayProto = Array.prototype;\r\nvar arrayMethods = Object.create(arrayProto);\r\nvar methodsToPatch = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'unshift',\r\n    'splice',\r\n    'sort',\r\n    'reverse'\r\n];\r\n/**\r\n * Intercept mutating methods and emit events\r\n */\r\nmethodsToPatch.forEach(function (method) {\r\n    // cache original method\r\n    var original = arrayProto[method];\r\n    def(arrayMethods, method, function mutator() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var result = original.apply(this, args);\r\n        var ob = this.__ob__;\r\n        var inserted;\r\n        switch (method) {\r\n            case 'push':\r\n            case 'unshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':\r\n                inserted = args.slice(2);\r\n                break;\r\n        }\r\n        if (inserted)\r\n            ob.observeArray(inserted);\r\n        // notify change\r\n        if (false) // removed by dead control flow\n{}\r\n        else {\r\n            ob.dep.notify();\r\n        }\r\n        return result;\r\n    });\r\n});\r\n\r\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\r\nvar NO_INITIAL_VALUE = {};\r\n/**\r\n * In some cases we may want to disable observation inside a component's\r\n * update computation.\r\n */\r\nvar shouldObserve = true;\r\nfunction toggleObserving(value) {\r\n    shouldObserve = value;\r\n}\r\n// ssr mock dep\r\nvar mockDep = {\r\n    notify: noop,\r\n    depend: noop,\r\n    addSub: noop,\r\n    removeSub: noop\r\n};\r\n/**\r\n * Observer class that is attached to each observed\r\n * object. Once attached, the observer converts the target\r\n * object's property keys into getter/setters that\r\n * collect dependencies and dispatch updates.\r\n */\r\nvar Observer = /** @class */ (function () {\r\n    function Observer(value, shallow, mock) {\r\n        if (shallow === void 0) { shallow = false; }\r\n        if (mock === void 0) { mock = false; }\r\n        this.value = value;\r\n        this.shallow = shallow;\r\n        this.mock = mock;\r\n        // this.value = value\r\n        this.dep = mock ? mockDep : new Dep();\r\n        this.vmCount = 0;\r\n        def(value, '__ob__', this);\r\n        if (isArray(value)) {\r\n            if (!mock) {\r\n                if (hasProto) {\r\n                    value.__proto__ = arrayMethods;\r\n                    /* eslint-enable no-proto */\r\n                }\r\n                else {\r\n                    for (var i = 0, l = arrayKeys.length; i < l; i++) {\r\n                        var key = arrayKeys[i];\r\n                        def(value, key, arrayMethods[key]);\r\n                    }\r\n                }\r\n            }\r\n            if (!shallow) {\r\n                this.observeArray(value);\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Walk through all properties and convert them into\r\n             * getter/setters. This method should only be called when\r\n             * value type is Object.\r\n             */\r\n            var keys = Object.keys(value);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var key = keys[i];\r\n                defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Observe a list of Array items.\r\n     */\r\n    Observer.prototype.observeArray = function (value) {\r\n        for (var i = 0, l = value.length; i < l; i++) {\r\n            observe(value[i], false, this.mock);\r\n        }\r\n    };\r\n    return Observer;\r\n}());\r\n// helpers\r\n/**\r\n * Attempt to create an observer instance for a value,\r\n * returns the new observer if successfully observed,\r\n * or the existing observer if the value already has one.\r\n */\r\nfunction observe(value, shallow, ssrMockReactivity) {\r\n    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\r\n        return value.__ob__;\r\n    }\r\n    if (shouldObserve &&\r\n        (ssrMockReactivity || !isServerRendering()) &&\r\n        (isArray(value) || isPlainObject(value)) &&\r\n        Object.isExtensible(value) &&\r\n        !value.__v_skip /* ReactiveFlags.SKIP */ &&\r\n        !isRef(value) &&\r\n        !(value instanceof VNode)) {\r\n        return new Observer(value, shallow, ssrMockReactivity);\r\n    }\r\n}\r\n/**\r\n * Define a reactive property on an Object.\r\n */\r\nfunction defineReactive(obj, key, val, customSetter, shallow, mock, observeEvenIfShallow) {\r\n    if (observeEvenIfShallow === void 0) { observeEvenIfShallow = false; }\r\n    var dep = new Dep();\r\n    var property = Object.getOwnPropertyDescriptor(obj, key);\r\n    if (property && property.configurable === false) {\r\n        return;\r\n    }\r\n    // cater for pre-defined getter/setters\r\n    var getter = property && property.get;\r\n    var setter = property && property.set;\r\n    if ((!getter || setter) &&\r\n        (val === NO_INITIAL_VALUE || arguments.length === 2)) {\r\n        val = obj[key];\r\n    }\r\n    var childOb = shallow ? val && val.__ob__ : observe(val, false, mock);\r\n    Object.defineProperty(obj, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function reactiveGetter() {\r\n            var value = getter ? getter.call(obj) : val;\r\n            if (Dep.target) {\r\n                if (false) // removed by dead control flow\n{}\r\n                else {\r\n                    dep.depend();\r\n                }\r\n                if (childOb) {\r\n                    childOb.dep.depend();\r\n                    if (isArray(value)) {\r\n                        dependArray(value);\r\n                    }\r\n                }\r\n            }\r\n            return isRef(value) && !shallow ? value.value : value;\r\n        },\r\n        set: function reactiveSetter(newVal) {\r\n            var value = getter ? getter.call(obj) : val;\r\n            if (!hasChanged(value, newVal)) {\r\n                return;\r\n            }\r\n            if (false) // removed by dead control flow\n{}\r\n            if (setter) {\r\n                setter.call(obj, newVal);\r\n            }\r\n            else if (getter) {\r\n                // #7981: for accessor properties without setter\r\n                return;\r\n            }\r\n            else if (!shallow && isRef(value) && !isRef(newVal)) {\r\n                value.value = newVal;\r\n                return;\r\n            }\r\n            else {\r\n                val = newVal;\r\n            }\r\n            childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock);\r\n            if (false) // removed by dead control flow\n{}\r\n            else {\r\n                dep.notify();\r\n            }\r\n        }\r\n    });\r\n    return dep;\r\n}\r\nfunction set(target, key, val) {\r\n    if (false) // removed by dead control flow\n{}\r\n    if (isReadonly(target)) {\r\n         false && 0;\r\n        return;\r\n    }\r\n    var ob = target.__ob__;\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.length = Math.max(target.length, key);\r\n        target.splice(key, 1, val);\r\n        // when mocking for SSR, array methods are not hijacked\r\n        if (ob && !ob.shallow && ob.mock) {\r\n            observe(val, false, true);\r\n        }\r\n        return val;\r\n    }\r\n    if (key in target && !(key in Object.prototype)) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n         false &&\r\n            0;\r\n        return val;\r\n    }\r\n    if (!ob) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\r\n    if (false) // removed by dead control flow\n{}\r\n    else {\r\n        ob.dep.notify();\r\n    }\r\n    return val;\r\n}\r\nfunction del(target, key) {\r\n    if (false) // removed by dead control flow\n{}\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.splice(key, 1);\r\n        return;\r\n    }\r\n    var ob = target.__ob__;\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n         false &&\r\n            0;\r\n        return;\r\n    }\r\n    if (isReadonly(target)) {\r\n         false &&\r\n            0;\r\n        return;\r\n    }\r\n    if (!hasOwn(target, key)) {\r\n        return;\r\n    }\r\n    delete target[key];\r\n    if (!ob) {\r\n        return;\r\n    }\r\n    if (false) // removed by dead control flow\n{}\r\n    else {\r\n        ob.dep.notify();\r\n    }\r\n}\r\n/**\r\n * Collect dependencies on array elements when the array is touched, since\r\n * we cannot intercept array element access like property getters.\r\n */\r\nfunction dependArray(value) {\r\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\r\n        e = value[i];\r\n        if (e && e.__ob__) {\r\n            e.__ob__.dep.depend();\r\n        }\r\n        if (isArray(e)) {\r\n            dependArray(e);\r\n        }\r\n    }\r\n}\r\n\r\nfunction reactive(target) {\r\n    makeReactive(target, false);\r\n    return target;\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    makeReactive(target, true);\r\n    def(target, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    return target;\r\n}\r\nfunction makeReactive(target, shallow) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (!isReadonly(target)) {\r\n        if (false) // removed by dead control flow\n{ var existingOb; }\r\n        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);\r\n        if (false) // removed by dead control flow\n{}\r\n    }\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\r\n    }\r\n    return !!(value && value.__ob__);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value.__v_isShallow);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value.__v_isReadonly);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    var raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    // non-extensible objects won't be observed anyway\r\n    if (Object.isExtensible(value)) {\r\n        def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction isCollectionType(value) {\r\n    var type = toRawType(value);\r\n    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nvar RefFlag = \"__v_isRef\";\r\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction ref$1(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    var ref = {};\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, shallow);\r\n    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));\r\n    return ref;\r\n}\r\nfunction triggerRef(ref) {\r\n    if (false) // removed by dead control flow\n{}\r\n    if (false) // removed by dead control flow\n{}\r\n    else {\r\n        ref.dep && ref.dep.notify();\r\n    }\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nfunction proxyRefs(objectWithRefs) {\r\n    if (isReactive(objectWithRefs)) {\r\n        return objectWithRefs;\r\n    }\r\n    var proxy = {};\r\n    var keys = Object.keys(objectWithRefs);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);\r\n    }\r\n    return proxy;\r\n}\r\nfunction proxyWithRefUnwrap(target, source, key) {\r\n    Object.defineProperty(target, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            var val = source[key];\r\n            if (isRef(val)) {\r\n                return val.value;\r\n            }\r\n            else {\r\n                var ob = val && val.__ob__;\r\n                if (ob)\r\n                    ob.dep.depend();\r\n                return val;\r\n            }\r\n        },\r\n        set: function (value) {\r\n            var oldValue = source[key];\r\n            if (isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n            }\r\n            else {\r\n                source[key] = value;\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction customRef(factory) {\r\n    var dep = new Dep();\r\n    var _a = factory(function () {\r\n        if (false) // removed by dead control flow\n{}\r\n        else {\r\n            dep.depend();\r\n        }\r\n    }, function () {\r\n        if (false) // removed by dead control flow\n{}\r\n        else {\r\n            dep.notify();\r\n        }\r\n    }), get = _a.get, set = _a.set;\r\n    var ref = {\r\n        get value() {\r\n            return get();\r\n        },\r\n        set value(newVal) {\r\n            set(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\r\nfunction toRefs(object) {\r\n    if (false) // removed by dead control flow\n{}\r\n    var ret = isArray(object) ? new Array(object.length) : {};\r\n    for (var key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    var val = object[key];\r\n    if (isRef(val)) {\r\n        return val;\r\n    }\r\n    var ref = {\r\n        get value() {\r\n            var val = object[key];\r\n            return val === undefined ? defaultValue : val;\r\n        },\r\n        set value(newVal) {\r\n            object[key] = newVal;\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\r\n\r\nvar rawToReadonlyFlag = \"__v_rawToReadonly\";\r\nvar rawToShallowReadonlyFlag = \"__v_rawToShallowReadonly\";\r\nfunction readonly(target) {\r\n    return createReadonly(target, false);\r\n}\r\nfunction createReadonly(target, shallow) {\r\n    if (!isPlainObject(target)) {\r\n        if (false) // removed by dead control flow\n{}\r\n        return target;\r\n    }\r\n    if (false) // removed by dead control flow\n{}\r\n    // already a readonly object\r\n    if (isReadonly(target)) {\r\n        return target;\r\n    }\r\n    // already has a readonly proxy\r\n    var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;\r\n    var existingProxy = target[existingFlag];\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    var proxy = Object.create(Object.getPrototypeOf(target));\r\n    def(target, existingFlag, proxy);\r\n    def(proxy, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, true);\r\n    def(proxy, \"__v_raw\" /* ReactiveFlags.RAW */, target);\r\n    if (isRef(target)) {\r\n        def(proxy, RefFlag, true);\r\n    }\r\n    if (shallow || isShallow(target)) {\r\n        def(proxy, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    }\r\n    var keys = Object.keys(target);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        defineReadonlyProperty(proxy, target, keys[i], shallow);\r\n    }\r\n    return proxy;\r\n}\r\nfunction defineReadonlyProperty(proxy, target, key, shallow) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            var val = target[key];\r\n            return shallow || !isPlainObject(val) ? val : readonly(val);\r\n        },\r\n        set: function () {\r\n             false &&\r\n                0;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReadonly(target, true);\r\n}\r\n\r\nfunction computed(getterOrOptions, debugOptions) {\r\n    var getter;\r\n    var setter;\r\n    var onlyGetter = isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter =  false\r\n            ? 0\r\n            : noop;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    var watcher = isServerRendering()\r\n        ? null\r\n        : new Watcher(currentInstance, getter, noop, { lazy: true });\r\n    if (false) // removed by dead control flow\n{}\r\n    var ref = {\r\n        // some libs rely on the presence effect for checking computed refs\r\n        // from normal refs, but the implementation doesn't matter\r\n        effect: watcher,\r\n        get value() {\r\n            if (watcher) {\r\n                if (watcher.dirty) {\r\n                    watcher.evaluate();\r\n                }\r\n                if (Dep.target) {\r\n                    if (false) // removed by dead control flow\n{}\r\n                    watcher.depend();\r\n                }\r\n                return watcher.value;\r\n            }\r\n            else {\r\n                return getter();\r\n            }\r\n        },\r\n        set value(newVal) {\r\n            setter(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, onlyGetter);\r\n    return ref;\r\n}\r\n\r\nvar mark;\r\nvar measure;\r\nif (false) // removed by dead control flow\n{ var perf_1; }\r\n\r\nvar normalizeEvent = cached(function (name) {\r\n    var passive = name.charAt(0) === '&';\r\n    name = passive ? name.slice(1) : name;\r\n    var once = name.charAt(0) === '~'; // Prefixed last, checked first\r\n    name = once ? name.slice(1) : name;\r\n    var capture = name.charAt(0) === '!';\r\n    name = capture ? name.slice(1) : name;\r\n    return {\r\n        name: name,\r\n        once: once,\r\n        capture: capture,\r\n        passive: passive\r\n    };\r\n});\r\nfunction createFnInvoker(fns, vm) {\r\n    function invoker() {\r\n        var fns = invoker.fns;\r\n        if (isArray(fns)) {\r\n            var cloned = fns.slice();\r\n            for (var i = 0; i < cloned.length; i++) {\r\n                invokeWithErrorHandling(cloned[i], null, arguments, vm, \"v-on handler\");\r\n            }\r\n        }\r\n        else {\r\n            // return handler return value for single handlers\r\n            return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\r\n        }\r\n    }\r\n    invoker.fns = fns;\r\n    return invoker;\r\n}\r\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\r\n    var name, cur, old, event;\r\n    for (name in on) {\r\n        cur = on[name];\r\n        old = oldOn[name];\r\n        event = normalizeEvent(name);\r\n        if (isUndef(cur)) {\r\n             false &&\r\n                0;\r\n        }\r\n        else if (isUndef(old)) {\r\n            if (isUndef(cur.fns)) {\r\n                cur = on[name] = createFnInvoker(cur, vm);\r\n            }\r\n            if (isTrue(event.once)) {\r\n                cur = on[name] = createOnceHandler(event.name, cur, event.capture);\r\n            }\r\n            add(event.name, cur, event.capture, event.passive, event.params);\r\n        }\r\n        else if (cur !== old) {\r\n            old.fns = cur;\r\n            on[name] = old;\r\n        }\r\n    }\r\n    for (name in oldOn) {\r\n        if (isUndef(on[name])) {\r\n            event = normalizeEvent(name);\r\n            remove(event.name, oldOn[name], event.capture);\r\n        }\r\n    }\r\n}\r\n\r\nfunction mergeVNodeHook(def, hookKey, hook) {\r\n    if (def instanceof VNode) {\r\n        def = def.data.hook || (def.data.hook = {});\r\n    }\r\n    var invoker;\r\n    var oldHook = def[hookKey];\r\n    function wrappedHook() {\r\n        hook.apply(this, arguments);\r\n        // important: remove merged hook to ensure it's called only once\r\n        // and prevent memory leak\r\n        remove$2(invoker.fns, wrappedHook);\r\n    }\r\n    if (isUndef(oldHook)) {\r\n        // no existing hook\r\n        invoker = createFnInvoker([wrappedHook]);\r\n    }\r\n    else {\r\n        /* istanbul ignore if */\r\n        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\r\n            // already a merged invoker\r\n            invoker = oldHook;\r\n            invoker.fns.push(wrappedHook);\r\n        }\r\n        else {\r\n            // existing plain hook\r\n            invoker = createFnInvoker([oldHook, wrappedHook]);\r\n        }\r\n    }\r\n    invoker.merged = true;\r\n    def[hookKey] = invoker;\r\n}\r\n\r\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\r\n    // we are only extracting raw values here.\r\n    // validation and default values are handled in the child\r\n    // component itself.\r\n    var propOptions = Ctor.options.props;\r\n    if (isUndef(propOptions)) {\r\n        return;\r\n    }\r\n    var res = {};\r\n    var attrs = data.attrs, props = data.props;\r\n    if (isDef(attrs) || isDef(props)) {\r\n        for (var key in propOptions) {\r\n            var altKey = hyphenate(key);\r\n            if (false) // removed by dead control flow\n{ var keyInLowerCase; }\r\n            checkProp(res, props, key, altKey, true) ||\r\n                checkProp(res, attrs, key, altKey, false);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction checkProp(res, hash, key, altKey, preserve) {\r\n    if (isDef(hash)) {\r\n        if (hasOwn(hash, key)) {\r\n            res[key] = hash[key];\r\n            if (!preserve) {\r\n                delete hash[key];\r\n            }\r\n            return true;\r\n        }\r\n        else if (hasOwn(hash, altKey)) {\r\n            res[key] = hash[altKey];\r\n            if (!preserve) {\r\n                delete hash[altKey];\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n// The template compiler attempts to minimize the need for normalization by\r\n// statically analyzing the template at compile time.\r\n//\r\n// For plain HTML markup, normalization can be completely skipped because the\r\n// generated render function is guaranteed to return Array<VNode>. There are\r\n// two cases where extra normalization is needed:\r\n// 1. When the children contains components - because a functional component\r\n// may return an Array instead of a single root. In this case, just a simple\r\n// normalization is needed - if any child is an Array, we flatten the whole\r\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\r\n// because functional components already normalize their own children.\r\nfunction simpleNormalizeChildren(children) {\r\n    for (var i = 0; i < children.length; i++) {\r\n        if (isArray(children[i])) {\r\n            return Array.prototype.concat.apply([], children);\r\n        }\r\n    }\r\n    return children;\r\n}\r\n// 2. When the children contains constructs that always generated nested Arrays,\r\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\r\n// with hand-written render functions / JSX. In such cases a full normalization\r\n// is needed to cater to all possible types of children values.\r\nfunction normalizeChildren(children) {\r\n    return isPrimitive(children)\r\n        ? [createTextVNode(children)]\r\n        : isArray(children)\r\n            ? normalizeArrayChildren(children)\r\n            : undefined;\r\n}\r\nfunction isTextNode(node) {\r\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\r\n}\r\nfunction normalizeArrayChildren(children, nestedIndex) {\r\n    var res = [];\r\n    var i, c, lastIndex, last;\r\n    for (i = 0; i < children.length; i++) {\r\n        c = children[i];\r\n        if (isUndef(c) || typeof c === 'boolean')\r\n            continue;\r\n        lastIndex = res.length - 1;\r\n        last = res[lastIndex];\r\n        //  nested\r\n        if (isArray(c)) {\r\n            if (c.length > 0) {\r\n                c = normalizeArrayChildren(c, \"\".concat(nestedIndex || '', \"_\").concat(i));\r\n                // merge adjacent text nodes\r\n                if (isTextNode(c[0]) && isTextNode(last)) {\r\n                    res[lastIndex] = createTextVNode(last.text + c[0].text);\r\n                    c.shift();\r\n                }\r\n                res.push.apply(res, c);\r\n            }\r\n        }\r\n        else if (isPrimitive(c)) {\r\n            if (isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                // this is necessary for SSR hydration because text nodes are\r\n                // essentially merged when rendered to HTML strings\r\n                res[lastIndex] = createTextVNode(last.text + c);\r\n            }\r\n            else if (c !== '') {\r\n                // convert primitive to vnode\r\n                res.push(createTextVNode(c));\r\n            }\r\n        }\r\n        else {\r\n            if (isTextNode(c) && isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                res[lastIndex] = createTextVNode(last.text + c.text);\r\n            }\r\n            else {\r\n                // default key for nested array children (likely generated by v-for)\r\n                if (isTrue(children._isVList) &&\r\n                    isDef(c.tag) &&\r\n                    isUndef(c.key) &&\r\n                    isDef(nestedIndex)) {\r\n                    c.key = \"__vlist\".concat(nestedIndex, \"_\").concat(i, \"__\");\r\n                }\r\n                res.push(c);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvar SIMPLE_NORMALIZE = 1;\r\nvar ALWAYS_NORMALIZE = 2;\r\n// wrapper function for providing a more flexible interface\r\n// without getting yelled at by flow\r\nfunction createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {\r\n    if (isArray(data) || isPrimitive(data)) {\r\n        normalizationType = children;\r\n        children = data;\r\n        data = undefined;\r\n    }\r\n    if (isTrue(alwaysNormalize)) {\r\n        normalizationType = ALWAYS_NORMALIZE;\r\n    }\r\n    return _createElement(context, tag, data, children, normalizationType);\r\n}\r\nfunction _createElement(context, tag, data, children, normalizationType) {\r\n    if (isDef(data) && isDef(data.__ob__)) {\r\n         false &&\r\n            0;\r\n        return createEmptyVNode();\r\n    }\r\n    // object syntax in v-bind\r\n    if (isDef(data) && isDef(data.is)) {\r\n        tag = data.is;\r\n    }\r\n    if (!tag) {\r\n        // in case of component :is set to falsy value\r\n        return createEmptyVNode();\r\n    }\r\n    // warn against non-primitive key\r\n    if (false) // removed by dead control flow\n{}\r\n    // support single function children as default scoped slot\r\n    if (isArray(children) && isFunction(children[0])) {\r\n        data = data || {};\r\n        data.scopedSlots = { default: children[0] };\r\n        children.length = 0;\r\n    }\r\n    if (normalizationType === ALWAYS_NORMALIZE) {\r\n        children = normalizeChildren(children);\r\n    }\r\n    else if (normalizationType === SIMPLE_NORMALIZE) {\r\n        children = simpleNormalizeChildren(children);\r\n    }\r\n    var vnode, ns;\r\n    if (typeof tag === 'string') {\r\n        var Ctor = void 0;\r\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\r\n        if (config.isReservedTag(tag)) {\r\n            // platform built-in elements\r\n            if (false) // removed by dead control flow\n{}\r\n            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\r\n        }\r\n        else if ((!data || !data.pre) &&\r\n            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {\r\n            // component\r\n            vnode = createComponent(Ctor, data, context, children, tag);\r\n        }\r\n        else {\r\n            // unknown or unlisted namespaced elements\r\n            // check at runtime because it may get assigned a namespace when its\r\n            // parent normalizes children\r\n            vnode = new VNode(tag, data, children, undefined, undefined, context);\r\n        }\r\n    }\r\n    else {\r\n        // direct component options / constructor\r\n        vnode = createComponent(tag, data, context, children);\r\n    }\r\n    if (isArray(vnode)) {\r\n        return vnode;\r\n    }\r\n    else if (isDef(vnode)) {\r\n        if (isDef(ns))\r\n            applyNS(vnode, ns);\r\n        if (isDef(data))\r\n            registerDeepBindings(data);\r\n        return vnode;\r\n    }\r\n    else {\r\n        return createEmptyVNode();\r\n    }\r\n}\r\nfunction applyNS(vnode, ns, force) {\r\n    vnode.ns = ns;\r\n    if (vnode.tag === 'foreignObject') {\r\n        // use default namespace inside foreignObject\r\n        ns = undefined;\r\n        force = true;\r\n    }\r\n    if (isDef(vnode.children)) {\r\n        for (var i = 0, l = vnode.children.length; i < l; i++) {\r\n            var child = vnode.children[i];\r\n            if (isDef(child.tag) &&\r\n                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\r\n                applyNS(child, ns, force);\r\n            }\r\n        }\r\n    }\r\n}\r\n// ref #5318\r\n// necessary to ensure parent re-render when deep bindings like :style and\r\n// :class are used on slot nodes\r\nfunction registerDeepBindings(data) {\r\n    if (isObject(data.style)) {\r\n        traverse(data.style);\r\n    }\r\n    if (isObject(data.class)) {\r\n        traverse(data.class);\r\n    }\r\n}\r\n\r\n/**\r\n * Runtime helper for rendering v-for lists.\r\n */\r\nfunction renderList(val, render) {\r\n    var ret = null, i, l, keys, key;\r\n    if (isArray(val) || typeof val === 'string') {\r\n        ret = new Array(val.length);\r\n        for (i = 0, l = val.length; i < l; i++) {\r\n            ret[i] = render(val[i], i);\r\n        }\r\n    }\r\n    else if (typeof val === 'number') {\r\n        ret = new Array(val);\r\n        for (i = 0; i < val; i++) {\r\n            ret[i] = render(i + 1, i);\r\n        }\r\n    }\r\n    else if (isObject(val)) {\r\n        if (hasSymbol && val[Symbol.iterator]) {\r\n            ret = [];\r\n            var iterator = val[Symbol.iterator]();\r\n            var result = iterator.next();\r\n            while (!result.done) {\r\n                ret.push(render(result.value, ret.length));\r\n                result = iterator.next();\r\n            }\r\n        }\r\n        else {\r\n            keys = Object.keys(val);\r\n            ret = new Array(keys.length);\r\n            for (i = 0, l = keys.length; i < l; i++) {\r\n                key = keys[i];\r\n                ret[i] = render(val[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    if (!isDef(ret)) {\r\n        ret = [];\r\n    }\r\n    ret._isVList = true;\r\n    return ret;\r\n}\r\n\r\n/**\r\n * Runtime helper for rendering <slot>\r\n */\r\nfunction renderSlot(name, fallbackRender, props, bindObject) {\r\n    var scopedSlotFn = this.$scopedSlots[name];\r\n    var nodes;\r\n    if (scopedSlotFn) {\r\n        // scoped slot\r\n        props = props || {};\r\n        if (bindObject) {\r\n            if (false) // removed by dead control flow\n{}\r\n            props = extend(extend({}, bindObject), props);\r\n        }\r\n        nodes =\r\n            scopedSlotFn(props) ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    else {\r\n        nodes =\r\n            this.$slots[name] ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    var target = props && props.slot;\r\n    if (target) {\r\n        return this.$createElement('template', { slot: target }, nodes);\r\n    }\r\n    else {\r\n        return nodes;\r\n    }\r\n}\r\n\r\n/**\r\n * Runtime helper for resolving filters\r\n */\r\nfunction resolveFilter(id) {\r\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\r\n}\r\n\r\nfunction isKeyNotMatch(expect, actual) {\r\n    if (isArray(expect)) {\r\n        return expect.indexOf(actual) === -1;\r\n    }\r\n    else {\r\n        return expect !== actual;\r\n    }\r\n}\r\n/**\r\n * Runtime helper for checking keyCodes from config.\r\n * exposed as Vue.prototype._k\r\n * passing in eventKeyName as last argument separately for backwards compat\r\n */\r\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\r\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\r\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\r\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\r\n    }\r\n    else if (mappedKeyCode) {\r\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\r\n    }\r\n    else if (eventKeyName) {\r\n        return hyphenate(eventKeyName) !== key;\r\n    }\r\n    return eventKeyCode === undefined;\r\n}\r\n\r\n/**\r\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\r\n */\r\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\r\n    if (value) {\r\n        if (!isObject(value)) {\r\n             false &&\r\n                0;\r\n        }\r\n        else {\r\n            if (isArray(value)) {\r\n                value = toObject(value);\r\n            }\r\n            var hash = void 0;\r\n            var _loop_1 = function (key) {\r\n                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\r\n                    hash = data;\r\n                }\r\n                else {\r\n                    var type = data.attrs && data.attrs.type;\r\n                    hash =\r\n                        asProp || config.mustUseProp(tag, type, key)\r\n                            ? data.domProps || (data.domProps = {})\r\n                            : data.attrs || (data.attrs = {});\r\n                }\r\n                var camelizedKey = camelize(key);\r\n                var hyphenatedKey = hyphenate(key);\r\n                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\r\n                    hash[key] = value[key];\r\n                    if (isSync) {\r\n                        var on = data.on || (data.on = {});\r\n                        on[\"update:\".concat(key)] = function ($event) {\r\n                            value[key] = $event;\r\n                        };\r\n                    }\r\n                }\r\n            };\r\n            for (var key in value) {\r\n                _loop_1(key);\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\r\n\r\n/**\r\n * Runtime helper for rendering static trees.\r\n */\r\nfunction renderStatic(index, isInFor) {\r\n    var cached = this._staticTrees || (this._staticTrees = []);\r\n    var tree = cached[index];\r\n    // if has already-rendered static tree and not inside v-for,\r\n    // we can reuse the same tree.\r\n    if (tree && !isInFor) {\r\n        return tree;\r\n    }\r\n    // otherwise, render a fresh tree.\r\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\r\n    );\r\n    markStatic$1(tree, \"__static__\".concat(index), false);\r\n    return tree;\r\n}\r\n/**\r\n * Runtime helper for v-once.\r\n * Effectively it means marking the node as static with a unique key.\r\n */\r\nfunction markOnce(tree, index, key) {\r\n    markStatic$1(tree, \"__once__\".concat(index).concat(key ? \"_\".concat(key) : \"\"), true);\r\n    return tree;\r\n}\r\nfunction markStatic$1(tree, key, isOnce) {\r\n    if (isArray(tree)) {\r\n        for (var i = 0; i < tree.length; i++) {\r\n            if (tree[i] && typeof tree[i] !== 'string') {\r\n                markStaticNode(tree[i], \"\".concat(key, \"_\").concat(i), isOnce);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        markStaticNode(tree, key, isOnce);\r\n    }\r\n}\r\nfunction markStaticNode(node, key, isOnce) {\r\n    node.isStatic = true;\r\n    node.key = key;\r\n    node.isOnce = isOnce;\r\n}\r\n\r\nfunction bindObjectListeners(data, value) {\r\n    if (value) {\r\n        if (!isPlainObject(value)) {\r\n             false && 0;\r\n        }\r\n        else {\r\n            var on = (data.on = data.on ? extend({}, data.on) : {});\r\n            for (var key in value) {\r\n                var existing = on[key];\r\n                var ours = value[key];\r\n                on[key] = existing ? [].concat(existing, ours) : ours;\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\r\n\r\nfunction resolveScopedSlots(fns, res, \r\n// the following are added in 2.6\r\nhasDynamicKeys, contentHashKey) {\r\n    res = res || { $stable: !hasDynamicKeys };\r\n    for (var i = 0; i < fns.length; i++) {\r\n        var slot = fns[i];\r\n        if (isArray(slot)) {\r\n            resolveScopedSlots(slot, res, hasDynamicKeys);\r\n        }\r\n        else if (slot) {\r\n            // marker for reverse proxying v-slot without scope on this.$slots\r\n            // @ts-expect-error\r\n            if (slot.proxy) {\r\n                // @ts-expect-error\r\n                slot.fn.proxy = true;\r\n            }\r\n            res[slot.key] = slot.fn;\r\n        }\r\n    }\r\n    if (contentHashKey) {\r\n        res.$key = contentHashKey;\r\n    }\r\n    return res;\r\n}\r\n\r\n// helper to process dynamic keys for dynamic arguments in v-bind and v-on.\r\nfunction bindDynamicKeys(baseObj, values) {\r\n    for (var i = 0; i < values.length; i += 2) {\r\n        var key = values[i];\r\n        if (typeof key === 'string' && key) {\r\n            baseObj[values[i]] = values[i + 1];\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n    return baseObj;\r\n}\r\n// helper to dynamically append modifier runtime markers to event names.\r\n// ensure only append when value is already string, otherwise it will be cast\r\n// to string and cause the type check to miss.\r\nfunction prependModifier(value, symbol) {\r\n    return typeof value === 'string' ? symbol + value : value;\r\n}\r\n\r\nfunction installRenderHelpers(target) {\r\n    target._o = markOnce;\r\n    target._n = toNumber;\r\n    target._s = toString;\r\n    target._l = renderList;\r\n    target._t = renderSlot;\r\n    target._q = looseEqual;\r\n    target._i = looseIndexOf;\r\n    target._m = renderStatic;\r\n    target._f = resolveFilter;\r\n    target._k = checkKeyCodes;\r\n    target._b = bindObjectProps;\r\n    target._v = createTextVNode;\r\n    target._e = createEmptyVNode;\r\n    target._u = resolveScopedSlots;\r\n    target._g = bindObjectListeners;\r\n    target._d = bindDynamicKeys;\r\n    target._p = prependModifier;\r\n}\r\n\r\n/**\r\n * Runtime helper for resolving raw children VNodes into a slot object.\r\n */\r\nfunction resolveSlots(children, context) {\r\n    if (!children || !children.length) {\r\n        return {};\r\n    }\r\n    var slots = {};\r\n    for (var i = 0, l = children.length; i < l; i++) {\r\n        var child = children[i];\r\n        var data = child.data;\r\n        // remove slot attribute if the node is resolved as a Vue slot node\r\n        if (data && data.attrs && data.attrs.slot) {\r\n            delete data.attrs.slot;\r\n        }\r\n        // named slots should only be respected if the vnode was rendered in the\r\n        // same context.\r\n        if ((child.context === context || child.fnContext === context) &&\r\n            data &&\r\n            data.slot != null) {\r\n            var name_1 = data.slot;\r\n            var slot = slots[name_1] || (slots[name_1] = []);\r\n            if (child.tag === 'template') {\r\n                slot.push.apply(slot, child.children || []);\r\n            }\r\n            else {\r\n                slot.push(child);\r\n            }\r\n        }\r\n        else {\r\n            (slots.default || (slots.default = [])).push(child);\r\n        }\r\n    }\r\n    // ignore slots that contains only whitespace\r\n    for (var name_2 in slots) {\r\n        if (slots[name_2].every(isWhitespace)) {\r\n            delete slots[name_2];\r\n        }\r\n    }\r\n    return slots;\r\n}\r\nfunction isWhitespace(node) {\r\n    return (node.isComment && !node.asyncFactory) || node.text === ' ';\r\n}\r\n\r\nfunction isAsyncPlaceholder(node) {\r\n    // @ts-expect-error not really boolean type\r\n    return node.isComment && node.asyncFactory;\r\n}\r\n\r\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\r\n    var res;\r\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\r\n    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\r\n    var key = scopedSlots && scopedSlots.$key;\r\n    if (!scopedSlots) {\r\n        res = {};\r\n    }\r\n    else if (scopedSlots._normalized) {\r\n        // fast path 1: child component re-render only, parent did not change\r\n        return scopedSlots._normalized;\r\n    }\r\n    else if (isStable &&\r\n        prevScopedSlots &&\r\n        prevScopedSlots !== emptyObject &&\r\n        key === prevScopedSlots.$key &&\r\n        !hasNormalSlots &&\r\n        !prevScopedSlots.$hasNormal) {\r\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\r\n        // only need to normalize once\r\n        return prevScopedSlots;\r\n    }\r\n    else {\r\n        res = {};\r\n        for (var key_1 in scopedSlots) {\r\n            if (scopedSlots[key_1] && key_1[0] !== '$') {\r\n                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);\r\n            }\r\n        }\r\n    }\r\n    // expose normal slots on scopedSlots\r\n    for (var key_2 in normalSlots) {\r\n        if (!(key_2 in res)) {\r\n            res[key_2] = proxyNormalSlot(normalSlots, key_2);\r\n        }\r\n    }\r\n    // avoriaz seems to mock a non-extensible $scopedSlots object\r\n    // and when that is passed down this would cause an error\r\n    if (scopedSlots && Object.isExtensible(scopedSlots)) {\r\n        scopedSlots._normalized = res;\r\n    }\r\n    def(res, '$stable', isStable);\r\n    def(res, '$key', key);\r\n    def(res, '$hasNormal', hasNormalSlots);\r\n    return res;\r\n}\r\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\r\n    var normalized = function () {\r\n        var cur = currentInstance;\r\n        setCurrentInstance(vm);\r\n        var res = arguments.length ? fn.apply(null, arguments) : fn({});\r\n        res =\r\n            res && typeof res === 'object' && !isArray(res)\r\n                ? [res] // single vnode\r\n                : normalizeChildren(res);\r\n        var vnode = res && res[0];\r\n        setCurrentInstance(cur);\r\n        return res &&\r\n            (!vnode ||\r\n                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391\r\n            ? undefined\r\n            : res;\r\n    };\r\n    // this is a slot using the new v-slot syntax without scope. although it is\r\n    // compiled as a scoped slot, render fn users would expect it to be present\r\n    // on this.$slots because the usage is semantically a normal slot.\r\n    if (fn.proxy) {\r\n        Object.defineProperty(normalSlots, key, {\r\n            get: normalized,\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n    return normalized;\r\n}\r\nfunction proxyNormalSlot(slots, key) {\r\n    return function () { return slots[key]; };\r\n}\r\n\r\nfunction initSetup(vm) {\r\n    var options = vm.$options;\r\n    var setup = options.setup;\r\n    if (setup) {\r\n        var ctx = (vm._setupContext = createSetupContext(vm));\r\n        setCurrentInstance(vm);\r\n        pushTarget();\r\n        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, \"setup\");\r\n        popTarget();\r\n        setCurrentInstance();\r\n        if (isFunction(setupResult)) {\r\n            // render function\r\n            // @ts-ignore\r\n            options.render = setupResult;\r\n        }\r\n        else if (isObject(setupResult)) {\r\n            // bindings\r\n            if (false) // removed by dead control flow\n{}\r\n            vm._setupState = setupResult;\r\n            // __sfc indicates compiled bindings from <script setup>\r\n            if (!setupResult.__sfc) {\r\n                for (var key in setupResult) {\r\n                    if (!isReserved(key)) {\r\n                        proxyWithRefUnwrap(vm, setupResult, key);\r\n                    }\r\n                    else if (false) // removed by dead control flow\n{}\r\n                }\r\n            }\r\n            else {\r\n                // exposed for compiled render fn\r\n                var proxy = (vm._setupProxy = {});\r\n                for (var key in setupResult) {\r\n                    if (key !== '__sfc') {\r\n                        proxyWithRefUnwrap(proxy, setupResult, key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n}\r\nfunction createSetupContext(vm) {\r\n    var exposeCalled = false;\r\n    return {\r\n        get attrs() {\r\n            if (!vm._attrsProxy) {\r\n                var proxy = (vm._attrsProxy = {});\r\n                def(proxy, '_v_attr_proxy', true);\r\n                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');\r\n            }\r\n            return vm._attrsProxy;\r\n        },\r\n        get listeners() {\r\n            if (!vm._listenersProxy) {\r\n                var proxy = (vm._listenersProxy = {});\r\n                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');\r\n            }\r\n            return vm._listenersProxy;\r\n        },\r\n        get slots() {\r\n            return initSlotsProxy(vm);\r\n        },\r\n        emit: bind$1(vm.$emit, vm),\r\n        expose: function (exposed) {\r\n            if (false) // removed by dead control flow\n{}\r\n            if (exposed) {\r\n                Object.keys(exposed).forEach(function (key) {\r\n                    return proxyWithRefUnwrap(vm, exposed, key);\r\n                });\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction syncSetupProxy(to, from, prev, instance, type) {\r\n    var changed = false;\r\n    for (var key in from) {\r\n        if (!(key in to)) {\r\n            changed = true;\r\n            defineProxyAttr(to, key, instance, type);\r\n        }\r\n        else if (from[key] !== prev[key]) {\r\n            changed = true;\r\n        }\r\n    }\r\n    for (var key in to) {\r\n        if (!(key in from)) {\r\n            changed = true;\r\n            delete to[key];\r\n        }\r\n    }\r\n    return changed;\r\n}\r\nfunction defineProxyAttr(proxy, key, instance, type) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            return instance[type][key];\r\n        }\r\n    });\r\n}\r\nfunction initSlotsProxy(vm) {\r\n    if (!vm._slotsProxy) {\r\n        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);\r\n    }\r\n    return vm._slotsProxy;\r\n}\r\nfunction syncSetupSlots(to, from) {\r\n    for (var key in from) {\r\n        to[key] = from[key];\r\n    }\r\n    for (var key in to) {\r\n        if (!(key in from)) {\r\n            delete to[key];\r\n        }\r\n    }\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useSlots() {\r\n    return getContext().slots;\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useAttrs() {\r\n    return getContext().attrs;\r\n}\r\n/**\r\n * Vue 2 only\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useListeners() {\r\n    return getContext().listeners;\r\n}\r\nfunction getContext() {\r\n    if (false) // removed by dead control flow\n{}\r\n    var vm = currentInstance;\r\n    return vm._setupContext || (vm._setupContext = createSetupContext(vm));\r\n}\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nfunction mergeDefaults(raw, defaults) {\r\n    var props = isArray(raw)\r\n        ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})\r\n        : raw;\r\n    for (var key in defaults) {\r\n        var opt = props[key];\r\n        if (opt) {\r\n            if (isArray(opt) || isFunction(opt)) {\r\n                props[key] = { type: opt, default: defaults[key] };\r\n            }\r\n            else {\r\n                opt.default = defaults[key];\r\n            }\r\n        }\r\n        else if (opt === null) {\r\n            props[key] = { default: defaults[key] };\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n    return props;\r\n}\r\n\r\nfunction initRender(vm) {\r\n    vm._vnode = null; // the root of the child tree\r\n    vm._staticTrees = null; // v-once cached trees\r\n    var options = vm.$options;\r\n    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree\r\n    var renderContext = parentVnode && parentVnode.context;\r\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\r\n    vm.$scopedSlots = parentVnode\r\n        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)\r\n        : emptyObject;\r\n    // bind the createElement fn to this instance\r\n    // so that we get proper render context inside it.\r\n    // args order: tag, data, children, normalizationType, alwaysNormalize\r\n    // internal version is used by render functions compiled from templates\r\n    // @ts-expect-error\r\n    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };\r\n    // normalization is always applied for the public version, used in\r\n    // user-written render functions.\r\n    // @ts-expect-error\r\n    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };\r\n    // $attrs & $listeners are exposed for easier HOC creation.\r\n    // they need to be reactive so that HOCs using them are always updated\r\n    var parentData = parentVnode && parentVnode.data;\r\n    /* istanbul ignore else */\r\n    if (false) // removed by dead control flow\n{}\r\n    else {\r\n        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, null, true);\r\n        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);\r\n    }\r\n}\r\nvar currentRenderingInstance = null;\r\nfunction renderMixin(Vue) {\r\n    // install runtime convenience helpers\r\n    installRenderHelpers(Vue.prototype);\r\n    Vue.prototype.$nextTick = function (fn) {\r\n        return nextTick(fn, this);\r\n    };\r\n    Vue.prototype._render = function () {\r\n        var vm = this;\r\n        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;\r\n        if (_parentVnode && vm._isMounted) {\r\n            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\r\n            if (vm._slotsProxy) {\r\n                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);\r\n            }\r\n        }\r\n        // set parent vnode. this allows render functions to have access\r\n        // to the data on the placeholder node.\r\n        vm.$vnode = _parentVnode;\r\n        // render self\r\n        var prevInst = currentInstance;\r\n        var prevRenderInst = currentRenderingInstance;\r\n        var vnode;\r\n        try {\r\n            setCurrentInstance(vm);\r\n            currentRenderingInstance = vm;\r\n            vnode = render.call(vm._renderProxy, vm.$createElement);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vm, \"render\");\r\n            // return error render result,\r\n            // or previous vnode to prevent render error causing blank component\r\n            /* istanbul ignore else */\r\n            if (false) // removed by dead control flow\n{}\r\n            else {\r\n                vnode = vm._vnode;\r\n            }\r\n        }\r\n        finally {\r\n            currentRenderingInstance = prevRenderInst;\r\n            setCurrentInstance(prevInst);\r\n        }\r\n        // if the returned array contains only a single node, allow it\r\n        if (isArray(vnode) && vnode.length === 1) {\r\n            vnode = vnode[0];\r\n        }\r\n        // return empty vnode in case the render function errored out\r\n        if (!(vnode instanceof VNode)) {\r\n            if (false) // removed by dead control flow\n{}\r\n            vnode = createEmptyVNode();\r\n        }\r\n        // set parent\r\n        vnode.parent = _parentVnode;\r\n        return vnode;\r\n    };\r\n}\r\n\r\nfunction ensureCtor(comp, base) {\r\n    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {\r\n        comp = comp.default;\r\n    }\r\n    return isObject(comp) ? base.extend(comp) : comp;\r\n}\r\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\r\n    var node = createEmptyVNode();\r\n    node.asyncFactory = factory;\r\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\r\n    return node;\r\n}\r\nfunction resolveAsyncComponent(factory, baseCtor) {\r\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\r\n        return factory.errorComp;\r\n    }\r\n    if (isDef(factory.resolved)) {\r\n        return factory.resolved;\r\n    }\r\n    var owner = currentRenderingInstance;\r\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\r\n        // already pending\r\n        factory.owners.push(owner);\r\n    }\r\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\r\n        return factory.loadingComp;\r\n    }\r\n    if (owner && !isDef(factory.owners)) {\r\n        var owners_1 = (factory.owners = [owner]);\r\n        var sync_1 = true;\r\n        var timerLoading_1 = null;\r\n        var timerTimeout_1 = null;\r\n        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });\r\n        var forceRender_1 = function (renderCompleted) {\r\n            for (var i = 0, l = owners_1.length; i < l; i++) {\r\n                owners_1[i].$forceUpdate();\r\n            }\r\n            if (renderCompleted) {\r\n                owners_1.length = 0;\r\n                if (timerLoading_1 !== null) {\r\n                    clearTimeout(timerLoading_1);\r\n                    timerLoading_1 = null;\r\n                }\r\n                if (timerTimeout_1 !== null) {\r\n                    clearTimeout(timerTimeout_1);\r\n                    timerTimeout_1 = null;\r\n                }\r\n            }\r\n        };\r\n        var resolve = once(function (res) {\r\n            // cache resolved\r\n            factory.resolved = ensureCtor(res, baseCtor);\r\n            // invoke callbacks only if this is not a synchronous resolve\r\n            // (async resolves are shimmed as synchronous during SSR)\r\n            if (!sync_1) {\r\n                forceRender_1(true);\r\n            }\r\n            else {\r\n                owners_1.length = 0;\r\n            }\r\n        });\r\n        var reject_1 = once(function (reason) {\r\n             false &&\r\n                0;\r\n            if (isDef(factory.errorComp)) {\r\n                factory.error = true;\r\n                forceRender_1(true);\r\n            }\r\n        });\r\n        var res_1 = factory(resolve, reject_1);\r\n        if (isObject(res_1)) {\r\n            if (isPromise(res_1)) {\r\n                // () => Promise\r\n                if (isUndef(factory.resolved)) {\r\n                    res_1.then(resolve, reject_1);\r\n                }\r\n            }\r\n            else if (isPromise(res_1.component)) {\r\n                res_1.component.then(resolve, reject_1);\r\n                if (isDef(res_1.error)) {\r\n                    factory.errorComp = ensureCtor(res_1.error, baseCtor);\r\n                }\r\n                if (isDef(res_1.loading)) {\r\n                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);\r\n                    if (res_1.delay === 0) {\r\n                        factory.loading = true;\r\n                    }\r\n                    else {\r\n                        // @ts-expect-error NodeJS timeout type\r\n                        timerLoading_1 = setTimeout(function () {\r\n                            timerLoading_1 = null;\r\n                            if (isUndef(factory.resolved) && isUndef(factory.error)) {\r\n                                factory.loading = true;\r\n                                forceRender_1(false);\r\n                            }\r\n                        }, res_1.delay || 200);\r\n                    }\r\n                }\r\n                if (isDef(res_1.timeout)) {\r\n                    // @ts-expect-error NodeJS timeout type\r\n                    timerTimeout_1 = setTimeout(function () {\r\n                        timerTimeout_1 = null;\r\n                        if (isUndef(factory.resolved)) {\r\n                            reject_1( false ? 0 : null);\r\n                        }\r\n                    }, res_1.timeout);\r\n                }\r\n            }\r\n        }\r\n        sync_1 = false;\r\n        // return in case resolved synchronously\r\n        return factory.loading ? factory.loadingComp : factory.resolved;\r\n    }\r\n}\r\n\r\nfunction getFirstComponentChild(children) {\r\n    if (isArray(children)) {\r\n        for (var i = 0; i < children.length; i++) {\r\n            var c = children[i];\r\n            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\r\n                return c;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction initEvents(vm) {\r\n    vm._events = Object.create(null);\r\n    vm._hasHookEvent = false;\r\n    // init parent attached events\r\n    var listeners = vm.$options._parentListeners;\r\n    if (listeners) {\r\n        updateComponentListeners(vm, listeners);\r\n    }\r\n}\r\nvar target$1;\r\nfunction add$1(event, fn) {\r\n    target$1.$on(event, fn);\r\n}\r\nfunction remove$1(event, fn) {\r\n    target$1.$off(event, fn);\r\n}\r\nfunction createOnceHandler$1(event, fn) {\r\n    var _target = target$1;\r\n    return function onceHandler() {\r\n        var res = fn.apply(null, arguments);\r\n        if (res !== null) {\r\n            _target.$off(event, onceHandler);\r\n        }\r\n    };\r\n}\r\nfunction updateComponentListeners(vm, listeners, oldListeners) {\r\n    target$1 = vm;\r\n    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);\r\n    target$1 = undefined;\r\n}\r\nfunction eventsMixin(Vue) {\r\n    var hookRE = /^hook:/;\r\n    Vue.prototype.$on = function (event, fn) {\r\n        var vm = this;\r\n        if (isArray(event)) {\r\n            for (var i = 0, l = event.length; i < l; i++) {\r\n                vm.$on(event[i], fn);\r\n            }\r\n        }\r\n        else {\r\n            (vm._events[event] || (vm._events[event] = [])).push(fn);\r\n            // optimize hook:event cost by using a boolean flag marked at registration\r\n            // instead of a hash lookup\r\n            if (hookRE.test(event)) {\r\n                vm._hasHookEvent = true;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$once = function (event, fn) {\r\n        var vm = this;\r\n        function on() {\r\n            vm.$off(event, on);\r\n            fn.apply(vm, arguments);\r\n        }\r\n        on.fn = fn;\r\n        vm.$on(event, on);\r\n        return vm;\r\n    };\r\n    Vue.prototype.$off = function (event, fn) {\r\n        var vm = this;\r\n        // all\r\n        if (!arguments.length) {\r\n            vm._events = Object.create(null);\r\n            return vm;\r\n        }\r\n        // array of events\r\n        if (isArray(event)) {\r\n            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {\r\n                vm.$off(event[i_1], fn);\r\n            }\r\n            return vm;\r\n        }\r\n        // specific event\r\n        var cbs = vm._events[event];\r\n        if (!cbs) {\r\n            return vm;\r\n        }\r\n        if (!fn) {\r\n            vm._events[event] = null;\r\n            return vm;\r\n        }\r\n        // specific handler\r\n        var cb;\r\n        var i = cbs.length;\r\n        while (i--) {\r\n            cb = cbs[i];\r\n            if (cb === fn || cb.fn === fn) {\r\n                cbs.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$emit = function (event) {\r\n        var vm = this;\r\n        if (false) // removed by dead control flow\n{ var lowerCaseEvent; }\r\n        var cbs = vm._events[event];\r\n        if (cbs) {\r\n            cbs = cbs.length > 1 ? toArray(cbs) : cbs;\r\n            var args = toArray(arguments, 1);\r\n            var info = \"event handler for \\\"\".concat(event, \"\\\"\");\r\n            for (var i = 0, l = cbs.length; i < l; i++) {\r\n                invokeWithErrorHandling(cbs[i], vm, args, vm, info);\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n}\r\n\r\nvar activeEffectScope;\r\nvar EffectScope = /** @class */ (function () {\r\n    function EffectScope(detached) {\r\n        if (detached === void 0) { detached = false; }\r\n        this.detached = detached;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.effects = [];\r\n        /**\r\n         * @internal\r\n         */\r\n        this.cleanups = [];\r\n        this.parent = activeEffectScope;\r\n        if (!detached && activeEffectScope) {\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    EffectScope.prototype.run = function (fn) {\r\n        if (this.active) {\r\n            var currentEffectScope = activeEffectScope;\r\n            try {\r\n                activeEffectScope = this;\r\n                return fn();\r\n            }\r\n            finally {\r\n                activeEffectScope = currentEffectScope;\r\n            }\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    };\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    EffectScope.prototype.on = function () {\r\n        activeEffectScope = this;\r\n    };\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    EffectScope.prototype.off = function () {\r\n        activeEffectScope = this.parent;\r\n    };\r\n    EffectScope.prototype.stop = function (fromParent) {\r\n        if (this.active) {\r\n            var i = void 0, l = void 0;\r\n            for (i = 0, l = this.effects.length; i < l; i++) {\r\n                this.effects[i].teardown();\r\n            }\r\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                this.cleanups[i]();\r\n            }\r\n            if (this.scopes) {\r\n                for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                    this.scopes[i].stop(true);\r\n                }\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (!this.detached && this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                var last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.parent = undefined;\r\n            this.active = false;\r\n        }\r\n    };\r\n    return EffectScope;\r\n}());\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction recordEffectScope(effect, scope) {\r\n    if (scope === void 0) { scope = activeEffectScope; }\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else if (false) // removed by dead control flow\n{}\r\n}\r\n\r\nvar activeInstance = null;\r\nvar isUpdatingChildComponent = false;\r\nfunction setActiveInstance(vm) {\r\n    var prevActiveInstance = activeInstance;\r\n    activeInstance = vm;\r\n    return function () {\r\n        activeInstance = prevActiveInstance;\r\n    };\r\n}\r\nfunction initLifecycle(vm) {\r\n    var options = vm.$options;\r\n    // locate first non-abstract parent\r\n    var parent = options.parent;\r\n    if (parent && !options.abstract) {\r\n        while (parent.$options.abstract && parent.$parent) {\r\n            parent = parent.$parent;\r\n        }\r\n        parent.$children.push(vm);\r\n    }\r\n    vm.$parent = parent;\r\n    vm.$root = parent ? parent.$root : vm;\r\n    vm.$children = [];\r\n    vm.$refs = {};\r\n    vm._provided = parent ? parent._provided : Object.create(null);\r\n    vm._watcher = null;\r\n    vm._inactive = null;\r\n    vm._directInactive = false;\r\n    vm._isMounted = false;\r\n    vm._isDestroyed = false;\r\n    vm._isBeingDestroyed = false;\r\n}\r\nfunction lifecycleMixin(Vue) {\r\n    Vue.prototype._update = function (vnode, hydrating) {\r\n        var vm = this;\r\n        var prevEl = vm.$el;\r\n        var prevVnode = vm._vnode;\r\n        var restoreActiveInstance = setActiveInstance(vm);\r\n        vm._vnode = vnode;\r\n        // Vue.prototype.__patch__ is injected in entry points\r\n        // based on the rendering backend used.\r\n        if (!prevVnode) {\r\n            // initial render\r\n            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\r\n        }\r\n        else {\r\n            // updates\r\n            vm.$el = vm.__patch__(prevVnode, vnode);\r\n        }\r\n        restoreActiveInstance();\r\n        // update __vue__ reference\r\n        if (prevEl) {\r\n            prevEl.__vue__ = null;\r\n        }\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = vm;\r\n        }\r\n        // if parent is an HOC, update its $el as well\r\n        var wrapper = vm;\r\n        while (wrapper &&\r\n            wrapper.$vnode &&\r\n            wrapper.$parent &&\r\n            wrapper.$vnode === wrapper.$parent._vnode) {\r\n            wrapper.$parent.$el = wrapper.$el;\r\n            wrapper = wrapper.$parent;\r\n        }\r\n        // updated hook is called by the scheduler to ensure that children are\r\n        // updated in a parent's updated hook.\r\n    };\r\n    Vue.prototype.$forceUpdate = function () {\r\n        var vm = this;\r\n        if (vm._watcher) {\r\n            vm._watcher.update();\r\n        }\r\n    };\r\n    Vue.prototype.$destroy = function () {\r\n        var vm = this;\r\n        if (vm._isBeingDestroyed) {\r\n            return;\r\n        }\r\n        callHook$1(vm, 'beforeDestroy');\r\n        vm._isBeingDestroyed = true;\r\n        // remove self from parent\r\n        var parent = vm.$parent;\r\n        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\r\n            remove$2(parent.$children, vm);\r\n        }\r\n        // teardown scope. this includes both the render watcher and other\r\n        // watchers created\r\n        vm._scope.stop();\r\n        // remove reference from data ob\r\n        // frozen object may not have observer.\r\n        if (vm._data.__ob__) {\r\n            vm._data.__ob__.vmCount--;\r\n        }\r\n        // call the last hook...\r\n        vm._isDestroyed = true;\r\n        // invoke destroy hooks on current rendered tree\r\n        vm.__patch__(vm._vnode, null);\r\n        // fire destroyed hook\r\n        callHook$1(vm, 'destroyed');\r\n        // turn off all instance listeners.\r\n        vm.$off();\r\n        // remove __vue__ reference\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = null;\r\n        }\r\n        // release circular reference (#6759)\r\n        if (vm.$vnode) {\r\n            vm.$vnode.parent = null;\r\n        }\r\n    };\r\n}\r\nfunction mountComponent(vm, el, hydrating) {\r\n    vm.$el = el;\r\n    if (!vm.$options.render) {\r\n        // @ts-expect-error invalid type\r\n        vm.$options.render = createEmptyVNode;\r\n        if (false) // removed by dead control flow\n{}\r\n    }\r\n    callHook$1(vm, 'beforeMount');\r\n    var updateComponent;\r\n    /* istanbul ignore if */\r\n    if (false) // removed by dead control flow\n{}\r\n    else {\r\n        updateComponent = function () {\r\n            vm._update(vm._render(), hydrating);\r\n        };\r\n    }\r\n    var watcherOptions = {\r\n        before: function () {\r\n            if (vm._isMounted && !vm._isDestroyed) {\r\n                callHook$1(vm, 'beforeUpdate');\r\n            }\r\n        }\r\n    };\r\n    if (false) // removed by dead control flow\n{}\r\n    // we set this to vm._watcher inside the watcher's constructor\r\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\r\n    // component's mounted hook), which relies on vm._watcher being already defined\r\n    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);\r\n    hydrating = false;\r\n    // flush buffer for flush: \"pre\" watchers queued in setup()\r\n    var preWatchers = vm._preWatchers;\r\n    if (preWatchers) {\r\n        for (var i = 0; i < preWatchers.length; i++) {\r\n            preWatchers[i].run();\r\n        }\r\n    }\r\n    // manually mounted instance, call mounted on self\r\n    // mounted is called for render-created child components in its inserted hook\r\n    if (vm.$vnode == null) {\r\n        vm._isMounted = true;\r\n        callHook$1(vm, 'mounted');\r\n    }\r\n    return vm;\r\n}\r\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\r\n    if (false) // removed by dead control flow\n{}\r\n    // determine whether component has slot children\r\n    // we need to do this before overwriting $options._renderChildren.\r\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\r\n    // dynamic slot names). Static scoped slots compiled from template has the\r\n    // \"$stable\" marker.\r\n    var newScopedSlots = parentVnode.data.scopedSlots;\r\n    var oldScopedSlots = vm.$scopedSlots;\r\n    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||\r\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\r\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\r\n        (!newScopedSlots && vm.$scopedSlots.$key));\r\n    // Any static slot children from the parent may have changed during parent's\r\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\r\n    // update is necessary to ensure correctness.\r\n    var needsForceUpdate = !!(renderChildren || // has new static slots\r\n        vm.$options._renderChildren || // has old static slots\r\n        hasDynamicScopedSlot);\r\n    var prevVNode = vm.$vnode;\r\n    vm.$options._parentVnode = parentVnode;\r\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\r\n    if (vm._vnode) {\r\n        // update child tree's parent\r\n        vm._vnode.parent = parentVnode;\r\n    }\r\n    vm.$options._renderChildren = renderChildren;\r\n    // update $attrs and $listeners hash\r\n    // these are also reactive so they may trigger child update if the child\r\n    // used them during render\r\n    var attrs = parentVnode.data.attrs || emptyObject;\r\n    if (vm._attrsProxy) {\r\n        // force update if attrs are accessed and has changed since it may be\r\n        // passed to a child component.\r\n        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {\r\n            needsForceUpdate = true;\r\n        }\r\n    }\r\n    vm.$attrs = attrs;\r\n    // update listeners\r\n    listeners = listeners || emptyObject;\r\n    var prevListeners = vm.$options._parentListeners;\r\n    if (vm._listenersProxy) {\r\n        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\r\n    }\r\n    vm.$listeners = vm.$options._parentListeners = listeners;\r\n    updateComponentListeners(vm, listeners, prevListeners);\r\n    // update props\r\n    if (propsData && vm.$options.props) {\r\n        toggleObserving(false);\r\n        var props = vm._props;\r\n        var propKeys = vm.$options._propKeys || [];\r\n        for (var i = 0; i < propKeys.length; i++) {\r\n            var key = propKeys[i];\r\n            var propOptions = vm.$options.props; // wtf flow?\r\n            props[key] = validateProp(key, propOptions, propsData, vm);\r\n        }\r\n        toggleObserving(true);\r\n        // keep a copy of raw propsData\r\n        vm.$options.propsData = propsData;\r\n    }\r\n    // resolve slots + force update if has children\r\n    if (needsForceUpdate) {\r\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\r\n        vm.$forceUpdate();\r\n    }\r\n    if (false) // removed by dead control flow\n{}\r\n}\r\nfunction isInInactiveTree(vm) {\r\n    while (vm && (vm = vm.$parent)) {\r\n        if (vm._inactive)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction activateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = false;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    else if (vm._directInactive) {\r\n        return;\r\n    }\r\n    if (vm._inactive || vm._inactive === null) {\r\n        vm._inactive = false;\r\n        for (var i = 0; i < vm.$children.length; i++) {\r\n            activateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'activated');\r\n    }\r\n}\r\nfunction deactivateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = true;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    if (!vm._inactive) {\r\n        vm._inactive = true;\r\n        for (var i = 0; i < vm.$children.length; i++) {\r\n            deactivateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'deactivated');\r\n    }\r\n}\r\nfunction callHook$1(vm, hook, args, setContext) {\r\n    if (setContext === void 0) { setContext = true; }\r\n    // #7573 disable dep collection when invoking lifecycle hooks\r\n    pushTarget();\r\n    var prevInst = currentInstance;\r\n    var prevScope = getCurrentScope();\r\n    setContext && setCurrentInstance(vm);\r\n    var handlers = vm.$options[hook];\r\n    var info = \"\".concat(hook, \" hook\");\r\n    if (handlers) {\r\n        for (var i = 0, j = handlers.length; i < j; i++) {\r\n            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\r\n        }\r\n    }\r\n    if (vm._hasHookEvent) {\r\n        vm.$emit('hook:' + hook);\r\n    }\r\n    if (setContext) {\r\n        setCurrentInstance(prevInst);\r\n        prevScope && prevScope.on();\r\n    }\r\n    popTarget();\r\n}\r\n\r\nvar MAX_UPDATE_COUNT = 100;\r\nvar queue = [];\r\nvar activatedChildren = [];\r\nvar has = {};\r\nvar circular = {};\r\nvar waiting = false;\r\nvar flushing = false;\r\nvar index$1 = 0;\r\n/**\r\n * Reset the scheduler's state.\r\n */\r\nfunction resetSchedulerState() {\r\n    index$1 = queue.length = activatedChildren.length = 0;\r\n    has = {};\r\n    if (false) // removed by dead control flow\n{}\r\n    waiting = flushing = false;\r\n}\r\n// Async edge case #6566 requires saving the timestamp when event listeners are\r\n// attached. However, calling performance.now() has a perf overhead especially\r\n// if the page has thousands of event listeners. Instead, we take a timestamp\r\n// every time the scheduler flushes and use that for all event listeners\r\n// attached during that flush.\r\nvar currentFlushTimestamp = 0;\r\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nvar getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\n// All IE versions use low-res event timestamps, and have problematic clock\r\n// implementations (#9632)\r\nif (inBrowser && !isIE) {\r\n    var performance_1 = window.performance;\r\n    if (performance_1 &&\r\n        typeof performance_1.now === 'function' &&\r\n        getNow() > document.createEvent('Event').timeStamp) {\r\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\r\n        // smaller than it, it means the event is using a hi-res timestamp,\r\n        // and we need to use the hi-res version for event listener timestamps as\r\n        // well.\r\n        getNow = function () { return performance_1.now(); };\r\n    }\r\n}\r\nvar sortCompareFn = function (a, b) {\r\n    if (a.post) {\r\n        if (!b.post)\r\n            return 1;\r\n    }\r\n    else if (b.post) {\r\n        return -1;\r\n    }\r\n    return a.id - b.id;\r\n};\r\n/**\r\n * Flush both queues and run the watchers.\r\n */\r\nfunction flushSchedulerQueue() {\r\n    currentFlushTimestamp = getNow();\r\n    flushing = true;\r\n    var watcher, id;\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child)\r\n    // 2. A component's user watchers are run before its render watcher (because\r\n    //    user watchers are created before the render watcher)\r\n    // 3. If a component is destroyed during a parent component's watcher run,\r\n    //    its watchers can be skipped.\r\n    queue.sort(sortCompareFn);\r\n    // do not cache length because more watchers might be pushed\r\n    // as we run existing watchers\r\n    for (index$1 = 0; index$1 < queue.length; index$1++) {\r\n        watcher = queue[index$1];\r\n        if (watcher.before) {\r\n            watcher.before();\r\n        }\r\n        id = watcher.id;\r\n        has[id] = null;\r\n        watcher.run();\r\n        // in dev build, check and stop circular updates.\r\n        if (false) // removed by dead control flow\n{}\r\n    }\r\n    // keep copies of post queues before resetting state\r\n    var activatedQueue = activatedChildren.slice();\r\n    var updatedQueue = queue.slice();\r\n    resetSchedulerState();\r\n    // call component updated and activated hooks\r\n    callActivatedHooks(activatedQueue);\r\n    callUpdatedHooks(updatedQueue);\r\n    cleanupDeps();\r\n    // devtool hook\r\n    /* istanbul ignore if */\r\n    if (devtools && config.devtools) {\r\n        devtools.emit('flush');\r\n    }\r\n}\r\nfunction callUpdatedHooks(queue) {\r\n    var i = queue.length;\r\n    while (i--) {\r\n        var watcher = queue[i];\r\n        var vm = watcher.vm;\r\n        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\r\n            callHook$1(vm, 'updated');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Queue a kept-alive component that was activated during patch.\r\n * The queue will be processed after the entire tree has been patched.\r\n */\r\nfunction queueActivatedComponent(vm) {\r\n    // setting _inactive to false here so that a render function can\r\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\r\n    vm._inactive = false;\r\n    activatedChildren.push(vm);\r\n}\r\nfunction callActivatedHooks(queue) {\r\n    for (var i = 0; i < queue.length; i++) {\r\n        queue[i]._inactive = true;\r\n        activateChildComponent(queue[i], true /* true */);\r\n    }\r\n}\r\n/**\r\n * Push a watcher into the watcher queue.\r\n * Jobs with duplicate IDs will be skipped unless it's\r\n * pushed when the queue is being flushed.\r\n */\r\nfunction queueWatcher(watcher) {\r\n    var id = watcher.id;\r\n    if (has[id] != null) {\r\n        return;\r\n    }\r\n    if (watcher === Dep.target && watcher.noRecurse) {\r\n        return;\r\n    }\r\n    has[id] = true;\r\n    if (!flushing) {\r\n        queue.push(watcher);\r\n    }\r\n    else {\r\n        // if already flushing, splice the watcher based on its id\r\n        // if already past its id, it will be run next immediately.\r\n        var i = queue.length - 1;\r\n        while (i > index$1 && queue[i].id > watcher.id) {\r\n            i--;\r\n        }\r\n        queue.splice(i + 1, 0, watcher);\r\n    }\r\n    // queue the flush\r\n    if (!waiting) {\r\n        waiting = true;\r\n        if (false) // removed by dead control flow\n{}\r\n        nextTick(flushSchedulerQueue);\r\n    }\r\n}\r\n\r\nvar WATCHER = \"watcher\";\r\nvar WATCHER_CB = \"\".concat(WATCHER, \" callback\");\r\nvar WATCHER_GETTER = \"\".concat(WATCHER, \" getter\");\r\nvar WATCHER_CLEANUP = \"\".concat(WATCHER, \" cleanup\");\r\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\nfunction watchPostEffect(effect, options) {\r\n    return doWatch(effect, null, ( false\r\n        ? 0 : { flush: 'post' }));\r\n}\r\nfunction watchSyncEffect(effect, options) {\r\n    return doWatch(effect, null, ( false\r\n        ? 0 : { flush: 'sync' }));\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nvar INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if (false) // removed by dead control flow\n{}\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, _a) {\r\n    var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;\r\n    if (false) // removed by dead control flow\n{}\r\n    var warnInvalidSource = function (s) {\r\n        warn$2(\"Invalid watch source: \".concat(s, \". A watch source can only be a getter/effect \") +\r\n            \"function, a ref, a reactive object, or an array of these types.\");\r\n    };\r\n    var instance = currentInstance;\r\n    var call = function (fn, type, args) {\r\n        if (args === void 0) { args = null; }\r\n        var res = invokeWithErrorHandling(fn, null, args, instance, type);\r\n        if (deep && res && res.__ob__)\r\n            res.__ob__.dep.depend();\r\n        return res;\r\n    };\r\n    var getter;\r\n    var forceTrigger = false;\r\n    var isMultiSource = false;\r\n    if (isRef(source)) {\r\n        getter = function () { return source.value; };\r\n        forceTrigger = isShallow(source);\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = function () {\r\n            source.__ob__.dep.depend();\r\n            return source;\r\n        };\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        isMultiSource = true;\r\n        forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });\r\n        getter = function () {\r\n            return source.map(function (s) {\r\n                if (isRef(s)) {\r\n                    return s.value;\r\n                }\r\n                else if (isReactive(s)) {\r\n                    s.__ob__.dep.depend();\r\n                    return traverse(s);\r\n                }\r\n                else if (isFunction(s)) {\r\n                    return call(s, WATCHER_GETTER);\r\n                }\r\n                else {\r\n                     false && 0;\r\n                }\r\n            });\r\n        };\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = function () { return call(source, WATCHER_GETTER); };\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = function () {\r\n                if (instance && instance._isDestroyed) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return call(source, WATCHER, [onCleanup]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = noop;\r\n         false && 0;\r\n    }\r\n    if (cb && deep) {\r\n        var baseGetter_1 = getter;\r\n        getter = function () { return traverse(baseGetter_1()); };\r\n    }\r\n    var cleanup;\r\n    var onCleanup = function (fn) {\r\n        cleanup = watcher.onStop = function () {\r\n            call(fn, WATCHER_CLEANUP);\r\n        };\r\n    };\r\n    // in SSR there is no need to setup an actual effect, and it should be noop\r\n    // unless it's eager\r\n    if (isServerRendering()) {\r\n        // we will also not call the invalidate callback (+ runner is not set up)\r\n        onCleanup = noop;\r\n        if (!cb) {\r\n            getter();\r\n        }\r\n        else if (immediate) {\r\n            call(cb, WATCHER_CB, [\r\n                getter(),\r\n                isMultiSource ? [] : undefined,\r\n                onCleanup\r\n            ]);\r\n        }\r\n        return noop;\r\n    }\r\n    var watcher = new Watcher(currentInstance, getter, noop, {\r\n        lazy: true\r\n    });\r\n    watcher.noRecurse = !cb;\r\n    var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n    // overwrite default run\r\n    watcher.run = function () {\r\n        if (!watcher.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            var newValue = watcher.get();\r\n            if (deep ||\r\n                forceTrigger ||\r\n                (isMultiSource\r\n                    ? newValue.some(function (v, i) {\r\n                        return hasChanged(v, oldValue[i]);\r\n                    })\r\n                    : hasChanged(newValue, oldValue))) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                call(cb, WATCHER_CB, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            watcher.get();\r\n        }\r\n    };\r\n    if (flush === 'sync') {\r\n        watcher.update = watcher.run;\r\n    }\r\n    else if (flush === 'post') {\r\n        watcher.post = true;\r\n        watcher.update = function () { return queueWatcher(watcher); };\r\n    }\r\n    else {\r\n        // pre\r\n        watcher.update = function () {\r\n            if (instance && instance === currentInstance && !instance._isMounted) {\r\n                // pre-watcher triggered before\r\n                var buffer = instance._preWatchers || (instance._preWatchers = []);\r\n                if (buffer.indexOf(watcher) < 0)\r\n                    buffer.push(watcher);\r\n            }\r\n            else {\r\n                queueWatcher(watcher);\r\n            }\r\n        };\r\n    }\r\n    if (false) // removed by dead control flow\n{}\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            watcher.run();\r\n        }\r\n        else {\r\n            oldValue = watcher.get();\r\n        }\r\n    }\r\n    else if (flush === 'post' && instance) {\r\n        instance.$once('hook:mounted', function () { return watcher.get(); });\r\n    }\r\n    else {\r\n        watcher.get();\r\n    }\r\n    return function () {\r\n        watcher.teardown();\r\n    };\r\n}\r\n\r\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if (false) // removed by dead control flow\n{}\r\n    }\r\n    else {\r\n        // TS doesn't allow symbol as index type\r\n        resolveProvided(currentInstance)[key] = value;\r\n    }\r\n}\r\nfunction resolveProvided(vm) {\r\n    // by default an instance inherits its parent's provides object\r\n    // but when it needs to provide values of its own, it creates its\r\n    // own provides object using parent provides object as prototype.\r\n    // this way in `inject` we can simply look up injections from direct\r\n    // parent and let the prototype chain do the work.\r\n    var existing = vm._provided;\r\n    var parentProvides = vm.$parent && vm.$parent._provided;\r\n    if (parentProvides === existing) {\r\n        return (vm._provided = Object.create(parentProvides));\r\n    }\r\n    else {\r\n        return existing;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory) {\r\n    if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    var instance = currentInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the instance is at root\r\n        var provides = instance.$parent && instance.$parent._provided;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && isFunction(defaultValue)\r\n                ? defaultValue.call(instance)\r\n                : defaultValue;\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n    else if (false) // removed by dead control flow\n{}\r\n}\r\n\r\n/**\r\n * @internal this function needs manual public type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction h(type, props, children) {\r\n    if (!currentInstance) {\r\n         false &&\r\n            0;\r\n    }\r\n    return createElement$1(currentInstance, type, props, children, 2, true);\r\n}\r\n\r\nfunction handleError(err, vm, info) {\r\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\r\n    // See: https://github.com/vuejs/vuex/issues/1505\r\n    pushTarget();\r\n    try {\r\n        if (vm) {\r\n            var cur = vm;\r\n            while ((cur = cur.$parent)) {\r\n                var hooks = cur.$options.errorCaptured;\r\n                if (hooks) {\r\n                    for (var i = 0; i < hooks.length; i++) {\r\n                        try {\r\n                            var capture = hooks[i].call(cur, err, vm, info) === false;\r\n                            if (capture)\r\n                                return;\r\n                        }\r\n                        catch (e) {\r\n                            globalHandleError(e, cur, 'errorCaptured hook');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        globalHandleError(err, vm, info);\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\r\n    var res;\r\n    try {\r\n        res = args ? handler.apply(context, args) : handler.call(context);\r\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\r\n            res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\r\n            res._handled = true;\r\n        }\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, info);\r\n    }\r\n    return res;\r\n}\r\nfunction globalHandleError(err, vm, info) {\r\n    if (config.errorHandler) {\r\n        try {\r\n            return config.errorHandler.call(null, err, vm, info);\r\n        }\r\n        catch (e) {\r\n            // if the user intentionally throws the original error in the handler,\r\n            // do not log it twice\r\n            if (e !== err) {\r\n                logError(e, null, 'config.errorHandler');\r\n            }\r\n        }\r\n    }\r\n    logError(err, vm, info);\r\n}\r\nfunction logError(err, vm, info) {\r\n    if (false) // removed by dead control flow\n{}\r\n    /* istanbul ignore else */\r\n    if (inBrowser && typeof console !== 'undefined') {\r\n        console.error(err);\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}\r\n\r\n/* globals MutationObserver */\r\nvar isUsingMicroTask = false;\r\nvar callbacks = [];\r\nvar pending = false;\r\nfunction flushCallbacks() {\r\n    pending = false;\r\n    var copies = callbacks.slice(0);\r\n    callbacks.length = 0;\r\n    for (var i = 0; i < copies.length; i++) {\r\n        copies[i]();\r\n    }\r\n}\r\n// Here we have async deferring wrappers using microtasks.\r\n// In 2.5 we used (macro) tasks (in combination with microtasks).\r\n// However, it has subtle problems when state is changed right before repaint\r\n// (e.g. #6813, out-in transitions).\r\n// Also, using (macro) tasks in event handler would cause some weird behaviors\r\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\r\n// So we now use microtasks everywhere, again.\r\n// A major drawback of this tradeoff is that there are some scenarios\r\n// where microtasks have too high a priority and fire in between supposedly\r\n// sequential events (e.g. #4521, #6690, which have workarounds)\r\n// or even between bubbling of the same event (#6566).\r\nvar timerFunc;\r\n// The nextTick behavior leverages the microtask queue, which can be accessed\r\n// via either native Promise.then or MutationObserver.\r\n// MutationObserver has wider support, however it is seriously bugged in\r\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\r\n// completely stops working after triggering a few times... so, if native\r\n// Promise is available, we will use it:\r\n/* istanbul ignore next, $flow-disable-line */\r\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\r\n    var p_1 = Promise.resolve();\r\n    timerFunc = function () {\r\n        p_1.then(flushCallbacks);\r\n        // In problematic UIWebViews, Promise.then doesn't completely break, but\r\n        // it can get stuck in a weird state where callbacks are pushed into the\r\n        // microtask queue but the queue isn't being flushed, until the browser\r\n        // needs to do some other work, e.g. handle a timer. Therefore we can\r\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\r\n        if (isIOS)\r\n            setTimeout(noop);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (!isIE &&\r\n    typeof MutationObserver !== 'undefined' &&\r\n    (isNative(MutationObserver) ||\r\n        // PhantomJS and iOS 7.x\r\n        MutationObserver.toString() === '[object MutationObserverConstructor]')) {\r\n    // Use MutationObserver where native Promise is not available,\r\n    // e.g. PhantomJS, iOS7, Android 4.4\r\n    // (#6466 MutationObserver is unreliable in IE11)\r\n    var counter_1 = 1;\r\n    var observer = new MutationObserver(flushCallbacks);\r\n    var textNode_1 = document.createTextNode(String(counter_1));\r\n    observer.observe(textNode_1, {\r\n        characterData: true\r\n    });\r\n    timerFunc = function () {\r\n        counter_1 = (counter_1 + 1) % 2;\r\n        textNode_1.data = String(counter_1);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\r\n    // Fallback to setImmediate.\r\n    // Technically it leverages the (macro) task queue,\r\n    // but it is still a better choice than setTimeout.\r\n    timerFunc = function () {\r\n        setImmediate(flushCallbacks);\r\n    };\r\n}\r\nelse {\r\n    // Fallback to setTimeout.\r\n    timerFunc = function () {\r\n        setTimeout(flushCallbacks, 0);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction nextTick(cb, ctx) {\r\n    var _resolve;\r\n    callbacks.push(function () {\r\n        if (cb) {\r\n            try {\r\n                cb.call(ctx);\r\n            }\r\n            catch (e) {\r\n                handleError(e, ctx, 'nextTick');\r\n            }\r\n        }\r\n        else if (_resolve) {\r\n            _resolve(ctx);\r\n        }\r\n    });\r\n    if (!pending) {\r\n        pending = true;\r\n        timerFunc();\r\n    }\r\n    // $flow-disable-line\r\n    if (!cb && typeof Promise !== 'undefined') {\r\n        return new Promise(function (resolve) {\r\n            _resolve = resolve;\r\n        });\r\n    }\r\n}\r\n\r\nfunction useCssModule(name) {\r\n    if (name === void 0) { name = '$style'; }\r\n    /* istanbul ignore else */\r\n    {\r\n        if (!currentInstance) {\r\n             false && 0;\r\n            return emptyObject;\r\n        }\r\n        var mod = currentInstance[name];\r\n        if (!mod) {\r\n             false &&\r\n                0;\r\n            return emptyObject;\r\n        }\r\n        return mod;\r\n    }\r\n}\r\n\r\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    if (!inBrowser && !false)\r\n        return;\r\n    var instance = currentInstance;\r\n    if (!instance) {\r\n         false &&\r\n            0;\r\n        return;\r\n    }\r\n    watchPostEffect(function () {\r\n        var el = instance.$el;\r\n        var vars = getter(instance, instance._setupProxy);\r\n        if (el && el.nodeType === 1) {\r\n            var style = el.style;\r\n            for (var key in vars) {\r\n                style.setProperty(\"--\".concat(key), vars[key]);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * v3-compatible async component API.\r\n * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts\r\n * because it relies on existing manual types\r\n */\r\nfunction defineAsyncComponent(source) {\r\n    if (isFunction(source)) {\r\n        source = { loader: source };\r\n    }\r\n    var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out\r\n    _b = source.suspensible, // undefined = never times out\r\n    suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true\r\n    userOnError = source.onError;\r\n    if (false) // removed by dead control flow\n{}\r\n    var pendingRequest = null;\r\n    var retries = 0;\r\n    var retry = function () {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    var load = function () {\r\n        var thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest =\r\n                loader()\r\n                    .catch(function (err) {\r\n                    err = err instanceof Error ? err : new Error(String(err));\r\n                    if (userOnError) {\r\n                        return new Promise(function (resolve, reject) {\r\n                            var userRetry = function () { return resolve(retry()); };\r\n                            var userFail = function () { return reject(err); };\r\n                            userOnError(err, userRetry, userFail, retries + 1);\r\n                        });\r\n                    }\r\n                    else {\r\n                        throw err;\r\n                    }\r\n                })\r\n                    .then(function (comp) {\r\n                    if (thisRequest !== pendingRequest && pendingRequest) {\r\n                        return pendingRequest;\r\n                    }\r\n                    if (false) // removed by dead control flow\n{}\r\n                    // interop module default\r\n                    if (comp &&\r\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                        comp = comp.default;\r\n                    }\r\n                    if (false) // removed by dead control flow\n{}\r\n                    return comp;\r\n                })));\r\n    };\r\n    return function () {\r\n        var component = load();\r\n        return {\r\n            component: component,\r\n            delay: delay,\r\n            timeout: timeout,\r\n            error: errorComponent,\r\n            loading: loadingComponent\r\n        };\r\n    };\r\n}\r\n\r\nfunction createLifeCycle(hookName) {\r\n    return function (fn, target) {\r\n        if (target === void 0) { target = currentInstance; }\r\n        if (!target) {\r\n             false &&\r\n                0;\r\n            return;\r\n        }\r\n        return injectHook(target, hookName, fn);\r\n    };\r\n}\r\nfunction formatName(name) {\r\n    if (name === 'beforeDestroy') {\r\n        name = 'beforeUnmount';\r\n    }\r\n    else if (name === 'destroyed') {\r\n        name = 'unmounted';\r\n    }\r\n    return \"on\".concat(name[0].toUpperCase() + name.slice(1));\r\n}\r\nfunction injectHook(instance, hookName, fn) {\r\n    var options = instance.$options;\r\n    options[hookName] = mergeLifecycleHook(options[hookName], fn);\r\n}\r\nvar onBeforeMount = createLifeCycle('beforeMount');\r\nvar onMounted = createLifeCycle('mounted');\r\nvar onBeforeUpdate = createLifeCycle('beforeUpdate');\r\nvar onUpdated = createLifeCycle('updated');\r\nvar onBeforeUnmount = createLifeCycle('beforeDestroy');\r\nvar onUnmounted = createLifeCycle('destroyed');\r\nvar onActivated = createLifeCycle('activated');\r\nvar onDeactivated = createLifeCycle('deactivated');\r\nvar onServerPrefetch = createLifeCycle('serverPrefetch');\r\nvar onRenderTracked = createLifeCycle('renderTracked');\r\nvar onRenderTriggered = createLifeCycle('renderTriggered');\r\nvar injectErrorCapturedHook = createLifeCycle('errorCaptured');\r\nfunction onErrorCaptured(hook, target) {\r\n    if (target === void 0) { target = currentInstance; }\r\n    injectErrorCapturedHook(hook, target);\r\n}\r\n\r\n/**\r\n * Note: also update dist/vue.runtime.mjs when adding new exports to this file.\r\n */\r\nvar version = '2.7.16';\r\n/**\r\n * @internal type is manually declared in <root>/types/v3-define-component.d.ts\r\n */\r\nfunction defineComponent(options) {\r\n    return options;\r\n}\r\n\r\nvar seenObjects = new _Set();\r\n/**\r\n * Recursively traverse an object to evoke all converted\r\n * getters, so that every nested property inside the object\r\n * is collected as a \"deep\" dependency.\r\n */\r\nfunction traverse(val) {\r\n    _traverse(val, seenObjects);\r\n    seenObjects.clear();\r\n    return val;\r\n}\r\nfunction _traverse(val, seen) {\r\n    var i, keys;\r\n    var isA = isArray(val);\r\n    if ((!isA && !isObject(val)) ||\r\n        val.__v_skip /* ReactiveFlags.SKIP */ ||\r\n        Object.isFrozen(val) ||\r\n        val instanceof VNode) {\r\n        return;\r\n    }\r\n    if (val.__ob__) {\r\n        var depId = val.__ob__.dep.id;\r\n        if (seen.has(depId)) {\r\n            return;\r\n        }\r\n        seen.add(depId);\r\n    }\r\n    if (isA) {\r\n        i = val.length;\r\n        while (i--)\r\n            _traverse(val[i], seen);\r\n    }\r\n    else if (isRef(val)) {\r\n        _traverse(val.value, seen);\r\n    }\r\n    else {\r\n        keys = Object.keys(val);\r\n        i = keys.length;\r\n        while (i--)\r\n            _traverse(val[keys[i]], seen);\r\n    }\r\n}\r\n\r\nvar uid$1 = 0;\r\n/**\r\n * A watcher parses an expression, collects dependencies,\r\n * and fires callback when the expression value changes.\r\n * This is used for both the $watch() api and directives.\r\n * @internal\r\n */\r\nvar Watcher = /** @class */ (function () {\r\n    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\r\n        recordEffectScope(this, \r\n        // if the active effect scope is manually created (not a component scope),\r\n        // prioritize it\r\n        activeEffectScope && !activeEffectScope._vm\r\n            ? activeEffectScope\r\n            : vm\r\n                ? vm._scope\r\n                : undefined);\r\n        if ((this.vm = vm) && isRenderWatcher) {\r\n            vm._watcher = this;\r\n        }\r\n        // options\r\n        if (options) {\r\n            this.deep = !!options.deep;\r\n            this.user = !!options.user;\r\n            this.lazy = !!options.lazy;\r\n            this.sync = !!options.sync;\r\n            this.before = options.before;\r\n            if (false) // removed by dead control flow\n{}\r\n        }\r\n        else {\r\n            this.deep = this.user = this.lazy = this.sync = false;\r\n        }\r\n        this.cb = cb;\r\n        this.id = ++uid$1; // uid for batching\r\n        this.active = true;\r\n        this.post = false;\r\n        this.dirty = this.lazy; // for lazy watchers\r\n        this.deps = [];\r\n        this.newDeps = [];\r\n        this.depIds = new _Set();\r\n        this.newDepIds = new _Set();\r\n        this.expression =  false ? 0 : '';\r\n        // parse expression for getter\r\n        if (isFunction(expOrFn)) {\r\n            this.getter = expOrFn;\r\n        }\r\n        else {\r\n            this.getter = parsePath(expOrFn);\r\n            if (!this.getter) {\r\n                this.getter = noop;\r\n                 false &&\r\n                    0;\r\n            }\r\n        }\r\n        this.value = this.lazy ? undefined : this.get();\r\n    }\r\n    /**\r\n     * Evaluate the getter, and re-collect dependencies.\r\n     */\r\n    Watcher.prototype.get = function () {\r\n        pushTarget(this);\r\n        var value;\r\n        var vm = this.vm;\r\n        try {\r\n            value = this.getter.call(vm, vm);\r\n        }\r\n        catch (e) {\r\n            if (this.user) {\r\n                handleError(e, vm, \"getter for watcher \\\"\".concat(this.expression, \"\\\"\"));\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        finally {\r\n            // \"touch\" every property so they are all tracked as\r\n            // dependencies for deep watching\r\n            if (this.deep) {\r\n                traverse(value);\r\n            }\r\n            popTarget();\r\n            this.cleanupDeps();\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * Add a dependency to this directive.\r\n     */\r\n    Watcher.prototype.addDep = function (dep) {\r\n        var id = dep.id;\r\n        if (!this.newDepIds.has(id)) {\r\n            this.newDepIds.add(id);\r\n            this.newDeps.push(dep);\r\n            if (!this.depIds.has(id)) {\r\n                dep.addSub(this);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Clean up for dependency collection.\r\n     */\r\n    Watcher.prototype.cleanupDeps = function () {\r\n        var i = this.deps.length;\r\n        while (i--) {\r\n            var dep = this.deps[i];\r\n            if (!this.newDepIds.has(dep.id)) {\r\n                dep.removeSub(this);\r\n            }\r\n        }\r\n        var tmp = this.depIds;\r\n        this.depIds = this.newDepIds;\r\n        this.newDepIds = tmp;\r\n        this.newDepIds.clear();\r\n        tmp = this.deps;\r\n        this.deps = this.newDeps;\r\n        this.newDeps = tmp;\r\n        this.newDeps.length = 0;\r\n    };\r\n    /**\r\n     * Subscriber interface.\r\n     * Will be called when a dependency changes.\r\n     */\r\n    Watcher.prototype.update = function () {\r\n        /* istanbul ignore else */\r\n        if (this.lazy) {\r\n            this.dirty = true;\r\n        }\r\n        else if (this.sync) {\r\n            this.run();\r\n        }\r\n        else {\r\n            queueWatcher(this);\r\n        }\r\n    };\r\n    /**\r\n     * Scheduler job interface.\r\n     * Will be called by the scheduler.\r\n     */\r\n    Watcher.prototype.run = function () {\r\n        if (this.active) {\r\n            var value = this.get();\r\n            if (value !== this.value ||\r\n                // Deep watchers and watchers on Object/Arrays should fire even\r\n                // when the value is the same, because the value may\r\n                // have mutated.\r\n                isObject(value) ||\r\n                this.deep) {\r\n                // set new value\r\n                var oldValue = this.value;\r\n                this.value = value;\r\n                if (this.user) {\r\n                    var info = \"callback for watcher \\\"\".concat(this.expression, \"\\\"\");\r\n                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\r\n                }\r\n                else {\r\n                    this.cb.call(this.vm, value, oldValue);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Evaluate the value of the watcher.\r\n     * This only gets called for lazy watchers.\r\n     */\r\n    Watcher.prototype.evaluate = function () {\r\n        this.value = this.get();\r\n        this.dirty = false;\r\n    };\r\n    /**\r\n     * Depend on all deps collected by this watcher.\r\n     */\r\n    Watcher.prototype.depend = function () {\r\n        var i = this.deps.length;\r\n        while (i--) {\r\n            this.deps[i].depend();\r\n        }\r\n    };\r\n    /**\r\n     * Remove self from all dependencies' subscriber list.\r\n     */\r\n    Watcher.prototype.teardown = function () {\r\n        if (this.vm && !this.vm._isBeingDestroyed) {\r\n            remove$2(this.vm._scope.effects, this);\r\n        }\r\n        if (this.active) {\r\n            var i = this.deps.length;\r\n            while (i--) {\r\n                this.deps[i].removeSub(this);\r\n            }\r\n            this.active = false;\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n        }\r\n    };\r\n    return Watcher;\r\n}());\r\n\r\nvar sharedPropertyDefinition = {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: noop,\r\n    set: noop\r\n};\r\nfunction proxy(target, sourceKey, key) {\r\n    sharedPropertyDefinition.get = function proxyGetter() {\r\n        return this[sourceKey][key];\r\n    };\r\n    sharedPropertyDefinition.set = function proxySetter(val) {\r\n        this[sourceKey][key] = val;\r\n    };\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction initState(vm) {\r\n    var opts = vm.$options;\r\n    if (opts.props)\r\n        initProps$1(vm, opts.props);\r\n    // Composition API\r\n    initSetup(vm);\r\n    if (opts.methods)\r\n        initMethods(vm, opts.methods);\r\n    if (opts.data) {\r\n        initData(vm);\r\n    }\r\n    else {\r\n        var ob = observe((vm._data = {}));\r\n        ob && ob.vmCount++;\r\n    }\r\n    if (opts.computed)\r\n        initComputed$1(vm, opts.computed);\r\n    if (opts.watch && opts.watch !== nativeWatch) {\r\n        initWatch(vm, opts.watch);\r\n    }\r\n}\r\nfunction initProps$1(vm, propsOptions) {\r\n    var propsData = vm.$options.propsData || {};\r\n    var props = (vm._props = shallowReactive({}));\r\n    // cache prop keys so that future props updates can iterate using Array\r\n    // instead of dynamic object key enumeration.\r\n    var keys = (vm.$options._propKeys = []);\r\n    var isRoot = !vm.$parent;\r\n    // root instance props should be converted\r\n    if (!isRoot) {\r\n        toggleObserving(false);\r\n    }\r\n    var _loop_1 = function (key) {\r\n        keys.push(key);\r\n        var value = validateProp(key, propsOptions, propsData, vm);\r\n        /* istanbul ignore else */\r\n        if (false) // removed by dead control flow\n{ var hyphenatedKey; }\r\n        else {\r\n            defineReactive(props, key, value, undefined, true /* shallow */);\r\n        }\r\n        // static props are already proxied on the component's prototype\r\n        // during Vue.extend(). We only need to proxy props defined at\r\n        // instantiation here.\r\n        if (!(key in vm)) {\r\n            proxy(vm, \"_props\", key);\r\n        }\r\n    };\r\n    for (var key in propsOptions) {\r\n        _loop_1(key);\r\n    }\r\n    toggleObserving(true);\r\n}\r\nfunction initData(vm) {\r\n    var data = vm.$options.data;\r\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};\r\n    if (!isPlainObject(data)) {\r\n        data = {};\r\n         false &&\r\n            0;\r\n    }\r\n    // proxy data on instance\r\n    var keys = Object.keys(data);\r\n    var props = vm.$options.props;\r\n    var methods = vm.$options.methods;\r\n    var i = keys.length;\r\n    while (i--) {\r\n        var key = keys[i];\r\n        if (false) // removed by dead control flow\n{}\r\n        if (props && hasOwn(props, key)) {\r\n             false &&\r\n                0;\r\n        }\r\n        else if (!isReserved(key)) {\r\n            proxy(vm, \"_data\", key);\r\n        }\r\n    }\r\n    // observe data\r\n    var ob = observe(data);\r\n    ob && ob.vmCount++;\r\n}\r\nfunction getData(data, vm) {\r\n    // #7573 disable dep collection when invoking data getters\r\n    pushTarget();\r\n    try {\r\n        return data.call(vm, vm);\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, \"data()\");\r\n        return {};\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nvar computedWatcherOptions = { lazy: true };\r\nfunction initComputed$1(vm, computed) {\r\n    // $flow-disable-line\r\n    var watchers = (vm._computedWatchers = Object.create(null));\r\n    // computed properties are just getters during SSR\r\n    var isSSR = isServerRendering();\r\n    for (var key in computed) {\r\n        var userDef = computed[key];\r\n        var getter = isFunction(userDef) ? userDef : userDef.get;\r\n        if (false) // removed by dead control flow\n{}\r\n        if (!isSSR) {\r\n            // create internal watcher for the computed property.\r\n            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\r\n        }\r\n        // component-defined computed properties are already defined on the\r\n        // component prototype. We only need to define computed properties defined\r\n        // at instantiation here.\r\n        if (!(key in vm)) {\r\n            defineComputed(vm, key, userDef);\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n}\r\nfunction defineComputed(target, key, userDef) {\r\n    var shouldCache = !isServerRendering();\r\n    if (isFunction(userDef)) {\r\n        sharedPropertyDefinition.get = shouldCache\r\n            ? createComputedGetter(key)\r\n            : createGetterInvoker(userDef);\r\n        sharedPropertyDefinition.set = noop;\r\n    }\r\n    else {\r\n        sharedPropertyDefinition.get = userDef.get\r\n            ? shouldCache && userDef.cache !== false\r\n                ? createComputedGetter(key)\r\n                : createGetterInvoker(userDef.get)\r\n            : noop;\r\n        sharedPropertyDefinition.set = userDef.set || noop;\r\n    }\r\n    if (false) // removed by dead control flow\n{}\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction createComputedGetter(key) {\r\n    return function computedGetter() {\r\n        var watcher = this._computedWatchers && this._computedWatchers[key];\r\n        if (watcher) {\r\n            if (watcher.dirty) {\r\n                watcher.evaluate();\r\n            }\r\n            if (Dep.target) {\r\n                if (false) // removed by dead control flow\n{}\r\n                watcher.depend();\r\n            }\r\n            return watcher.value;\r\n        }\r\n    };\r\n}\r\nfunction createGetterInvoker(fn) {\r\n    return function computedGetter() {\r\n        return fn.call(this, this);\r\n    };\r\n}\r\nfunction initMethods(vm, methods) {\r\n    var props = vm.$options.props;\r\n    for (var key in methods) {\r\n        if (false) // removed by dead control flow\n{}\r\n        vm[key] = typeof methods[key] !== 'function' ? noop : bind$1(methods[key], vm);\r\n    }\r\n}\r\nfunction initWatch(vm, watch) {\r\n    for (var key in watch) {\r\n        var handler = watch[key];\r\n        if (isArray(handler)) {\r\n            for (var i = 0; i < handler.length; i++) {\r\n                createWatcher(vm, key, handler[i]);\r\n            }\r\n        }\r\n        else {\r\n            createWatcher(vm, key, handler);\r\n        }\r\n    }\r\n}\r\nfunction createWatcher(vm, expOrFn, handler, options) {\r\n    if (isPlainObject(handler)) {\r\n        options = handler;\r\n        handler = handler.handler;\r\n    }\r\n    if (typeof handler === 'string') {\r\n        handler = vm[handler];\r\n    }\r\n    return vm.$watch(expOrFn, handler, options);\r\n}\r\nfunction stateMixin(Vue) {\r\n    // flow somehow has problems with directly declared definition object\r\n    // when using Object.defineProperty, so we have to procedurally build up\r\n    // the object here.\r\n    var dataDef = {};\r\n    dataDef.get = function () {\r\n        return this._data;\r\n    };\r\n    var propsDef = {};\r\n    propsDef.get = function () {\r\n        return this._props;\r\n    };\r\n    if (false) // removed by dead control flow\n{}\r\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\r\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\r\n    Vue.prototype.$set = set;\r\n    Vue.prototype.$delete = del;\r\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\r\n        var vm = this;\r\n        if (isPlainObject(cb)) {\r\n            return createWatcher(vm, expOrFn, cb, options);\r\n        }\r\n        options = options || {};\r\n        options.user = true;\r\n        var watcher = new Watcher(vm, expOrFn, cb, options);\r\n        if (options.immediate) {\r\n            var info = \"callback for immediate watcher \\\"\".concat(watcher.expression, \"\\\"\");\r\n            pushTarget();\r\n            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\r\n            popTarget();\r\n        }\r\n        return function unwatchFn() {\r\n            watcher.teardown();\r\n        };\r\n    };\r\n}\r\n\r\nfunction initProvide(vm) {\r\n    var provideOption = vm.$options.provide;\r\n    if (provideOption) {\r\n        var provided = isFunction(provideOption)\r\n            ? provideOption.call(vm)\r\n            : provideOption;\r\n        if (!isObject(provided)) {\r\n            return;\r\n        }\r\n        var source = resolveProvided(vm);\r\n        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to\r\n        // iterate the keys ourselves.\r\n        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));\r\n        }\r\n    }\r\n}\r\nfunction initInjections(vm) {\r\n    var result = resolveInject(vm.$options.inject, vm);\r\n    if (result) {\r\n        toggleObserving(false);\r\n        Object.keys(result).forEach(function (key) {\r\n            /* istanbul ignore else */\r\n            if (false) // removed by dead control flow\n{}\r\n            else {\r\n                defineReactive(vm, key, result[key]);\r\n            }\r\n        });\r\n        toggleObserving(true);\r\n    }\r\n}\r\nfunction resolveInject(inject, vm) {\r\n    if (inject) {\r\n        // inject is :any because flow is not smart enough to figure out cached\r\n        var result = Object.create(null);\r\n        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            // #6574 in case the inject object is observed...\r\n            if (key === '__ob__')\r\n                continue;\r\n            var provideKey = inject[key].from;\r\n            if (provideKey in vm._provided) {\r\n                result[key] = vm._provided[provideKey];\r\n            }\r\n            else if ('default' in inject[key]) {\r\n                var provideDefault = inject[key].default;\r\n                result[key] = isFunction(provideDefault)\r\n                    ? provideDefault.call(vm)\r\n                    : provideDefault;\r\n            }\r\n            else if (false) // removed by dead control flow\n{}\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nvar uid = 0;\r\nfunction initMixin$1(Vue) {\r\n    Vue.prototype._init = function (options) {\r\n        var vm = this;\r\n        // a uid\r\n        vm._uid = uid++;\r\n        var startTag, endTag;\r\n        /* istanbul ignore if */\r\n        if (false) // removed by dead control flow\n{}\r\n        // a flag to mark this as a Vue instance without having to do instanceof\r\n        // check\r\n        vm._isVue = true;\r\n        // avoid instances from being observed\r\n        vm.__v_skip = true;\r\n        // effect scope\r\n        vm._scope = new EffectScope(true /* detached */);\r\n        // #13134 edge case where a child component is manually created during the\r\n        // render of a parent component\r\n        vm._scope.parent = undefined;\r\n        vm._scope._vm = true;\r\n        // merge options\r\n        if (options && options._isComponent) {\r\n            // optimize internal component instantiation\r\n            // since dynamic options merging is pretty slow, and none of the\r\n            // internal component options needs special treatment.\r\n            initInternalComponent(vm, options);\r\n        }\r\n        else {\r\n            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\r\n        }\r\n        /* istanbul ignore else */\r\n        if (false) // removed by dead control flow\n{}\r\n        else {\r\n            vm._renderProxy = vm;\r\n        }\r\n        // expose real self\r\n        vm._self = vm;\r\n        initLifecycle(vm);\r\n        initEvents(vm);\r\n        initRender(vm);\r\n        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);\r\n        initInjections(vm); // resolve injections before data/props\r\n        initState(vm);\r\n        initProvide(vm); // resolve provide after data/props\r\n        callHook$1(vm, 'created');\r\n        /* istanbul ignore if */\r\n        if (false) // removed by dead control flow\n{}\r\n        if (vm.$options.el) {\r\n            vm.$mount(vm.$options.el);\r\n        }\r\n    };\r\n}\r\nfunction initInternalComponent(vm, options) {\r\n    var opts = (vm.$options = Object.create(vm.constructor.options));\r\n    // doing this because it's faster than dynamic enumeration.\r\n    var parentVnode = options._parentVnode;\r\n    opts.parent = options.parent;\r\n    opts._parentVnode = parentVnode;\r\n    var vnodeComponentOptions = parentVnode.componentOptions;\r\n    opts.propsData = vnodeComponentOptions.propsData;\r\n    opts._parentListeners = vnodeComponentOptions.listeners;\r\n    opts._renderChildren = vnodeComponentOptions.children;\r\n    opts._componentTag = vnodeComponentOptions.tag;\r\n    if (options.render) {\r\n        opts.render = options.render;\r\n        opts.staticRenderFns = options.staticRenderFns;\r\n    }\r\n}\r\nfunction resolveConstructorOptions(Ctor) {\r\n    var options = Ctor.options;\r\n    if (Ctor.super) {\r\n        var superOptions = resolveConstructorOptions(Ctor.super);\r\n        var cachedSuperOptions = Ctor.superOptions;\r\n        if (superOptions !== cachedSuperOptions) {\r\n            // super option changed,\r\n            // need to resolve new options.\r\n            Ctor.superOptions = superOptions;\r\n            // check if there are any late-modified/attached options (#4976)\r\n            var modifiedOptions = resolveModifiedOptions(Ctor);\r\n            // update base extend options\r\n            if (modifiedOptions) {\r\n                extend(Ctor.extendOptions, modifiedOptions);\r\n            }\r\n            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\r\n            if (options.name) {\r\n                options.components[options.name] = Ctor;\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}\r\nfunction resolveModifiedOptions(Ctor) {\r\n    var modified;\r\n    var latest = Ctor.options;\r\n    var sealed = Ctor.sealedOptions;\r\n    for (var key in latest) {\r\n        if (latest[key] !== sealed[key]) {\r\n            if (!modified)\r\n                modified = {};\r\n            modified[key] = latest[key];\r\n        }\r\n    }\r\n    return modified;\r\n}\r\n\r\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\r\n    var _this = this;\r\n    var options = Ctor.options;\r\n    // ensure the createElement function in functional components\r\n    // gets a unique context - this is necessary for correct named slot check\r\n    var contextVm;\r\n    if (hasOwn(parent, '_uid')) {\r\n        contextVm = Object.create(parent);\r\n        contextVm._original = parent;\r\n    }\r\n    else {\r\n        // the context vm passed in is a functional context as well.\r\n        // in this case we want to make sure we are able to get a hold to the\r\n        // real context instance.\r\n        contextVm = parent;\r\n        // @ts-ignore\r\n        parent = parent._original;\r\n    }\r\n    var isCompiled = isTrue(options._compiled);\r\n    var needNormalization = !isCompiled;\r\n    this.data = data;\r\n    this.props = props;\r\n    this.children = children;\r\n    this.parent = parent;\r\n    this.listeners = data.on || emptyObject;\r\n    this.injections = resolveInject(options.inject, parent);\r\n    this.slots = function () {\r\n        if (!_this.$slots) {\r\n            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));\r\n        }\r\n        return _this.$slots;\r\n    };\r\n    Object.defineProperty(this, 'scopedSlots', {\r\n        enumerable: true,\r\n        get: function () {\r\n            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\r\n        }\r\n    });\r\n    // support for compiled functional template\r\n    if (isCompiled) {\r\n        // exposing $options for renderStatic()\r\n        this.$options = options;\r\n        // pre-resolve slots for renderSlot()\r\n        this.$slots = this.slots();\r\n        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\r\n    }\r\n    if (options._scopeId) {\r\n        this._c = function (a, b, c, d) {\r\n            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);\r\n            if (vnode && !isArray(vnode)) {\r\n                vnode.fnScopeId = options._scopeId;\r\n                vnode.fnContext = parent;\r\n            }\r\n            return vnode;\r\n        };\r\n    }\r\n    else {\r\n        this._c = function (a, b, c, d) {\r\n            return createElement$1(contextVm, a, b, c, d, needNormalization);\r\n        };\r\n    }\r\n}\r\ninstallRenderHelpers(FunctionalRenderContext.prototype);\r\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\r\n    var options = Ctor.options;\r\n    var props = {};\r\n    var propOptions = options.props;\r\n    if (isDef(propOptions)) {\r\n        for (var key in propOptions) {\r\n            props[key] = validateProp(key, propOptions, propsData || emptyObject);\r\n        }\r\n    }\r\n    else {\r\n        if (isDef(data.attrs))\r\n            mergeProps(props, data.attrs);\r\n        if (isDef(data.props))\r\n            mergeProps(props, data.props);\r\n    }\r\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\r\n    var vnode = options.render.call(null, renderContext._c, renderContext);\r\n    if (vnode instanceof VNode) {\r\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\r\n    }\r\n    else if (isArray(vnode)) {\r\n        var vnodes = normalizeChildren(vnode) || [];\r\n        var res = new Array(vnodes.length);\r\n        for (var i = 0; i < vnodes.length; i++) {\r\n            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\r\n        }\r\n        return res;\r\n    }\r\n}\r\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\r\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\r\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\r\n    // that should not be matched to match.\r\n    var clone = cloneVNode(vnode);\r\n    clone.fnContext = contextVm;\r\n    clone.fnOptions = options;\r\n    if (false) // removed by dead control flow\n{}\r\n    if (data.slot) {\r\n        (clone.data || (clone.data = {})).slot = data.slot;\r\n    }\r\n    return clone;\r\n}\r\nfunction mergeProps(to, from) {\r\n    for (var key in from) {\r\n        to[camelize(key)] = from[key];\r\n    }\r\n}\r\n\r\nfunction getComponentName(options) {\r\n    return options.name || options.__name || options._componentTag;\r\n}\r\n// inline hooks to be invoked on component VNodes during patch\r\nvar componentVNodeHooks = {\r\n    init: function (vnode, hydrating) {\r\n        if (vnode.componentInstance &&\r\n            !vnode.componentInstance._isDestroyed &&\r\n            vnode.data.keepAlive) {\r\n            // kept-alive components, treat as a patch\r\n            var mountedNode = vnode; // work around flow\r\n            componentVNodeHooks.prepatch(mountedNode, mountedNode);\r\n        }\r\n        else {\r\n            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));\r\n            child.$mount(hydrating ? vnode.elm : undefined, hydrating);\r\n        }\r\n    },\r\n    prepatch: function (oldVnode, vnode) {\r\n        var options = vnode.componentOptions;\r\n        var child = (vnode.componentInstance = oldVnode.componentInstance);\r\n        updateChildComponent(child, options.propsData, // updated props\r\n        options.listeners, // updated listeners\r\n        vnode, // new parent vnode\r\n        options.children // new children\r\n        );\r\n    },\r\n    insert: function (vnode) {\r\n        var context = vnode.context, componentInstance = vnode.componentInstance;\r\n        if (!componentInstance._isMounted) {\r\n            componentInstance._isMounted = true;\r\n            callHook$1(componentInstance, 'mounted');\r\n        }\r\n        if (vnode.data.keepAlive) {\r\n            if (context._isMounted) {\r\n                // vue-router#1212\r\n                // During updates, a kept-alive component's child components may\r\n                // change, so directly walking the tree here may call activated hooks\r\n                // on incorrect children. Instead we push them into a queue which will\r\n                // be processed after the whole patch process ended.\r\n                queueActivatedComponent(componentInstance);\r\n            }\r\n            else {\r\n                activateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    },\r\n    destroy: function (vnode) {\r\n        var componentInstance = vnode.componentInstance;\r\n        if (!componentInstance._isDestroyed) {\r\n            if (!vnode.data.keepAlive) {\r\n                componentInstance.$destroy();\r\n            }\r\n            else {\r\n                deactivateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    }\r\n};\r\nvar hooksToMerge = Object.keys(componentVNodeHooks);\r\nfunction createComponent(Ctor, data, context, children, tag) {\r\n    if (isUndef(Ctor)) {\r\n        return;\r\n    }\r\n    var baseCtor = context.$options._base;\r\n    // plain options object: turn it into a constructor\r\n    if (isObject(Ctor)) {\r\n        Ctor = baseCtor.extend(Ctor);\r\n    }\r\n    // if at this stage it's not a constructor or an async component factory,\r\n    // reject.\r\n    if (typeof Ctor !== 'function') {\r\n        if (false) // removed by dead control flow\n{}\r\n        return;\r\n    }\r\n    // async component\r\n    var asyncFactory;\r\n    // @ts-expect-error\r\n    if (isUndef(Ctor.cid)) {\r\n        asyncFactory = Ctor;\r\n        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\r\n        if (Ctor === undefined) {\r\n            // return a placeholder node for async component, which is rendered\r\n            // as a comment node but preserves all the raw information for the node.\r\n            // the information will be used for async server-rendering and hydration.\r\n            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\r\n        }\r\n    }\r\n    data = data || {};\r\n    // resolve constructor options in case global mixins are applied after\r\n    // component constructor creation\r\n    resolveConstructorOptions(Ctor);\r\n    // transform component v-model data into props & events\r\n    if (isDef(data.model)) {\r\n        // @ts-expect-error\r\n        transformModel(Ctor.options, data);\r\n    }\r\n    // extract props\r\n    // @ts-expect-error\r\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\r\n    // functional component\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.functional)) {\r\n        return createFunctionalComponent(Ctor, propsData, data, context, children);\r\n    }\r\n    // extract listeners, since these needs to be treated as\r\n    // child component listeners instead of DOM listeners\r\n    var listeners = data.on;\r\n    // replace with listeners with .native modifier\r\n    // so it gets processed during parent component patch.\r\n    data.on = data.nativeOn;\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.abstract)) {\r\n        // abstract components do not keep anything\r\n        // other than props & listeners & slot\r\n        // work around flow\r\n        var slot = data.slot;\r\n        data = {};\r\n        if (slot) {\r\n            data.slot = slot;\r\n        }\r\n    }\r\n    // install component management hooks onto the placeholder node\r\n    installComponentHooks(data);\r\n    // return a placeholder vnode\r\n    // @ts-expect-error\r\n    var name = getComponentName(Ctor.options) || tag;\r\n    var vnode = new VNode(\r\n    // @ts-expect-error\r\n    \"vue-component-\".concat(Ctor.cid).concat(name ? \"-\".concat(name) : ''), data, undefined, undefined, undefined, context, \r\n    // @ts-expect-error\r\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\r\n    return vnode;\r\n}\r\nfunction createComponentInstanceForVnode(\r\n// we know it's MountedComponentVNode but flow doesn't\r\nvnode, \r\n// activeInstance in lifecycle state\r\nparent) {\r\n    var options = {\r\n        _isComponent: true,\r\n        _parentVnode: vnode,\r\n        parent: parent\r\n    };\r\n    // check inline-template render functions\r\n    var inlineTemplate = vnode.data.inlineTemplate;\r\n    if (isDef(inlineTemplate)) {\r\n        options.render = inlineTemplate.render;\r\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\r\n    }\r\n    return new vnode.componentOptions.Ctor(options);\r\n}\r\nfunction installComponentHooks(data) {\r\n    var hooks = data.hook || (data.hook = {});\r\n    for (var i = 0; i < hooksToMerge.length; i++) {\r\n        var key = hooksToMerge[i];\r\n        var existing = hooks[key];\r\n        var toMerge = componentVNodeHooks[key];\r\n        // @ts-expect-error\r\n        if (existing !== toMerge && !(existing && existing._merged)) {\r\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\r\n        }\r\n    }\r\n}\r\nfunction mergeHook(f1, f2) {\r\n    var merged = function (a, b) {\r\n        // flow complains about extra args which is why we use any\r\n        f1(a, b);\r\n        f2(a, b);\r\n    };\r\n    merged._merged = true;\r\n    return merged;\r\n}\r\n// transform component v-model info (value and callback) into\r\n// prop and event handler respectively.\r\nfunction transformModel(options, data) {\r\n    var prop = (options.model && options.model.prop) || 'value';\r\n    var event = (options.model && options.model.event) || 'input';\r\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\r\n    var on = data.on || (data.on = {});\r\n    var existing = on[event];\r\n    var callback = data.model.callback;\r\n    if (isDef(existing)) {\r\n        if (isArray(existing)\r\n            ? existing.indexOf(callback) === -1\r\n            : existing !== callback) {\r\n            on[event] = [callback].concat(existing);\r\n        }\r\n    }\r\n    else {\r\n        on[event] = callback;\r\n    }\r\n}\r\n\r\nvar warn$2 = noop;\r\nvar tip = (/* unused pure expression or super */ null && (noop));\r\nvar generateComponentTrace; // work around flow check\r\nvar formatComponentName;\r\nif (false) // removed by dead control flow\n{ var repeat_1, classify_1, classifyRE_1, hasConsole_1; }\r\n\r\n/**\r\n * Option overwriting strategies are functions that handle\r\n * how to merge a parent option value and a child option\r\n * value into the final value.\r\n */\r\nvar strats = config.optionMergeStrategies;\r\n/**\r\n * Options with restrictions\r\n */\r\nif (false) // removed by dead control flow\n{}\r\n/**\r\n * Helper that recursively merges two data objects together.\r\n */\r\nfunction mergeData(to, from, recursive) {\r\n    if (recursive === void 0) { recursive = true; }\r\n    if (!from)\r\n        return to;\r\n    var key, toVal, fromVal;\r\n    var keys = hasSymbol\r\n        ? Reflect.ownKeys(from)\r\n        : Object.keys(from);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        key = keys[i];\r\n        // in case the object is already observed...\r\n        if (key === '__ob__')\r\n            continue;\r\n        toVal = to[key];\r\n        fromVal = from[key];\r\n        if (!recursive || !hasOwn(to, key)) {\r\n            set(to, key, fromVal);\r\n        }\r\n        else if (toVal !== fromVal &&\r\n            isPlainObject(toVal) &&\r\n            isPlainObject(fromVal)) {\r\n            mergeData(toVal, fromVal);\r\n        }\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Data\r\n */\r\nfunction mergeDataOrFn(parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        // in a Vue.extend merge, both should be functions\r\n        if (!childVal) {\r\n            return parentVal;\r\n        }\r\n        if (!parentVal) {\r\n            return childVal;\r\n        }\r\n        // when parentVal & childVal are both present,\r\n        // we need to return a function that returns the\r\n        // merged result of both functions... no need to\r\n        // check if parentVal is a function here because\r\n        // it has to be a function to pass previous merges.\r\n        return function mergedDataFn() {\r\n            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\r\n        };\r\n    }\r\n    else {\r\n        return function mergedInstanceDataFn() {\r\n            // instance merge\r\n            var instanceData = isFunction(childVal)\r\n                ? childVal.call(vm, vm)\r\n                : childVal;\r\n            var defaultData = isFunction(parentVal)\r\n                ? parentVal.call(vm, vm)\r\n                : parentVal;\r\n            if (instanceData) {\r\n                return mergeData(instanceData, defaultData);\r\n            }\r\n            else {\r\n                return defaultData;\r\n            }\r\n        };\r\n    }\r\n}\r\nstrats.data = function (parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        if (childVal && typeof childVal !== 'function') {\r\n             false &&\r\n                0;\r\n            return parentVal;\r\n        }\r\n        return mergeDataOrFn(parentVal, childVal);\r\n    }\r\n    return mergeDataOrFn(parentVal, childVal, vm);\r\n};\r\n/**\r\n * Hooks and props are merged as arrays.\r\n */\r\nfunction mergeLifecycleHook(parentVal, childVal) {\r\n    var res = childVal\r\n        ? parentVal\r\n            ? parentVal.concat(childVal)\r\n            : isArray(childVal)\r\n                ? childVal\r\n                : [childVal]\r\n        : parentVal;\r\n    return res ? dedupeHooks(res) : res;\r\n}\r\nfunction dedupeHooks(hooks) {\r\n    var res = [];\r\n    for (var i = 0; i < hooks.length; i++) {\r\n        if (res.indexOf(hooks[i]) === -1) {\r\n            res.push(hooks[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nLIFECYCLE_HOOKS.forEach(function (hook) {\r\n    strats[hook] = mergeLifecycleHook;\r\n});\r\n/**\r\n * Assets\r\n *\r\n * When a vm is present (instance creation), we need to do\r\n * a three-way merge between constructor options, instance\r\n * options and parent options.\r\n */\r\nfunction mergeAssets(parentVal, childVal, vm, key) {\r\n    var res = Object.create(parentVal || null);\r\n    if (childVal) {\r\n         false && 0;\r\n        return extend(res, childVal);\r\n    }\r\n    else {\r\n        return res;\r\n    }\r\n}\r\nASSET_TYPES.forEach(function (type) {\r\n    strats[type + 's'] = mergeAssets;\r\n});\r\n/**\r\n * Watchers.\r\n *\r\n * Watchers hashes should not overwrite one\r\n * another, so we merge them as arrays.\r\n */\r\nstrats.watch = function (parentVal, childVal, vm, key) {\r\n    // work around Firefox's Object.prototype.watch...\r\n    //@ts-expect-error work around\r\n    if (parentVal === nativeWatch)\r\n        parentVal = undefined;\r\n    //@ts-expect-error work around\r\n    if (childVal === nativeWatch)\r\n        childVal = undefined;\r\n    /* istanbul ignore if */\r\n    if (!childVal)\r\n        return Object.create(parentVal || null);\r\n    if (false) // removed by dead control flow\n{}\r\n    if (!parentVal)\r\n        return childVal;\r\n    var ret = {};\r\n    extend(ret, parentVal);\r\n    for (var key_1 in childVal) {\r\n        var parent_1 = ret[key_1];\r\n        var child = childVal[key_1];\r\n        if (parent_1 && !isArray(parent_1)) {\r\n            parent_1 = [parent_1];\r\n        }\r\n        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];\r\n    }\r\n    return ret;\r\n};\r\n/**\r\n * Other object hashes.\r\n */\r\nstrats.props =\r\n    strats.methods =\r\n        strats.inject =\r\n            strats.computed =\r\n                function (parentVal, childVal, vm, key) {\r\n                    if (childVal && \"production\" !== 'production') // removed by dead control flow\n{}\r\n                    if (!parentVal)\r\n                        return childVal;\r\n                    var ret = Object.create(null);\r\n                    extend(ret, parentVal);\r\n                    if (childVal)\r\n                        extend(ret, childVal);\r\n                    return ret;\r\n                };\r\nstrats.provide = function (parentVal, childVal) {\r\n    if (!parentVal)\r\n        return childVal;\r\n    return function () {\r\n        var ret = Object.create(null);\r\n        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);\r\n        if (childVal) {\r\n            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive\r\n            );\r\n        }\r\n        return ret;\r\n    };\r\n};\r\n/**\r\n * Default strategy.\r\n */\r\nvar defaultStrat = function (parentVal, childVal) {\r\n    return childVal === undefined ? parentVal : childVal;\r\n};\r\n/**\r\n * Validate component names\r\n */\r\nfunction checkComponents(options) {\r\n    for (var key in options.components) {\r\n        validateComponentName(key);\r\n    }\r\n}\r\nfunction validateComponentName(name) {\r\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\".concat(unicodeRegExp.source, \"]*$\")).test(name)) {\r\n        warn$2('Invalid component name: \"' +\r\n            name +\r\n            '\". Component names ' +\r\n            'should conform to valid custom element name in html5 specification.');\r\n    }\r\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\r\n        warn$2('Do not use built-in or reserved HTML elements as component ' +\r\n            'id: ' +\r\n            name);\r\n    }\r\n}\r\n/**\r\n * Ensure all props option syntax are normalized into the\r\n * Object-based format.\r\n */\r\nfunction normalizeProps(options, vm) {\r\n    var props = options.props;\r\n    if (!props)\r\n        return;\r\n    var res = {};\r\n    var i, val, name;\r\n    if (isArray(props)) {\r\n        i = props.length;\r\n        while (i--) {\r\n            val = props[i];\r\n            if (typeof val === 'string') {\r\n                name = camelize(val);\r\n                res[name] = { type: null };\r\n            }\r\n            else if (false) // removed by dead control flow\n{}\r\n        }\r\n    }\r\n    else if (isPlainObject(props)) {\r\n        for (var key in props) {\r\n            val = props[key];\r\n            name = camelize(key);\r\n            res[name] = isPlainObject(val) ? val : { type: val };\r\n        }\r\n    }\r\n    else if (false) // removed by dead control flow\n{}\r\n    options.props = res;\r\n}\r\n/**\r\n * Normalize all injections into Object-based format\r\n */\r\nfunction normalizeInject(options, vm) {\r\n    var inject = options.inject;\r\n    if (!inject)\r\n        return;\r\n    var normalized = (options.inject = {});\r\n    if (isArray(inject)) {\r\n        for (var i = 0; i < inject.length; i++) {\r\n            normalized[inject[i]] = { from: inject[i] };\r\n        }\r\n    }\r\n    else if (isPlainObject(inject)) {\r\n        for (var key in inject) {\r\n            var val = inject[key];\r\n            normalized[key] = isPlainObject(val)\r\n                ? extend({ from: key }, val)\r\n                : { from: val };\r\n        }\r\n    }\r\n    else if (false) // removed by dead control flow\n{}\r\n}\r\n/**\r\n * Normalize raw function directives into object format.\r\n */\r\nfunction normalizeDirectives$1(options) {\r\n    var dirs = options.directives;\r\n    if (dirs) {\r\n        for (var key in dirs) {\r\n            var def = dirs[key];\r\n            if (isFunction(def)) {\r\n                dirs[key] = { bind: def, update: def };\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction assertObjectType(name, value, vm) {\r\n    if (!isPlainObject(value)) {\r\n        warn$2(\"Invalid value for option \\\"\".concat(name, \"\\\": expected an Object, \") +\r\n            \"but got \".concat(toRawType(value), \".\"), vm);\r\n    }\r\n}\r\n/**\r\n * Merge two option objects into a new one.\r\n * Core utility used in both instantiation and inheritance.\r\n */\r\nfunction mergeOptions(parent, child, vm) {\r\n    if (false) // removed by dead control flow\n{}\r\n    if (isFunction(child)) {\r\n        // @ts-expect-error\r\n        child = child.options;\r\n    }\r\n    normalizeProps(child, vm);\r\n    normalizeInject(child, vm);\r\n    normalizeDirectives$1(child);\r\n    // Apply extends and mixins on the child options,\r\n    // but only if it is a raw options object that isn't\r\n    // the result of another mergeOptions call.\r\n    // Only merged options has the _base property.\r\n    if (!child._base) {\r\n        if (child.extends) {\r\n            parent = mergeOptions(parent, child.extends, vm);\r\n        }\r\n        if (child.mixins) {\r\n            for (var i = 0, l = child.mixins.length; i < l; i++) {\r\n                parent = mergeOptions(parent, child.mixins[i], vm);\r\n            }\r\n        }\r\n    }\r\n    var options = {};\r\n    var key;\r\n    for (key in parent) {\r\n        mergeField(key);\r\n    }\r\n    for (key in child) {\r\n        if (!hasOwn(parent, key)) {\r\n            mergeField(key);\r\n        }\r\n    }\r\n    function mergeField(key) {\r\n        var strat = strats[key] || defaultStrat;\r\n        options[key] = strat(parent[key], child[key], vm, key);\r\n    }\r\n    return options;\r\n}\r\n/**\r\n * Resolve an asset.\r\n * This function is used because child instances need access\r\n * to assets defined in its ancestor chain.\r\n */\r\nfunction resolveAsset(options, type, id, warnMissing) {\r\n    /* istanbul ignore if */\r\n    if (typeof id !== 'string') {\r\n        return;\r\n    }\r\n    var assets = options[type];\r\n    // check local registration variations first\r\n    if (hasOwn(assets, id))\r\n        return assets[id];\r\n    var camelizedId = camelize(id);\r\n    if (hasOwn(assets, camelizedId))\r\n        return assets[camelizedId];\r\n    var PascalCaseId = capitalize(camelizedId);\r\n    if (hasOwn(assets, PascalCaseId))\r\n        return assets[PascalCaseId];\r\n    // fallback to prototype chain\r\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\r\n    if (false) // removed by dead control flow\n{}\r\n    return res;\r\n}\r\n\r\nfunction validateProp(key, propOptions, propsData, vm) {\r\n    var prop = propOptions[key];\r\n    var absent = !hasOwn(propsData, key);\r\n    var value = propsData[key];\r\n    // boolean casting\r\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\r\n    if (booleanIndex > -1) {\r\n        if (absent && !hasOwn(prop, 'default')) {\r\n            value = false;\r\n        }\r\n        else if (value === '' || value === hyphenate(key)) {\r\n            // only cast empty string / same name to boolean if\r\n            // boolean has higher priority\r\n            var stringIndex = getTypeIndex(String, prop.type);\r\n            if (stringIndex < 0 || booleanIndex < stringIndex) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    // check default value\r\n    if (value === undefined) {\r\n        value = getPropDefaultValue(vm, prop, key);\r\n        // since the default value is a fresh copy,\r\n        // make sure to observe it.\r\n        var prevShouldObserve = shouldObserve;\r\n        toggleObserving(true);\r\n        observe(value);\r\n        toggleObserving(prevShouldObserve);\r\n    }\r\n    if (false) // removed by dead control flow\n{}\r\n    return value;\r\n}\r\n/**\r\n * Get the default value of a prop.\r\n */\r\nfunction getPropDefaultValue(vm, prop, key) {\r\n    // no default, return undefined\r\n    if (!hasOwn(prop, 'default')) {\r\n        return undefined;\r\n    }\r\n    var def = prop.default;\r\n    // warn against non-factory defaults for Object & Array\r\n    if (false) // removed by dead control flow\n{}\r\n    // the raw prop value was also undefined from previous render,\r\n    // return previous default value to avoid unnecessary watcher trigger\r\n    if (vm &&\r\n        vm.$options.propsData &&\r\n        vm.$options.propsData[key] === undefined &&\r\n        vm._props[key] !== undefined) {\r\n        return vm._props[key];\r\n    }\r\n    // call factory function for non-Function types\r\n    // a value is Function if its prototype is function even across different execution context\r\n    return isFunction(def) && getType(prop.type) !== 'Function'\r\n        ? def.call(vm)\r\n        : def;\r\n}\r\n/**\r\n * Assert whether a prop is valid.\r\n */\r\nfunction assertProp(prop, name, value, vm, absent) {\r\n    if (prop.required && absent) {\r\n        warn$2('Missing required prop: \"' + name + '\"', vm);\r\n        return;\r\n    }\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    var type = prop.type;\r\n    var valid = !type || type === true;\r\n    var expectedTypes = [];\r\n    if (type) {\r\n        if (!isArray(type)) {\r\n            type = [type];\r\n        }\r\n        for (var i = 0; i < type.length && !valid; i++) {\r\n            var assertedType = assertType(value, type[i], vm);\r\n            expectedTypes.push(assertedType.expectedType || '');\r\n            valid = assertedType.valid;\r\n        }\r\n    }\r\n    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });\r\n    if (!valid && haveExpectedTypes) {\r\n        warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);\r\n        return;\r\n    }\r\n    var validator = prop.validator;\r\n    if (validator) {\r\n        if (!validator(value)) {\r\n            warn$2('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\r\n        }\r\n    }\r\n}\r\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\r\nfunction assertType(value, type, vm) {\r\n    var valid;\r\n    var expectedType = getType(type);\r\n    if (simpleCheckRE.test(expectedType)) {\r\n        var t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = isPlainObject(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else {\r\n        try {\r\n            valid = value instanceof type;\r\n        }\r\n        catch (e) {\r\n            warn$2('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\r\n            valid = false;\r\n        }\r\n    }\r\n    return {\r\n        valid: valid,\r\n        expectedType: expectedType\r\n    };\r\n}\r\nvar functionTypeCheckRE = /^\\s*function (\\w+)/;\r\n/**\r\n * Use function string name to check built-in types,\r\n * because a simple equality check will fail when running\r\n * across different vms / iframes.\r\n */\r\nfunction getType(fn) {\r\n    var match = fn && fn.toString().match(functionTypeCheckRE);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (!isArray(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\r\n        if (isSameType(expectedTypes[i], type)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    var message = \"Invalid prop: type check failed for prop \\\"\".concat(name, \"\\\".\") +\r\n        \" Expected \".concat(expectedTypes.map(capitalize).join(', '));\r\n    var expectedType = expectedTypes[0];\r\n    var receivedType = toRawType(value);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        isExplicable(typeof value) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += \" with value \".concat(styleValue(value, expectedType));\r\n    }\r\n    message += \", got \".concat(receivedType, \" \");\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += \"with value \".concat(styleValue(value, receivedType), \".\");\r\n    }\r\n    return message;\r\n}\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return \"\\\"\".concat(value, \"\\\"\");\r\n    }\r\n    else if (type === 'Number') {\r\n        return \"\".concat(Number(value));\r\n    }\r\n    else {\r\n        return \"\".concat(value);\r\n    }\r\n}\r\nvar EXPLICABLE_TYPES = (/* unused pure expression or super */ null && (['string', 'number', 'boolean']));\r\nfunction isExplicable(value) {\r\n    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });\r\n}\r\nfunction isBoolean() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });\r\n}\r\n\r\nfunction Vue(options) {\r\n    if (false) // removed by dead control flow\n{}\r\n    this._init(options);\r\n}\r\n//@ts-expect-error Vue has function type\r\ninitMixin$1(Vue);\r\n//@ts-expect-error Vue has function type\r\nstateMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\neventsMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nlifecycleMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nrenderMixin(Vue);\r\n\r\nfunction initUse(Vue) {\r\n    Vue.use = function (plugin) {\r\n        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\r\n        if (installedPlugins.indexOf(plugin) > -1) {\r\n            return this;\r\n        }\r\n        // additional parameters\r\n        var args = toArray(arguments, 1);\r\n        args.unshift(this);\r\n        if (isFunction(plugin.install)) {\r\n            plugin.install.apply(plugin, args);\r\n        }\r\n        else if (isFunction(plugin)) {\r\n            plugin.apply(null, args);\r\n        }\r\n        installedPlugins.push(plugin);\r\n        return this;\r\n    };\r\n}\r\n\r\nfunction initMixin(Vue) {\r\n    Vue.mixin = function (mixin) {\r\n        this.options = mergeOptions(this.options, mixin);\r\n        return this;\r\n    };\r\n}\r\n\r\nfunction initExtend(Vue) {\r\n    /**\r\n     * Each instance constructor, including Vue, has a unique\r\n     * cid. This enables us to create wrapped \"child\r\n     * constructors\" for prototypal inheritance and cache them.\r\n     */\r\n    Vue.cid = 0;\r\n    var cid = 1;\r\n    /**\r\n     * Class inheritance\r\n     */\r\n    Vue.extend = function (extendOptions) {\r\n        extendOptions = extendOptions || {};\r\n        var Super = this;\r\n        var SuperId = Super.cid;\r\n        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\r\n        if (cachedCtors[SuperId]) {\r\n            return cachedCtors[SuperId];\r\n        }\r\n        var name = getComponentName(extendOptions) || getComponentName(Super.options);\r\n        if (false) // removed by dead control flow\n{}\r\n        var Sub = function VueComponent(options) {\r\n            this._init(options);\r\n        };\r\n        Sub.prototype = Object.create(Super.prototype);\r\n        Sub.prototype.constructor = Sub;\r\n        Sub.cid = cid++;\r\n        Sub.options = mergeOptions(Super.options, extendOptions);\r\n        Sub['super'] = Super;\r\n        // For props and computed properties, we define the proxy getters on\r\n        // the Vue instances at extension time, on the extended prototype. This\r\n        // avoids Object.defineProperty calls for each instance created.\r\n        if (Sub.options.props) {\r\n            initProps(Sub);\r\n        }\r\n        if (Sub.options.computed) {\r\n            initComputed(Sub);\r\n        }\r\n        // allow further extension/mixin/plugin usage\r\n        Sub.extend = Super.extend;\r\n        Sub.mixin = Super.mixin;\r\n        Sub.use = Super.use;\r\n        // create asset registers, so extended classes\r\n        // can have their private assets too.\r\n        ASSET_TYPES.forEach(function (type) {\r\n            Sub[type] = Super[type];\r\n        });\r\n        // enable recursive self-lookup\r\n        if (name) {\r\n            Sub.options.components[name] = Sub;\r\n        }\r\n        // keep a reference to the super options at extension time.\r\n        // later at instantiation we can check if Super's options have\r\n        // been updated.\r\n        Sub.superOptions = Super.options;\r\n        Sub.extendOptions = extendOptions;\r\n        Sub.sealedOptions = extend({}, Sub.options);\r\n        // cache constructor\r\n        cachedCtors[SuperId] = Sub;\r\n        return Sub;\r\n    };\r\n}\r\nfunction initProps(Comp) {\r\n    var props = Comp.options.props;\r\n    for (var key in props) {\r\n        proxy(Comp.prototype, \"_props\", key);\r\n    }\r\n}\r\nfunction initComputed(Comp) {\r\n    var computed = Comp.options.computed;\r\n    for (var key in computed) {\r\n        defineComputed(Comp.prototype, key, computed[key]);\r\n    }\r\n}\r\n\r\nfunction initAssetRegisters(Vue) {\r\n    /**\r\n     * Create asset registration methods.\r\n     */\r\n    ASSET_TYPES.forEach(function (type) {\r\n        // @ts-expect-error function is not exact same type\r\n        Vue[type] = function (id, definition) {\r\n            if (!definition) {\r\n                return this.options[type + 's'][id];\r\n            }\r\n            else {\r\n                /* istanbul ignore if */\r\n                if (false) // removed by dead control flow\n{}\r\n                if (type === 'component' && isPlainObject(definition)) {\r\n                    // @ts-expect-error\r\n                    definition.name = definition.name || id;\r\n                    definition = this.options._base.extend(definition);\r\n                }\r\n                if (type === 'directive' && isFunction(definition)) {\r\n                    definition = { bind: definition, update: definition };\r\n                }\r\n                this.options[type + 's'][id] = definition;\r\n                return definition;\r\n            }\r\n        };\r\n    });\r\n}\r\n\r\nfunction _getComponentName(opts) {\r\n    return opts && (getComponentName(opts.Ctor.options) || opts.tag);\r\n}\r\nfunction matches(pattern, name) {\r\n    if (isArray(pattern)) {\r\n        return pattern.indexOf(name) > -1;\r\n    }\r\n    else if (typeof pattern === 'string') {\r\n        return pattern.split(',').indexOf(name) > -1;\r\n    }\r\n    else if (isRegExp(pattern)) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction pruneCache(keepAliveInstance, filter) {\r\n    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode, $vnode = keepAliveInstance.$vnode;\r\n    for (var key in cache) {\r\n        var entry = cache[key];\r\n        if (entry) {\r\n            var name_1 = entry.name;\r\n            if (name_1 && !filter(name_1)) {\r\n                pruneCacheEntry(cache, key, keys, _vnode);\r\n            }\r\n        }\r\n    }\r\n    $vnode.componentOptions.children = undefined;\r\n}\r\nfunction pruneCacheEntry(cache, key, keys, current) {\r\n    var entry = cache[key];\r\n    if (entry && (!current || entry.tag !== current.tag)) {\r\n        // @ts-expect-error can be undefined\r\n        entry.componentInstance.$destroy();\r\n    }\r\n    cache[key] = null;\r\n    remove$2(keys, key);\r\n}\r\nvar patternTypes = [String, RegExp, Array];\r\n// TODO defineComponent\r\nvar KeepAlive = {\r\n    name: 'keep-alive',\r\n    abstract: true,\r\n    props: {\r\n        include: patternTypes,\r\n        exclude: patternTypes,\r\n        max: [String, Number]\r\n    },\r\n    methods: {\r\n        cacheVNode: function () {\r\n            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;\r\n            if (vnodeToCache) {\r\n                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;\r\n                cache[keyToCache] = {\r\n                    name: _getComponentName(componentOptions),\r\n                    tag: tag,\r\n                    componentInstance: componentInstance\r\n                };\r\n                keys.push(keyToCache);\r\n                // prune oldest entry\r\n                if (this.max && keys.length > parseInt(this.max)) {\r\n                    pruneCacheEntry(cache, keys[0], keys, this._vnode);\r\n                }\r\n                this.vnodeToCache = null;\r\n            }\r\n        }\r\n    },\r\n    created: function () {\r\n        this.cache = Object.create(null);\r\n        this.keys = [];\r\n    },\r\n    destroyed: function () {\r\n        for (var key in this.cache) {\r\n            pruneCacheEntry(this.cache, key, this.keys);\r\n        }\r\n    },\r\n    mounted: function () {\r\n        var _this = this;\r\n        this.cacheVNode();\r\n        this.$watch('include', function (val) {\r\n            pruneCache(_this, function (name) { return matches(val, name); });\r\n        });\r\n        this.$watch('exclude', function (val) {\r\n            pruneCache(_this, function (name) { return !matches(val, name); });\r\n        });\r\n    },\r\n    updated: function () {\r\n        this.cacheVNode();\r\n    },\r\n    render: function () {\r\n        var slot = this.$slots.default;\r\n        var vnode = getFirstComponentChild(slot);\r\n        var componentOptions = vnode && vnode.componentOptions;\r\n        if (componentOptions) {\r\n            // check pattern\r\n            var name_2 = _getComponentName(componentOptions);\r\n            var _a = this, include = _a.include, exclude = _a.exclude;\r\n            if (\r\n            // not included\r\n            (include && (!name_2 || !matches(include, name_2))) ||\r\n                // excluded\r\n                (exclude && name_2 && matches(exclude, name_2))) {\r\n                return vnode;\r\n            }\r\n            var _b = this, cache = _b.cache, keys = _b.keys;\r\n            var key = vnode.key == null\r\n                ? // same constructor may get registered as different local components\r\n                    // so cid alone is not enough (#3269)\r\n                    componentOptions.Ctor.cid +\r\n                        (componentOptions.tag ? \"::\".concat(componentOptions.tag) : '')\r\n                : vnode.key;\r\n            if (cache[key]) {\r\n                vnode.componentInstance = cache[key].componentInstance;\r\n                // make current key freshest\r\n                remove$2(keys, key);\r\n                keys.push(key);\r\n            }\r\n            else {\r\n                // delay setting the cache until update\r\n                this.vnodeToCache = vnode;\r\n                this.keyToCache = key;\r\n            }\r\n            // @ts-expect-error can vnode.data can be undefined\r\n            vnode.data.keepAlive = true;\r\n        }\r\n        return vnode || (slot && slot[0]);\r\n    }\r\n};\r\n\r\nvar builtInComponents = {\r\n    KeepAlive: KeepAlive\r\n};\r\n\r\nfunction initGlobalAPI(Vue) {\r\n    // config\r\n    var configDef = {};\r\n    configDef.get = function () { return config; };\r\n    if (false) // removed by dead control flow\n{}\r\n    Object.defineProperty(Vue, 'config', configDef);\r\n    // exposed util methods.\r\n    // NOTE: these are not considered part of the public API - avoid relying on\r\n    // them unless you are aware of the risk.\r\n    Vue.util = {\r\n        warn: warn$2,\r\n        extend: extend,\r\n        mergeOptions: mergeOptions,\r\n        defineReactive: defineReactive\r\n    };\r\n    Vue.set = set;\r\n    Vue.delete = del;\r\n    Vue.nextTick = nextTick;\r\n    // 2.6 explicit observable API\r\n    Vue.observable = function (obj) {\r\n        observe(obj);\r\n        return obj;\r\n    };\r\n    Vue.options = Object.create(null);\r\n    ASSET_TYPES.forEach(function (type) {\r\n        Vue.options[type + 's'] = Object.create(null);\r\n    });\r\n    // this is used to identify the \"base\" constructor to extend all plain-object\r\n    // components with in Weex's multi-instance scenarios.\r\n    Vue.options._base = Vue;\r\n    extend(Vue.options.components, builtInComponents);\r\n    initUse(Vue);\r\n    initMixin(Vue);\r\n    initExtend(Vue);\r\n    initAssetRegisters(Vue);\r\n}\r\n\r\ninitGlobalAPI(Vue);\r\nObject.defineProperty(Vue.prototype, '$isServer', {\r\n    get: isServerRendering\r\n});\r\nObject.defineProperty(Vue.prototype, '$ssrContext', {\r\n    get: function () {\r\n        /* istanbul ignore next */\r\n        return this.$vnode && this.$vnode.ssrContext;\r\n    }\r\n});\r\n// expose FunctionalRenderContext for ssr runtime helper installation\r\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\r\n    value: FunctionalRenderContext\r\n});\r\nVue.version = version;\r\n\r\n// these are reserved for web because they are directly compiled away\r\n// during template compilation\r\nvar isReservedAttr = makeMap('style,class');\r\n// attributes that should be using props for binding\r\nvar acceptValue = makeMap('input,textarea,option,select,progress');\r\nvar mustUseProp = function (tag, type, attr) {\r\n    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||\r\n        (attr === 'selected' && tag === 'option') ||\r\n        (attr === 'checked' && tag === 'input') ||\r\n        (attr === 'muted' && tag === 'video'));\r\n};\r\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\r\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\r\nvar convertEnumeratedValue = function (key, value) {\r\n    return isFalsyAttrValue(value) || value === 'false'\r\n        ? 'false'\r\n        : // allow arbitrary string value for contenteditable\r\n            key === 'contenteditable' && isValidContentEditableValue(value)\r\n                ? value\r\n                : 'true';\r\n};\r\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\r\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\r\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\r\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\r\n    'required,reversed,scoped,seamless,selected,sortable,' +\r\n    'truespeed,typemustmatch,visible');\r\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\r\nvar isXlink = function (name) {\r\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\r\n};\r\nvar getXlinkProp = function (name) {\r\n    return isXlink(name) ? name.slice(6, name.length) : '';\r\n};\r\nvar isFalsyAttrValue = function (val) {\r\n    return val == null || val === false;\r\n};\r\n\r\nfunction genClassForVnode(vnode) {\r\n    var data = vnode.data;\r\n    var parentNode = vnode;\r\n    var childNode = vnode;\r\n    while (isDef(childNode.componentInstance)) {\r\n        childNode = childNode.componentInstance._vnode;\r\n        if (childNode && childNode.data) {\r\n            data = mergeClassData(childNode.data, data);\r\n        }\r\n    }\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while (isDef((parentNode = parentNode.parent))) {\r\n        if (parentNode && parentNode.data) {\r\n            data = mergeClassData(data, parentNode.data);\r\n        }\r\n    }\r\n    return renderClass(data.staticClass, data.class);\r\n}\r\nfunction mergeClassData(child, parent) {\r\n    return {\r\n        staticClass: concat(child.staticClass, parent.staticClass),\r\n        class: isDef(child.class) ? [child.class, parent.class] : parent.class\r\n    };\r\n}\r\nfunction renderClass(staticClass, dynamicClass) {\r\n    if (isDef(staticClass) || isDef(dynamicClass)) {\r\n        return concat(staticClass, stringifyClass(dynamicClass));\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction concat(a, b) {\r\n    return a ? (b ? a + ' ' + b : a) : b || '';\r\n}\r\nfunction stringifyClass(value) {\r\n    if (Array.isArray(value)) {\r\n        return stringifyArray(value);\r\n    }\r\n    if (isObject(value)) {\r\n        return stringifyObject(value);\r\n    }\r\n    if (typeof value === 'string') {\r\n        return value;\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction stringifyArray(value) {\r\n    var res = '';\r\n    var stringified;\r\n    for (var i = 0, l = value.length; i < l; i++) {\r\n        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {\r\n            if (res)\r\n                res += ' ';\r\n            res += stringified;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction stringifyObject(value) {\r\n    var res = '';\r\n    for (var key in value) {\r\n        if (value[key]) {\r\n            if (res)\r\n                res += ' ';\r\n            res += key;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvar namespaceMap = {\r\n    svg: 'http://www.w3.org/2000/svg',\r\n    math: 'http://www.w3.org/1998/Math/MathML'\r\n};\r\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +\r\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\r\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\r\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\r\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\r\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\r\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\r\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\r\n    'output,progress,select,textarea,' +\r\n    'details,dialog,menu,menuitem,summary,' +\r\n    'content,element,shadow,template,blockquote,iframe,tfoot');\r\n// this map is intentionally selective, only covering SVG elements that may\r\n// contain child elements.\r\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\r\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\r\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\r\nvar isPreTag = function (tag) { return tag === 'pre'; };\r\nvar isReservedTag = function (tag) {\r\n    return isHTMLTag(tag) || isSVG(tag);\r\n};\r\nfunction getTagNamespace(tag) {\r\n    if (isSVG(tag)) {\r\n        return 'svg';\r\n    }\r\n    // basic support for MathML\r\n    // note it doesn't support other MathML elements being component roots\r\n    if (tag === 'math') {\r\n        return 'math';\r\n    }\r\n}\r\nvar unknownElementCache = Object.create(null);\r\nfunction isUnknownElement(tag) {\r\n    /* istanbul ignore if */\r\n    if (!inBrowser) {\r\n        return true;\r\n    }\r\n    if (isReservedTag(tag)) {\r\n        return false;\r\n    }\r\n    tag = tag.toLowerCase();\r\n    /* istanbul ignore if */\r\n    if (unknownElementCache[tag] != null) {\r\n        return unknownElementCache[tag];\r\n    }\r\n    var el = document.createElement(tag);\r\n    if (tag.indexOf('-') > -1) {\r\n        // https://stackoverflow.com/a/28210364/1070244\r\n        return (unknownElementCache[tag] =\r\n            el.constructor === window.HTMLUnknownElement ||\r\n                el.constructor === window.HTMLElement);\r\n    }\r\n    else {\r\n        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));\r\n    }\r\n}\r\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\r\n\r\n/**\r\n * Query an element selector if it's not an element already.\r\n */\r\nfunction query(el) {\r\n    if (typeof el === 'string') {\r\n        var selected = document.querySelector(el);\r\n        if (!selected) {\r\n             false && 0;\r\n            return document.createElement('div');\r\n        }\r\n        return selected;\r\n    }\r\n    else {\r\n        return el;\r\n    }\r\n}\r\n\r\nfunction createElement(tagName, vnode) {\r\n    var elm = document.createElement(tagName);\r\n    if (tagName !== 'select') {\r\n        return elm;\r\n    }\r\n    // false or null will remove the attribute but undefined will not\r\n    if (vnode.data &&\r\n        vnode.data.attrs &&\r\n        vnode.data.attrs.multiple !== undefined) {\r\n        elm.setAttribute('multiple', 'multiple');\r\n    }\r\n    return elm;\r\n}\r\nfunction createElementNS(namespace, tagName) {\r\n    return document.createElementNS(namespaceMap[namespace], tagName);\r\n}\r\nfunction createTextNode(text) {\r\n    return document.createTextNode(text);\r\n}\r\nfunction createComment(text) {\r\n    return document.createComment(text);\r\n}\r\nfunction insertBefore(parentNode, newNode, referenceNode) {\r\n    parentNode.insertBefore(newNode, referenceNode);\r\n}\r\nfunction removeChild(node, child) {\r\n    node.removeChild(child);\r\n}\r\nfunction appendChild(node, child) {\r\n    node.appendChild(child);\r\n}\r\nfunction parentNode(node) {\r\n    return node.parentNode;\r\n}\r\nfunction nextSibling(node) {\r\n    return node.nextSibling;\r\n}\r\nfunction tagName(node) {\r\n    return node.tagName;\r\n}\r\nfunction setTextContent(node, text) {\r\n    node.textContent = text;\r\n}\r\nfunction setStyleScope(node, scopeId) {\r\n    node.setAttribute(scopeId, '');\r\n}\r\n\r\nvar nodeOps = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  createElement: createElement,\r\n  createElementNS: createElementNS,\r\n  createTextNode: createTextNode,\r\n  createComment: createComment,\r\n  insertBefore: insertBefore,\r\n  removeChild: removeChild,\r\n  appendChild: appendChild,\r\n  parentNode: parentNode,\r\n  nextSibling: nextSibling,\r\n  tagName: tagName,\r\n  setTextContent: setTextContent,\r\n  setStyleScope: setStyleScope\r\n});\r\n\r\nvar ref = {\r\n    create: function (_, vnode) {\r\n        registerRef(vnode);\r\n    },\r\n    update: function (oldVnode, vnode) {\r\n        if (oldVnode.data.ref !== vnode.data.ref) {\r\n            registerRef(oldVnode, true);\r\n            registerRef(vnode);\r\n        }\r\n    },\r\n    destroy: function (vnode) {\r\n        registerRef(vnode, true);\r\n    }\r\n};\r\nfunction registerRef(vnode, isRemoval) {\r\n    var ref = vnode.data.ref;\r\n    if (!isDef(ref))\r\n        return;\r\n    var vm = vnode.context;\r\n    var refValue = vnode.componentInstance || vnode.elm;\r\n    var value = isRemoval ? null : refValue;\r\n    var $refsValue = isRemoval ? undefined : refValue;\r\n    if (isFunction(ref)) {\r\n        invokeWithErrorHandling(ref, vm, [value], vm, \"template ref function\");\r\n        return;\r\n    }\r\n    var isFor = vnode.data.refInFor;\r\n    var _isString = typeof ref === 'string' || typeof ref === 'number';\r\n    var _isRef = isRef(ref);\r\n    var refs = vm.$refs;\r\n    if (_isString || _isRef) {\r\n        if (isFor) {\r\n            var existing = _isString ? refs[ref] : ref.value;\r\n            if (isRemoval) {\r\n                isArray(existing) && remove$2(existing, refValue);\r\n            }\r\n            else {\r\n                if (!isArray(existing)) {\r\n                    if (_isString) {\r\n                        refs[ref] = [refValue];\r\n                        setSetupRef(vm, ref, refs[ref]);\r\n                    }\r\n                    else {\r\n                        ref.value = [refValue];\r\n                    }\r\n                }\r\n                else if (!existing.includes(refValue)) {\r\n                    existing.push(refValue);\r\n                }\r\n            }\r\n        }\r\n        else if (_isString) {\r\n            if (isRemoval && refs[ref] !== refValue) {\r\n                return;\r\n            }\r\n            refs[ref] = $refsValue;\r\n            setSetupRef(vm, ref, value);\r\n        }\r\n        else if (_isRef) {\r\n            if (isRemoval && ref.value !== refValue) {\r\n                return;\r\n            }\r\n            ref.value = value;\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n}\r\nfunction setSetupRef(_a, key, val) {\r\n    var _setupState = _a._setupState;\r\n    if (_setupState && hasOwn(_setupState, key)) {\r\n        if (isRef(_setupState[key])) {\r\n            _setupState[key].value = val;\r\n        }\r\n        else {\r\n            _setupState[key] = val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Virtual DOM patching algorithm based on Snabbdom by\r\n * Simon Friis Vindum (@paldepind)\r\n * Licensed under the MIT License\r\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\r\n *\r\n * modified by Evan You (@yyx990803)\r\n *\r\n * Not type-checking this because this file is perf-critical and the cost\r\n * of making flow understand it is not worth it.\r\n */\r\nvar emptyNode = new VNode('', {}, []);\r\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\r\nfunction sameVnode(a, b) {\r\n    return (a.key === b.key &&\r\n        a.asyncFactory === b.asyncFactory &&\r\n        ((a.tag === b.tag &&\r\n            a.isComment === b.isComment &&\r\n            isDef(a.data) === isDef(b.data) &&\r\n            sameInputType(a, b)) ||\r\n            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));\r\n}\r\nfunction sameInputType(a, b) {\r\n    if (a.tag !== 'input')\r\n        return true;\r\n    var i;\r\n    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;\r\n    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;\r\n    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));\r\n}\r\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\r\n    var i, key;\r\n    var map = {};\r\n    for (i = beginIdx; i <= endIdx; ++i) {\r\n        key = children[i].key;\r\n        if (isDef(key))\r\n            map[key] = i;\r\n    }\r\n    return map;\r\n}\r\nfunction createPatchFunction(backend) {\r\n    var i, j;\r\n    var cbs = {};\r\n    var modules = backend.modules, nodeOps = backend.nodeOps;\r\n    for (i = 0; i < hooks.length; ++i) {\r\n        cbs[hooks[i]] = [];\r\n        for (j = 0; j < modules.length; ++j) {\r\n            if (isDef(modules[j][hooks[i]])) {\r\n                cbs[hooks[i]].push(modules[j][hooks[i]]);\r\n            }\r\n        }\r\n    }\r\n    function emptyNodeAt(elm) {\r\n        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\r\n    }\r\n    function createRmCb(childElm, listeners) {\r\n        function remove() {\r\n            if (--remove.listeners === 0) {\r\n                removeNode(childElm);\r\n            }\r\n        }\r\n        remove.listeners = listeners;\r\n        return remove;\r\n    }\r\n    function removeNode(el) {\r\n        var parent = nodeOps.parentNode(el);\r\n        // element may have already been removed due to v-html / v-text\r\n        if (isDef(parent)) {\r\n            nodeOps.removeChild(parent, el);\r\n        }\r\n    }\r\n    function isUnknownElement(vnode, inVPre) {\r\n        return (!inVPre &&\r\n            !vnode.ns &&\r\n            !(config.ignoredElements.length &&\r\n                config.ignoredElements.some(function (ignore) {\r\n                    return isRegExp(ignore)\r\n                        ? ignore.test(vnode.tag)\r\n                        : ignore === vnode.tag;\r\n                })) &&\r\n            config.isUnknownElement(vnode.tag));\r\n    }\r\n    var creatingElmInVPre = 0;\r\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // This vnode was used in a previous render!\r\n            // now it's used as a new node, overwriting its elm would cause\r\n            // potential patch errors down the road when it's used as an insertion\r\n            // reference node. Instead, we clone the node on-demand before creating\r\n            // associated DOM element for it.\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        vnode.isRootInsert = !nested; // for transition enter check\r\n        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\r\n            return;\r\n        }\r\n        var data = vnode.data;\r\n        var children = vnode.children;\r\n        var tag = vnode.tag;\r\n        if (isDef(tag)) {\r\n            if (false) // removed by dead control flow\n{}\r\n            vnode.elm = vnode.ns\r\n                ? nodeOps.createElementNS(vnode.ns, tag)\r\n                : nodeOps.createElement(tag, vnode);\r\n            setScope(vnode);\r\n            createChildren(vnode, children, insertedVnodeQueue);\r\n            if (isDef(data)) {\r\n                invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            }\r\n            insert(parentElm, vnode.elm, refElm);\r\n            if (false) // removed by dead control flow\n{}\r\n        }\r\n        else if (isTrue(vnode.isComment)) {\r\n            vnode.elm = nodeOps.createComment(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n        else {\r\n            vnode.elm = nodeOps.createTextNode(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n    }\r\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        var i = vnode.data;\r\n        if (isDef(i)) {\r\n            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\r\n            if (isDef((i = i.hook)) && isDef((i = i.init))) {\r\n                i(vnode, false /* hydrating */);\r\n            }\r\n            // after calling the init hook, if the vnode is a child component\r\n            // it should've created a child instance and mounted it. the child\r\n            // component also has set the placeholder vnode's elm.\r\n            // in that case we can just return the element and be done.\r\n            if (isDef(vnode.componentInstance)) {\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                insert(parentElm, vnode.elm, refElm);\r\n                if (isTrue(isReactivated)) {\r\n                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    function initComponent(vnode, insertedVnodeQueue) {\r\n        if (isDef(vnode.data.pendingInsert)) {\r\n            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\r\n            vnode.data.pendingInsert = null;\r\n        }\r\n        vnode.elm = vnode.componentInstance.$el;\r\n        if (isPatchable(vnode)) {\r\n            invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            setScope(vnode);\r\n        }\r\n        else {\r\n            // empty component root.\r\n            // skip all element-related modules except for ref (#3455)\r\n            registerRef(vnode);\r\n            // make sure to invoke the insert hook\r\n            insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        var i;\r\n        // hack for #4339: a reactivated component with inner transition\r\n        // does not trigger because the inner node's created hooks are not called\r\n        // again. It's not ideal to involve module-specific logic in here but\r\n        // there doesn't seem to be a better way to do it.\r\n        var innerNode = vnode;\r\n        while (innerNode.componentInstance) {\r\n            innerNode = innerNode.componentInstance._vnode;\r\n            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {\r\n                for (i = 0; i < cbs.activate.length; ++i) {\r\n                    cbs.activate[i](emptyNode, innerNode);\r\n                }\r\n                insertedVnodeQueue.push(innerNode);\r\n                break;\r\n            }\r\n        }\r\n        // unlike a newly created component,\r\n        // a reactivated keep-alive component doesn't insert itself\r\n        insert(parentElm, vnode.elm, refElm);\r\n    }\r\n    function insert(parent, elm, ref) {\r\n        if (isDef(parent)) {\r\n            if (isDef(ref)) {\r\n                if (nodeOps.parentNode(ref) === parent) {\r\n                    nodeOps.insertBefore(parent, elm, ref);\r\n                }\r\n            }\r\n            else {\r\n                nodeOps.appendChild(parent, elm);\r\n            }\r\n        }\r\n    }\r\n    function createChildren(vnode, children, insertedVnodeQueue) {\r\n        if (isArray(children)) {\r\n            if (false) // removed by dead control flow\n{}\r\n            for (var i_1 = 0; i_1 < children.length; ++i_1) {\r\n                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);\r\n            }\r\n        }\r\n        else if (isPrimitive(vnode.text)) {\r\n            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\r\n        }\r\n    }\r\n    function isPatchable(vnode) {\r\n        while (vnode.componentInstance) {\r\n            vnode = vnode.componentInstance._vnode;\r\n        }\r\n        return isDef(vnode.tag);\r\n    }\r\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\r\n        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {\r\n            cbs.create[i_2](emptyNode, vnode);\r\n        }\r\n        i = vnode.data.hook; // Reuse variable\r\n        if (isDef(i)) {\r\n            if (isDef(i.create))\r\n                i.create(emptyNode, vnode);\r\n            if (isDef(i.insert))\r\n                insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    // set scope id attribute for scoped CSS.\r\n    // this is implemented as a special case to avoid the overhead\r\n    // of going through the normal attribute patching process.\r\n    function setScope(vnode) {\r\n        var i;\r\n        if (isDef((i = vnode.fnScopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n        else {\r\n            var ancestor = vnode;\r\n            while (ancestor) {\r\n                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {\r\n                    nodeOps.setStyleScope(vnode.elm, i);\r\n                }\r\n                ancestor = ancestor.parent;\r\n            }\r\n        }\r\n        // for slot content they should also get the scopeId from the host instance.\r\n        if (isDef((i = activeInstance)) &&\r\n            i !== vnode.context &&\r\n            i !== vnode.fnContext &&\r\n            isDef((i = i.$options._scopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n    }\r\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\r\n        }\r\n    }\r\n    function invokeDestroyHook(vnode) {\r\n        var i, j;\r\n        var data = vnode.data;\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.destroy)))\r\n                i(vnode);\r\n            for (i = 0; i < cbs.destroy.length; ++i)\r\n                cbs.destroy[i](vnode);\r\n        }\r\n        if (isDef((i = vnode.children))) {\r\n            for (j = 0; j < vnode.children.length; ++j) {\r\n                invokeDestroyHook(vnode.children[j]);\r\n            }\r\n        }\r\n    }\r\n    function removeVnodes(vnodes, startIdx, endIdx) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            var ch = vnodes[startIdx];\r\n            if (isDef(ch)) {\r\n                if (isDef(ch.tag)) {\r\n                    removeAndInvokeRemoveHook(ch);\r\n                    invokeDestroyHook(ch);\r\n                }\r\n                else {\r\n                    // Text node\r\n                    removeNode(ch.elm);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function removeAndInvokeRemoveHook(vnode, rm) {\r\n        if (isDef(rm) || isDef(vnode.data)) {\r\n            var i_3;\r\n            var listeners = cbs.remove.length + 1;\r\n            if (isDef(rm)) {\r\n                // we have a recursively passed down rm callback\r\n                // increase the listeners count\r\n                rm.listeners += listeners;\r\n            }\r\n            else {\r\n                // directly removing\r\n                rm = createRmCb(vnode.elm, listeners);\r\n            }\r\n            // recursively invoke hooks on child component root node\r\n            if (isDef((i_3 = vnode.componentInstance)) &&\r\n                isDef((i_3 = i_3._vnode)) &&\r\n                isDef(i_3.data)) {\r\n                removeAndInvokeRemoveHook(i_3, rm);\r\n            }\r\n            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {\r\n                cbs.remove[i_3](vnode, rm);\r\n            }\r\n            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {\r\n                i_3(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n        else {\r\n            removeNode(vnode.elm);\r\n        }\r\n    }\r\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\r\n        var oldStartIdx = 0;\r\n        var newStartIdx = 0;\r\n        var oldEndIdx = oldCh.length - 1;\r\n        var oldStartVnode = oldCh[0];\r\n        var oldEndVnode = oldCh[oldEndIdx];\r\n        var newEndIdx = newCh.length - 1;\r\n        var newStartVnode = newCh[0];\r\n        var newEndVnode = newCh[newEndIdx];\r\n        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\r\n        // removeOnly is a special flag used only by <transition-group>\r\n        // to ensure removed elements stay in correct relative positions\r\n        // during leaving transitions\r\n        var canMove = !removeOnly;\r\n        if (false) // removed by dead control flow\n{}\r\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n            if (isUndef(oldStartVnode)) {\r\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\r\n            }\r\n            else if (isUndef(oldEndVnode)) {\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n                // Vnode moved right\r\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n                // Vnode moved left\r\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else {\r\n                if (isUndef(oldKeyToIdx))\r\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n                idxInOld = isDef(newStartVnode.key)\r\n                    ? oldKeyToIdx[newStartVnode.key]\r\n                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\r\n                if (isUndef(idxInOld)) {\r\n                    // New element\r\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                }\r\n                else {\r\n                    vnodeToMove = oldCh[idxInOld];\r\n                    if (sameVnode(vnodeToMove, newStartVnode)) {\r\n                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                        oldCh[idxInOld] = undefined;\r\n                        canMove &&\r\n                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\r\n                    }\r\n                    else {\r\n                        // same key but different element. treat as new element\r\n                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                    }\r\n                }\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n        }\r\n        if (oldStartIdx > oldEndIdx) {\r\n            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\r\n            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\r\n        }\r\n        else if (newStartIdx > newEndIdx) {\r\n            removeVnodes(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n    }\r\n    function checkDuplicateKeys(children) {\r\n        var seenKeys = {};\r\n        for (var i_4 = 0; i_4 < children.length; i_4++) {\r\n            var vnode = children[i_4];\r\n            var key = vnode.key;\r\n            if (isDef(key)) {\r\n                if (seenKeys[key]) {\r\n                    warn$2(\"Duplicate keys detected: '\".concat(key, \"'. This may cause an update error.\"), vnode.context);\r\n                }\r\n                else {\r\n                    seenKeys[key] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function findIdxInOld(node, oldCh, start, end) {\r\n        for (var i_5 = start; i_5 < end; i_5++) {\r\n            var c = oldCh[i_5];\r\n            if (isDef(c) && sameVnode(node, c))\r\n                return i_5;\r\n        }\r\n    }\r\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\r\n        if (oldVnode === vnode) {\r\n            return;\r\n        }\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // clone reused vnode\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        var elm = (vnode.elm = oldVnode.elm);\r\n        if (isTrue(oldVnode.isAsyncPlaceholder)) {\r\n            if (isDef(vnode.asyncFactory.resolved)) {\r\n                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\r\n            }\r\n            else {\r\n                vnode.isAsyncPlaceholder = true;\r\n            }\r\n            return;\r\n        }\r\n        // reuse element for static trees.\r\n        // note we only do this if the vnode is cloned -\r\n        // if the new node is not cloned it means the render functions have been\r\n        // reset by the hot-reload-api and we need to do a proper re-render.\r\n        if (isTrue(vnode.isStatic) &&\r\n            isTrue(oldVnode.isStatic) &&\r\n            vnode.key === oldVnode.key &&\r\n            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\r\n            vnode.componentInstance = oldVnode.componentInstance;\r\n            return;\r\n        }\r\n        var i;\r\n        var data = vnode.data;\r\n        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {\r\n            i(oldVnode, vnode);\r\n        }\r\n        var oldCh = oldVnode.children;\r\n        var ch = vnode.children;\r\n        if (isDef(data) && isPatchable(vnode)) {\r\n            for (i = 0; i < cbs.update.length; ++i)\r\n                cbs.update[i](oldVnode, vnode);\r\n            if (isDef((i = data.hook)) && isDef((i = i.update)))\r\n                i(oldVnode, vnode);\r\n        }\r\n        if (isUndef(vnode.text)) {\r\n            if (isDef(oldCh) && isDef(ch)) {\r\n                if (oldCh !== ch)\r\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\r\n            }\r\n            else if (isDef(ch)) {\r\n                if (false) // removed by dead control flow\n{}\r\n                if (isDef(oldVnode.text))\r\n                    nodeOps.setTextContent(elm, '');\r\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n            }\r\n            else if (isDef(oldCh)) {\r\n                removeVnodes(oldCh, 0, oldCh.length - 1);\r\n            }\r\n            else if (isDef(oldVnode.text)) {\r\n                nodeOps.setTextContent(elm, '');\r\n            }\r\n        }\r\n        else if (oldVnode.text !== vnode.text) {\r\n            nodeOps.setTextContent(elm, vnode.text);\r\n        }\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))\r\n                i(oldVnode, vnode);\r\n        }\r\n    }\r\n    function invokeInsertHook(vnode, queue, initial) {\r\n        // delay insert hooks for component root nodes, invoke them after the\r\n        // element is really inserted\r\n        if (isTrue(initial) && isDef(vnode.parent)) {\r\n            vnode.parent.data.pendingInsert = queue;\r\n        }\r\n        else {\r\n            for (var i_6 = 0; i_6 < queue.length; ++i_6) {\r\n                queue[i_6].data.hook.insert(queue[i_6]);\r\n            }\r\n        }\r\n    }\r\n    var hydrationBailed = false;\r\n    // list of modules that can skip create hook during hydration because they\r\n    // are already rendered on the client or has no need for initialization\r\n    // Note: style is excluded because it relies on initial clone for future\r\n    // deep updates (#7063).\r\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\r\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\r\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\r\n        var i;\r\n        var tag = vnode.tag, data = vnode.data, children = vnode.children;\r\n        inVPre = inVPre || (data && data.pre);\r\n        vnode.elm = elm;\r\n        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\r\n            vnode.isAsyncPlaceholder = true;\r\n            return true;\r\n        }\r\n        // assert node match\r\n        if (false) // removed by dead control flow\n{}\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.init)))\r\n                i(vnode, true /* hydrating */);\r\n            if (isDef((i = vnode.componentInstance))) {\r\n                // child component. it should have hydrated its own tree.\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                return true;\r\n            }\r\n        }\r\n        if (isDef(tag)) {\r\n            if (isDef(children)) {\r\n                // empty element, allow client to pick up and populate children\r\n                if (!elm.hasChildNodes()) {\r\n                    createChildren(vnode, children, insertedVnodeQueue);\r\n                }\r\n                else {\r\n                    // v-html and domProps: innerHTML\r\n                    if (isDef((i = data)) &&\r\n                        isDef((i = i.domProps)) &&\r\n                        isDef((i = i.innerHTML))) {\r\n                        if (i !== elm.innerHTML) {\r\n                            /* istanbul ignore if */\r\n                            if (false) // removed by dead control flow\n{}\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // iterate and compare children lists\r\n                        var childrenMatch = true;\r\n                        var childNode = elm.firstChild;\r\n                        for (var i_7 = 0; i_7 < children.length; i_7++) {\r\n                            if (!childNode ||\r\n                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {\r\n                                childrenMatch = false;\r\n                                break;\r\n                            }\r\n                            childNode = childNode.nextSibling;\r\n                        }\r\n                        // if childNode is not null, it means the actual childNodes list is\r\n                        // longer than the virtual children list.\r\n                        if (!childrenMatch || childNode) {\r\n                            /* istanbul ignore if */\r\n                            if (false) // removed by dead control flow\n{}\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isDef(data)) {\r\n                var fullInvoke = false;\r\n                for (var key in data) {\r\n                    if (!isRenderedModule(key)) {\r\n                        fullInvoke = true;\r\n                        invokeCreateHooks(vnode, insertedVnodeQueue);\r\n                        break;\r\n                    }\r\n                }\r\n                if (!fullInvoke && data['class']) {\r\n                    // ensure collecting deps for deep class bindings for future updates\r\n                    traverse(data['class']);\r\n                }\r\n            }\r\n        }\r\n        else if (elm.data !== vnode.text) {\r\n            elm.data = vnode.text;\r\n        }\r\n        return true;\r\n    }\r\n    function assertNodeMatch(node, vnode, inVPre) {\r\n        if (isDef(vnode.tag)) {\r\n            return (vnode.tag.indexOf('vue-component') === 0 ||\r\n                (!isUnknownElement(vnode, inVPre) &&\r\n                    vnode.tag.toLowerCase() ===\r\n                        (node.tagName && node.tagName.toLowerCase())));\r\n        }\r\n        else {\r\n            return node.nodeType === (vnode.isComment ? 8 : 3);\r\n        }\r\n    }\r\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\r\n        if (isUndef(vnode)) {\r\n            if (isDef(oldVnode))\r\n                invokeDestroyHook(oldVnode);\r\n            return;\r\n        }\r\n        var isInitialPatch = false;\r\n        var insertedVnodeQueue = [];\r\n        if (isUndef(oldVnode)) {\r\n            // empty mount (likely as component), create new root element\r\n            isInitialPatch = true;\r\n            createElm(vnode, insertedVnodeQueue);\r\n        }\r\n        else {\r\n            var isRealElement = isDef(oldVnode.nodeType);\r\n            if (!isRealElement && sameVnode(oldVnode, vnode)) {\r\n                // patch existing root node\r\n                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\r\n            }\r\n            else {\r\n                if (isRealElement) {\r\n                    // mounting to a real element\r\n                    // check if this is server-rendered content and if we can perform\r\n                    // a successful hydration.\r\n                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\r\n                        oldVnode.removeAttribute(SSR_ATTR);\r\n                        hydrating = true;\r\n                    }\r\n                    if (isTrue(hydrating)) {\r\n                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\r\n                            invokeInsertHook(vnode, insertedVnodeQueue, true);\r\n                            return oldVnode;\r\n                        }\r\n                        else if (false) // removed by dead control flow\n{}\r\n                    }\r\n                    // either not server-rendered, or hydration failed.\r\n                    // create an empty node and replace it\r\n                    oldVnode = emptyNodeAt(oldVnode);\r\n                }\r\n                // replacing existing element\r\n                var oldElm = oldVnode.elm;\r\n                var parentElm = nodeOps.parentNode(oldElm);\r\n                // create new node\r\n                createElm(vnode, insertedVnodeQueue, \r\n                // extremely rare edge case: do not insert if old element is in a\r\n                // leaving transition. Only happens when combining transition +\r\n                // keep-alive + HOCs. (#4590)\r\n                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));\r\n                // update parent placeholder node element, recursively\r\n                if (isDef(vnode.parent)) {\r\n                    var ancestor = vnode.parent;\r\n                    var patchable = isPatchable(vnode);\r\n                    while (ancestor) {\r\n                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {\r\n                            cbs.destroy[i_8](ancestor);\r\n                        }\r\n                        ancestor.elm = vnode.elm;\r\n                        if (patchable) {\r\n                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {\r\n                                cbs.create[i_9](emptyNode, ancestor);\r\n                            }\r\n                            // #6513\r\n                            // invoke insert hooks that may have been merged by create hooks.\r\n                            // e.g. for directives that uses the \"inserted\" hook.\r\n                            var insert_1 = ancestor.data.hook.insert;\r\n                            if (insert_1.merged) {\r\n                                // start at index 1 to avoid re-invoking component mounted hook\r\n                                // clone insert hooks to avoid being mutated during iteration.\r\n                                // e.g. for customed directives under transition group.\r\n                                var cloned = insert_1.fns.slice(1);\r\n                                for (var i_10 = 0; i_10 < cloned.length; i_10++) {\r\n                                    cloned[i_10]();\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            registerRef(ancestor);\r\n                        }\r\n                        ancestor = ancestor.parent;\r\n                    }\r\n                }\r\n                // destroy old node\r\n                if (isDef(parentElm)) {\r\n                    removeVnodes([oldVnode], 0, 0);\r\n                }\r\n                else if (isDef(oldVnode.tag)) {\r\n                    invokeDestroyHook(oldVnode);\r\n                }\r\n            }\r\n        }\r\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\r\n        return vnode.elm;\r\n    };\r\n}\r\n\r\nvar directives$1 = {\r\n    create: updateDirectives,\r\n    update: updateDirectives,\r\n    destroy: function unbindDirectives(vnode) {\r\n        // @ts-expect-error emptyNode is not VNodeWithData\r\n        updateDirectives(vnode, emptyNode);\r\n    }\r\n};\r\nfunction updateDirectives(oldVnode, vnode) {\r\n    if (oldVnode.data.directives || vnode.data.directives) {\r\n        _update(oldVnode, vnode);\r\n    }\r\n}\r\nfunction _update(oldVnode, vnode) {\r\n    var isCreate = oldVnode === emptyNode;\r\n    var isDestroy = vnode === emptyNode;\r\n    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);\r\n    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);\r\n    var dirsWithInsert = [];\r\n    var dirsWithPostpatch = [];\r\n    var key, oldDir, dir;\r\n    for (key in newDirs) {\r\n        oldDir = oldDirs[key];\r\n        dir = newDirs[key];\r\n        if (!oldDir) {\r\n            // new directive, bind\r\n            callHook(dir, 'bind', vnode, oldVnode);\r\n            if (dir.def && dir.def.inserted) {\r\n                dirsWithInsert.push(dir);\r\n            }\r\n        }\r\n        else {\r\n            // existing directive, update\r\n            dir.oldValue = oldDir.value;\r\n            dir.oldArg = oldDir.arg;\r\n            callHook(dir, 'update', vnode, oldVnode);\r\n            if (dir.def && dir.def.componentUpdated) {\r\n                dirsWithPostpatch.push(dir);\r\n            }\r\n        }\r\n    }\r\n    if (dirsWithInsert.length) {\r\n        var callInsert = function () {\r\n            for (var i = 0; i < dirsWithInsert.length; i++) {\r\n                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);\r\n            }\r\n        };\r\n        if (isCreate) {\r\n            mergeVNodeHook(vnode, 'insert', callInsert);\r\n        }\r\n        else {\r\n            callInsert();\r\n        }\r\n    }\r\n    if (dirsWithPostpatch.length) {\r\n        mergeVNodeHook(vnode, 'postpatch', function () {\r\n            for (var i = 0; i < dirsWithPostpatch.length; i++) {\r\n                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\r\n            }\r\n        });\r\n    }\r\n    if (!isCreate) {\r\n        for (key in oldDirs) {\r\n            if (!newDirs[key]) {\r\n                // no longer present, unbind\r\n                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\r\n            }\r\n        }\r\n    }\r\n}\r\nvar emptyModifiers = Object.create(null);\r\nfunction normalizeDirectives(dirs, vm) {\r\n    var res = Object.create(null);\r\n    if (!dirs) {\r\n        // $flow-disable-line\r\n        return res;\r\n    }\r\n    var i, dir;\r\n    for (i = 0; i < dirs.length; i++) {\r\n        dir = dirs[i];\r\n        if (!dir.modifiers) {\r\n            // $flow-disable-line\r\n            dir.modifiers = emptyModifiers;\r\n        }\r\n        res[getRawDirName(dir)] = dir;\r\n        if (vm._setupState && vm._setupState.__sfc) {\r\n            var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);\r\n            if (typeof setupDef === 'function') {\r\n                dir.def = {\r\n                    bind: setupDef,\r\n                    update: setupDef,\r\n                };\r\n            }\r\n            else {\r\n                dir.def = setupDef;\r\n            }\r\n        }\r\n        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);\r\n    }\r\n    // $flow-disable-line\r\n    return res;\r\n}\r\nfunction getRawDirName(dir) {\r\n    return (dir.rawName || \"\".concat(dir.name, \".\").concat(Object.keys(dir.modifiers || {}).join('.')));\r\n}\r\nfunction callHook(dir, hook, vnode, oldVnode, isDestroy) {\r\n    var fn = dir.def && dir.def[hook];\r\n    if (fn) {\r\n        try {\r\n            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vnode.context, \"directive \".concat(dir.name, \" \").concat(hook, \" hook\"));\r\n        }\r\n    }\r\n}\r\n\r\nvar baseModules = [ref, directives$1];\r\n\r\nfunction updateAttrs(oldVnode, vnode) {\r\n    var opts = vnode.componentOptions;\r\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\r\n        return;\r\n    }\r\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\r\n        return;\r\n    }\r\n    var key, cur, old;\r\n    var elm = vnode.elm;\r\n    var oldAttrs = oldVnode.data.attrs || {};\r\n    var attrs = vnode.data.attrs || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {\r\n        attrs = vnode.data.attrs = extend({}, attrs);\r\n    }\r\n    for (key in attrs) {\r\n        cur = attrs[key];\r\n        old = oldAttrs[key];\r\n        if (old !== cur) {\r\n            setAttr(elm, key, cur, vnode.data.pre);\r\n        }\r\n    }\r\n    // #4391: in IE9, setting type can reset value for input[type=radio]\r\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\r\n    /* istanbul ignore if */\r\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\r\n        setAttr(elm, 'value', attrs.value);\r\n    }\r\n    for (key in oldAttrs) {\r\n        if (isUndef(attrs[key])) {\r\n            if (isXlink(key)) {\r\n                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n            }\r\n            else if (!isEnumeratedAttr(key)) {\r\n                elm.removeAttribute(key);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction setAttr(el, key, value, isInPre) {\r\n    if (isInPre || el.tagName.indexOf('-') > -1) {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n    else if (isBooleanAttr(key)) {\r\n        // set attribute for blank value\r\n        // e.g. <option disabled>Select one</option>\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            // technically allowfullscreen is a boolean attribute for <iframe>,\r\n            // but Flash expects a value of \"true\" when used on <embed> tag\r\n            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\r\n            el.setAttribute(key, value);\r\n        }\r\n    }\r\n    else if (isEnumeratedAttr(key)) {\r\n        el.setAttribute(key, convertEnumeratedValue(key, value));\r\n    }\r\n    else if (isXlink(key)) {\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n}\r\nfunction baseSetAttr(el, key, value) {\r\n    if (isFalsyAttrValue(value)) {\r\n        el.removeAttribute(key);\r\n    }\r\n    else {\r\n        // #7138: IE10 & 11 fires input event when setting placeholder on\r\n        // <textarea>... block the first input event and remove the blocker\r\n        // immediately.\r\n        /* istanbul ignore if */\r\n        if (isIE &&\r\n            !isIE9 &&\r\n            el.tagName === 'TEXTAREA' &&\r\n            key === 'placeholder' &&\r\n            value !== '' &&\r\n            !el.__ieph) {\r\n            var blocker_1 = function (e) {\r\n                e.stopImmediatePropagation();\r\n                el.removeEventListener('input', blocker_1);\r\n            };\r\n            el.addEventListener('input', blocker_1);\r\n            // $flow-disable-line\r\n            el.__ieph = true; /* IE placeholder patched */\r\n        }\r\n        el.setAttribute(key, value);\r\n    }\r\n}\r\nvar attrs = {\r\n    create: updateAttrs,\r\n    update: updateAttrs\r\n};\r\n\r\nfunction updateClass(oldVnode, vnode) {\r\n    var el = vnode.elm;\r\n    var data = vnode.data;\r\n    var oldData = oldVnode.data;\r\n    if (isUndef(data.staticClass) &&\r\n        isUndef(data.class) &&\r\n        (isUndef(oldData) ||\r\n            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {\r\n        return;\r\n    }\r\n    var cls = genClassForVnode(vnode);\r\n    // handle transition classes\r\n    var transitionClass = el._transitionClasses;\r\n    if (isDef(transitionClass)) {\r\n        cls = concat(cls, stringifyClass(transitionClass));\r\n    }\r\n    // set the class\r\n    if (cls !== el._prevClass) {\r\n        el.setAttribute('class', cls);\r\n        el._prevClass = cls;\r\n    }\r\n}\r\nvar klass$1 = {\r\n    create: updateClass,\r\n    update: updateClass\r\n};\r\n\r\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\r\nfunction parseFilters(exp) {\r\n    var inSingle = false;\r\n    var inDouble = false;\r\n    var inTemplateString = false;\r\n    var inRegex = false;\r\n    var curly = 0;\r\n    var square = 0;\r\n    var paren = 0;\r\n    var lastFilterIndex = 0;\r\n    var c, prev, i, expression, filters;\r\n    for (i = 0; i < exp.length; i++) {\r\n        prev = c;\r\n        c = exp.charCodeAt(i);\r\n        if (inSingle) {\r\n            if (c === 0x27 && prev !== 0x5c)\r\n                inSingle = false;\r\n        }\r\n        else if (inDouble) {\r\n            if (c === 0x22 && prev !== 0x5c)\r\n                inDouble = false;\r\n        }\r\n        else if (inTemplateString) {\r\n            if (c === 0x60 && prev !== 0x5c)\r\n                inTemplateString = false;\r\n        }\r\n        else if (inRegex) {\r\n            if (c === 0x2f && prev !== 0x5c)\r\n                inRegex = false;\r\n        }\r\n        else if (c === 0x7c && // pipe\r\n            exp.charCodeAt(i + 1) !== 0x7c &&\r\n            exp.charCodeAt(i - 1) !== 0x7c &&\r\n            !curly &&\r\n            !square &&\r\n            !paren) {\r\n            if (expression === undefined) {\r\n                // first filter, end of expression\r\n                lastFilterIndex = i + 1;\r\n                expression = exp.slice(0, i).trim();\r\n            }\r\n            else {\r\n                pushFilter();\r\n            }\r\n        }\r\n        else {\r\n            switch (c) {\r\n                case 0x22:\r\n                    inDouble = true;\r\n                    break; // \"\r\n                case 0x27:\r\n                    inSingle = true;\r\n                    break; // '\r\n                case 0x60:\r\n                    inTemplateString = true;\r\n                    break; // `\r\n                case 0x28:\r\n                    paren++;\r\n                    break; // (\r\n                case 0x29:\r\n                    paren--;\r\n                    break; // )\r\n                case 0x5b:\r\n                    square++;\r\n                    break; // [\r\n                case 0x5d:\r\n                    square--;\r\n                    break; // ]\r\n                case 0x7b:\r\n                    curly++;\r\n                    break; // {\r\n                case 0x7d:\r\n                    curly--;\r\n                    break; // }\r\n            }\r\n            if (c === 0x2f) {\r\n                // /\r\n                var j = i - 1;\r\n                var p \r\n                // find first non-whitespace prev char\r\n                = void 0;\r\n                // find first non-whitespace prev char\r\n                for (; j >= 0; j--) {\r\n                    p = exp.charAt(j);\r\n                    if (p !== ' ')\r\n                        break;\r\n                }\r\n                if (!p || !validDivisionCharRE.test(p)) {\r\n                    inRegex = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (expression === undefined) {\r\n        expression = exp.slice(0, i).trim();\r\n    }\r\n    else if (lastFilterIndex !== 0) {\r\n        pushFilter();\r\n    }\r\n    function pushFilter() {\r\n        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\r\n        lastFilterIndex = i + 1;\r\n    }\r\n    if (filters) {\r\n        for (i = 0; i < filters.length; i++) {\r\n            expression = wrapFilter(expression, filters[i]);\r\n        }\r\n    }\r\n    return expression;\r\n}\r\nfunction wrapFilter(exp, filter) {\r\n    var i = filter.indexOf('(');\r\n    if (i < 0) {\r\n        // _f: resolveFilter\r\n        return \"_f(\\\"\".concat(filter, \"\\\")(\").concat(exp, \")\");\r\n    }\r\n    else {\r\n        var name_1 = filter.slice(0, i);\r\n        var args = filter.slice(i + 1);\r\n        return \"_f(\\\"\".concat(name_1, \"\\\")(\").concat(exp).concat(args !== ')' ? ',' + args : args);\r\n    }\r\n}\r\n\r\n/* eslint-disable no-unused-vars */\r\nfunction baseWarn(msg, range) {\r\n    console.error(\"[Vue compiler]: \".concat(msg));\r\n}\r\n/* eslint-enable no-unused-vars */\r\nfunction pluckModuleFunction(modules, key) {\r\n    return modules ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; }) : [];\r\n}\r\nfunction addProp(el, name, value, range, dynamic) {\r\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\r\n    el.plain = false;\r\n}\r\nfunction addAttr(el, name, value, range, dynamic) {\r\n    var attrs = dynamic\r\n        ? el.dynamicAttrs || (el.dynamicAttrs = [])\r\n        : el.attrs || (el.attrs = []);\r\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\r\n    el.plain = false;\r\n}\r\n// add a raw attr (use this in preTransforms)\r\nfunction addRawAttr(el, name, value, range) {\r\n    el.attrsMap[name] = value;\r\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\r\n}\r\nfunction addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\r\n    (el.directives || (el.directives = [])).push(rangeSetItem({\r\n        name: name,\r\n        rawName: rawName,\r\n        value: value,\r\n        arg: arg,\r\n        isDynamicArg: isDynamicArg,\r\n        modifiers: modifiers\r\n    }, range));\r\n    el.plain = false;\r\n}\r\nfunction prependModifierMarker(symbol, name, dynamic) {\r\n    return dynamic ? \"_p(\".concat(name, \",\\\"\").concat(symbol, \"\\\")\") : symbol + name; // mark the event as captured\r\n}\r\nfunction addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\r\n    modifiers = modifiers || emptyObject;\r\n    // warn prevent and passive modifier\r\n    /* istanbul ignore if */\r\n    if (false) // removed by dead control flow\n{}\r\n    // normalize click.right and click.middle since they don't actually fire\r\n    // this is technically browser-specific, but at least for now browsers are\r\n    // the only target envs that have right/middle clicks.\r\n    if (modifiers.right) {\r\n        if (dynamic) {\r\n            name = \"(\".concat(name, \")==='click'?'contextmenu':(\").concat(name, \")\");\r\n        }\r\n        else if (name === 'click') {\r\n            name = 'contextmenu';\r\n            delete modifiers.right;\r\n        }\r\n    }\r\n    else if (modifiers.middle) {\r\n        if (dynamic) {\r\n            name = \"(\".concat(name, \")==='click'?'mouseup':(\").concat(name, \")\");\r\n        }\r\n        else if (name === 'click') {\r\n            name = 'mouseup';\r\n        }\r\n    }\r\n    // check capture modifier\r\n    if (modifiers.capture) {\r\n        delete modifiers.capture;\r\n        name = prependModifierMarker('!', name, dynamic);\r\n    }\r\n    if (modifiers.once) {\r\n        delete modifiers.once;\r\n        name = prependModifierMarker('~', name, dynamic);\r\n    }\r\n    /* istanbul ignore if */\r\n    if (modifiers.passive) {\r\n        delete modifiers.passive;\r\n        name = prependModifierMarker('&', name, dynamic);\r\n    }\r\n    var events;\r\n    if (modifiers.native) {\r\n        delete modifiers.native;\r\n        events = el.nativeEvents || (el.nativeEvents = {});\r\n    }\r\n    else {\r\n        events = el.events || (el.events = {});\r\n    }\r\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\r\n    if (modifiers !== emptyObject) {\r\n        newHandler.modifiers = modifiers;\r\n    }\r\n    var handlers = events[name];\r\n    /* istanbul ignore if */\r\n    if (Array.isArray(handlers)) {\r\n        important ? handlers.unshift(newHandler) : handlers.push(newHandler);\r\n    }\r\n    else if (handlers) {\r\n        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\r\n    }\r\n    else {\r\n        events[name] = newHandler;\r\n    }\r\n    el.plain = false;\r\n}\r\nfunction getRawBindingAttr(el, name) {\r\n    return (el.rawAttrsMap[':' + name] ||\r\n        el.rawAttrsMap['v-bind:' + name] ||\r\n        el.rawAttrsMap[name]);\r\n}\r\nfunction getBindingAttr(el, name, getStatic) {\r\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\r\n    if (dynamicValue != null) {\r\n        return parseFilters(dynamicValue);\r\n    }\r\n    else if (getStatic !== false) {\r\n        var staticValue = getAndRemoveAttr(el, name);\r\n        if (staticValue != null) {\r\n            return JSON.stringify(staticValue);\r\n        }\r\n    }\r\n}\r\n// note: this only removes the attr from the Array (attrsList) so that it\r\n// doesn't get processed by processAttrs.\r\n// By default it does NOT remove it from the map (attrsMap) because the map is\r\n// needed during codegen.\r\nfunction getAndRemoveAttr(el, name, removeFromMap) {\r\n    var val;\r\n    if ((val = el.attrsMap[name]) != null) {\r\n        var list = el.attrsList;\r\n        for (var i = 0, l = list.length; i < l; i++) {\r\n            if (list[i].name === name) {\r\n                list.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (removeFromMap) {\r\n        delete el.attrsMap[name];\r\n    }\r\n    return val;\r\n}\r\nfunction getAndRemoveAttrByRegex(el, name) {\r\n    var list = el.attrsList;\r\n    for (var i = 0, l = list.length; i < l; i++) {\r\n        var attr = list[i];\r\n        if (name.test(attr.name)) {\r\n            list.splice(i, 1);\r\n            return attr;\r\n        }\r\n    }\r\n}\r\nfunction rangeSetItem(item, range) {\r\n    if (range) {\r\n        if (range.start != null) {\r\n            item.start = range.start;\r\n        }\r\n        if (range.end != null) {\r\n            item.end = range.end;\r\n        }\r\n    }\r\n    return item;\r\n}\r\n\r\n/**\r\n * Cross-platform code generation for component v-model\r\n */\r\nfunction genComponentModel(el, value, modifiers) {\r\n    var _a = modifiers || {}, number = _a.number, trim = _a.trim;\r\n    var baseValueExpression = '$$v';\r\n    var valueExpression = baseValueExpression;\r\n    if (trim) {\r\n        valueExpression =\r\n            \"(typeof \".concat(baseValueExpression, \" === 'string'\") +\r\n                \"? \".concat(baseValueExpression, \".trim()\") +\r\n                \": \".concat(baseValueExpression, \")\");\r\n    }\r\n    if (number) {\r\n        valueExpression = \"_n(\".concat(valueExpression, \")\");\r\n    }\r\n    var assignment = genAssignmentCode(value, valueExpression);\r\n    el.model = {\r\n        value: \"(\".concat(value, \")\"),\r\n        expression: JSON.stringify(value),\r\n        callback: \"function (\".concat(baseValueExpression, \") {\").concat(assignment, \"}\")\r\n    };\r\n}\r\n/**\r\n * Cross-platform codegen helper for generating v-model value assignment code.\r\n */\r\nfunction genAssignmentCode(value, assignment) {\r\n    var res = parseModel(value);\r\n    if (res.key === null) {\r\n        return \"\".concat(value, \"=\").concat(assignment);\r\n    }\r\n    else {\r\n        return \"$set(\".concat(res.exp, \", \").concat(res.key, \", \").concat(assignment, \")\");\r\n    }\r\n}\r\n/**\r\n * Parse a v-model expression into a base path and a final key segment.\r\n * Handles both dot-path and possible square brackets.\r\n *\r\n * Possible cases:\r\n *\r\n * - test\r\n * - test[key]\r\n * - test[test1[key]]\r\n * - test[\"a\"][key]\r\n * - xxx.test[a[a].test1[key]]\r\n * - test.xxx.a[\"asa\"][test1[key]]\r\n *\r\n */\r\nvar len, str, chr, index, expressionPos, expressionEndPos;\r\nfunction parseModel(val) {\r\n    // Fix https://github.com/vuejs/vue/pull/7730\r\n    // allow v-model=\"obj.val \" (trailing whitespace)\r\n    val = val.trim();\r\n    len = val.length;\r\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\r\n        index = val.lastIndexOf('.');\r\n        if (index > -1) {\r\n            return {\r\n                exp: val.slice(0, index),\r\n                key: '\"' + val.slice(index + 1) + '\"'\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                exp: val,\r\n                key: null\r\n            };\r\n        }\r\n    }\r\n    str = val;\r\n    index = expressionPos = expressionEndPos = 0;\r\n    while (!eof()) {\r\n        chr = next();\r\n        /* istanbul ignore if */\r\n        if (isStringStart(chr)) {\r\n            parseString(chr);\r\n        }\r\n        else if (chr === 0x5b) {\r\n            parseBracket(chr);\r\n        }\r\n    }\r\n    return {\r\n        exp: val.slice(0, expressionPos),\r\n        key: val.slice(expressionPos + 1, expressionEndPos)\r\n    };\r\n}\r\nfunction next() {\r\n    return str.charCodeAt(++index);\r\n}\r\nfunction eof() {\r\n    return index >= len;\r\n}\r\nfunction isStringStart(chr) {\r\n    return chr === 0x22 || chr === 0x27;\r\n}\r\nfunction parseBracket(chr) {\r\n    var inBracket = 1;\r\n    expressionPos = index;\r\n    while (!eof()) {\r\n        chr = next();\r\n        if (isStringStart(chr)) {\r\n            parseString(chr);\r\n            continue;\r\n        }\r\n        if (chr === 0x5b)\r\n            inBracket++;\r\n        if (chr === 0x5d)\r\n            inBracket--;\r\n        if (inBracket === 0) {\r\n            expressionEndPos = index;\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction parseString(chr) {\r\n    var stringQuote = chr;\r\n    while (!eof()) {\r\n        chr = next();\r\n        if (chr === stringQuote) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nvar warn$1;\r\n// in some cases, the event used has to be determined at runtime\r\n// so we used some reserved tokens during compile.\r\nvar RANGE_TOKEN = '__r';\r\nvar CHECKBOX_RADIO_TOKEN = '__c';\r\nfunction model$1(el, dir, _warn) {\r\n    warn$1 = _warn;\r\n    var value = dir.value;\r\n    var modifiers = dir.modifiers;\r\n    var tag = el.tag;\r\n    var type = el.attrsMap.type;\r\n    if (false) // removed by dead control flow\n{}\r\n    if (el.component) {\r\n        genComponentModel(el, value, modifiers);\r\n        // component v-model doesn't need extra runtime\r\n        return false;\r\n    }\r\n    else if (tag === 'select') {\r\n        genSelect(el, value, modifiers);\r\n    }\r\n    else if (tag === 'input' && type === 'checkbox') {\r\n        genCheckboxModel(el, value, modifiers);\r\n    }\r\n    else if (tag === 'input' && type === 'radio') {\r\n        genRadioModel(el, value, modifiers);\r\n    }\r\n    else if (tag === 'input' || tag === 'textarea') {\r\n        genDefaultModel(el, value, modifiers);\r\n    }\r\n    else if (!config.isReservedTag(tag)) {\r\n        genComponentModel(el, value, modifiers);\r\n        // component v-model doesn't need extra runtime\r\n        return false;\r\n    }\r\n    else if (false) // removed by dead control flow\n{}\r\n    // ensure runtime directive metadata\r\n    return true;\r\n}\r\nfunction genCheckboxModel(el, value, modifiers) {\r\n    var number = modifiers && modifiers.number;\r\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\r\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\r\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\r\n    addProp(el, 'checked', \"Array.isArray(\".concat(value, \")\") +\r\n        \"?_i(\".concat(value, \",\").concat(valueBinding, \")>-1\") +\r\n        (trueValueBinding === 'true'\r\n            ? \":(\".concat(value, \")\")\r\n            : \":_q(\".concat(value, \",\").concat(trueValueBinding, \")\")));\r\n    addHandler(el, 'change', \"var $$a=\".concat(value, \",\") +\r\n        '$$el=$event.target,' +\r\n        \"$$c=$$el.checked?(\".concat(trueValueBinding, \"):(\").concat(falseValueBinding, \");\") +\r\n        'if(Array.isArray($$a)){' +\r\n        \"var $$v=\".concat(number ? '_n(' + valueBinding + ')' : valueBinding, \",\") +\r\n        '$$i=_i($$a,$$v);' +\r\n        \"if($$el.checked){$$i<0&&(\".concat(genAssignmentCode(value, '$$a.concat([$$v])'), \")}\") +\r\n        \"else{$$i>-1&&(\".concat(genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))'), \")}\") +\r\n        \"}else{\".concat(genAssignmentCode(value, '$$c'), \"}\"), null, true);\r\n}\r\nfunction genRadioModel(el, value, modifiers) {\r\n    var number = modifiers && modifiers.number;\r\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\r\n    valueBinding = number ? \"_n(\".concat(valueBinding, \")\") : valueBinding;\r\n    addProp(el, 'checked', \"_q(\".concat(value, \",\").concat(valueBinding, \")\"));\r\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\r\n}\r\nfunction genSelect(el, value, modifiers) {\r\n    var number = modifiers && modifiers.number;\r\n    var selectedVal = \"Array.prototype.filter\" +\r\n        \".call($event.target.options,function(o){return o.selected})\" +\r\n        \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\r\n        \"return \".concat(number ? '_n(val)' : 'val', \"})\");\r\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\r\n    var code = \"var $$selectedVal = \".concat(selectedVal, \";\");\r\n    code = \"\".concat(code, \" \").concat(genAssignmentCode(value, assignment));\r\n    addHandler(el, 'change', code, null, true);\r\n}\r\nfunction genDefaultModel(el, value, modifiers) {\r\n    var type = el.attrsMap.type;\r\n    // warn if v-bind:value conflicts with v-model\r\n    // except for inputs with v-bind:type\r\n    if (false) // removed by dead control flow\n{ var binding, typeBinding, value_1; }\r\n    var _a = modifiers || {}, lazy = _a.lazy, number = _a.number, trim = _a.trim;\r\n    var needCompositionGuard = !lazy && type !== 'range';\r\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\r\n    var valueExpression = '$event.target.value';\r\n    if (trim) {\r\n        valueExpression = \"$event.target.value.trim()\";\r\n    }\r\n    if (number) {\r\n        valueExpression = \"_n(\".concat(valueExpression, \")\");\r\n    }\r\n    var code = genAssignmentCode(value, valueExpression);\r\n    if (needCompositionGuard) {\r\n        code = \"if($event.target.composing)return;\".concat(code);\r\n    }\r\n    addProp(el, 'value', \"(\".concat(value, \")\"));\r\n    addHandler(el, event, code, null, true);\r\n    if (trim || number) {\r\n        addHandler(el, 'blur', '$forceUpdate()');\r\n    }\r\n}\r\n\r\n// normalize v-model event tokens that can only be determined at runtime.\r\n// it's important to place the event as the first in the array because\r\n// the whole point is ensuring the v-model callback gets called before\r\n// user-attached handlers.\r\nfunction normalizeEvents(on) {\r\n    /* istanbul ignore if */\r\n    if (isDef(on[RANGE_TOKEN])) {\r\n        // IE input[type=range] only supports `change` event\r\n        var event_1 = isIE ? 'change' : 'input';\r\n        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);\r\n        delete on[RANGE_TOKEN];\r\n    }\r\n    // This was originally intended to fix #4521 but no longer necessary\r\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\r\n    /* istanbul ignore if */\r\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\r\n        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\r\n        delete on[CHECKBOX_RADIO_TOKEN];\r\n    }\r\n}\r\nvar target;\r\nfunction createOnceHandler(event, handler, capture) {\r\n    var _target = target; // save current target element in closure\r\n    return function onceHandler() {\r\n        var res = handler.apply(null, arguments);\r\n        if (res !== null) {\r\n            remove(event, onceHandler, capture, _target);\r\n        }\r\n    };\r\n}\r\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\r\n// implementation and does not fire microtasks in between event propagation, so\r\n// safe to exclude.\r\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\r\nfunction add(name, handler, capture, passive) {\r\n    // async edge case #6566: inner click event triggers patch, event handler\r\n    // attached to outer element during patch, and triggered again. This\r\n    // happens because browsers fire microtask ticks between event propagation.\r\n    // the solution is simple: we save the timestamp when a handler is attached,\r\n    // and the handler would only fire if the event passed to it was fired\r\n    // AFTER it was attached.\r\n    if (useMicrotaskFix) {\r\n        var attachedTimestamp_1 = currentFlushTimestamp;\r\n        var original_1 = handler;\r\n        //@ts-expect-error\r\n        handler = original_1._wrapper = function (e) {\r\n            if (\r\n            // no bubbling, should always fire.\r\n            // this is just a safety net in case event.timeStamp is unreliable in\r\n            // certain weird environments...\r\n            e.target === e.currentTarget ||\r\n                // event is fired after handler attachment\r\n                e.timeStamp >= attachedTimestamp_1 ||\r\n                // bail for environments that have buggy event.timeStamp implementations\r\n                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\r\n                // #9681 QtWebEngine event.timeStamp is negative value\r\n                e.timeStamp <= 0 ||\r\n                // #9448 bail if event is fired in another document in a multi-page\r\n                // electron/nw.js app, since event.timeStamp will be using a different\r\n                // starting reference\r\n                e.target.ownerDocument !== document) {\r\n                return original_1.apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\r\n}\r\nfunction remove(name, handler, capture, _target) {\r\n    (_target || target).removeEventListener(name, \r\n    //@ts-expect-error\r\n    handler._wrapper || handler, capture);\r\n}\r\nfunction updateDOMListeners(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\r\n        return;\r\n    }\r\n    var on = vnode.data.on || {};\r\n    var oldOn = oldVnode.data.on || {};\r\n    // vnode is empty when removing all listeners,\r\n    // and use old vnode dom element\r\n    target = vnode.elm || oldVnode.elm;\r\n    normalizeEvents(on);\r\n    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);\r\n    target = undefined;\r\n}\r\nvar events = {\r\n    create: updateDOMListeners,\r\n    update: updateDOMListeners,\r\n    // @ts-expect-error emptyNode has actually data\r\n    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }\r\n};\r\n\r\nvar svgContainer;\r\nfunction updateDOMProps(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\r\n        return;\r\n    }\r\n    var key, cur;\r\n    var elm = vnode.elm;\r\n    var oldProps = oldVnode.data.domProps || {};\r\n    var props = vnode.data.domProps || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {\r\n        props = vnode.data.domProps = extend({}, props);\r\n    }\r\n    for (key in oldProps) {\r\n        if (!(key in props)) {\r\n            elm[key] = '';\r\n        }\r\n    }\r\n    for (key in props) {\r\n        cur = props[key];\r\n        // ignore children if the node has textContent or innerHTML,\r\n        // as these will throw away existing DOM nodes and cause removal errors\r\n        // on subsequent patches (#3360)\r\n        if (key === 'textContent' || key === 'innerHTML') {\r\n            if (vnode.children)\r\n                vnode.children.length = 0;\r\n            if (cur === oldProps[key])\r\n                continue;\r\n            // #6601 work around Chrome version <= 55 bug where single textNode\r\n            // replaced by innerHTML/textContent retains its parentNode property\r\n            if (elm.childNodes.length === 1) {\r\n                elm.removeChild(elm.childNodes[0]);\r\n            }\r\n        }\r\n        if (key === 'value' && elm.tagName !== 'PROGRESS') {\r\n            // store value as _value as well since\r\n            // non-string values will be stringified\r\n            elm._value = cur;\r\n            // avoid resetting cursor position when value is the same\r\n            var strCur = isUndef(cur) ? '' : String(cur);\r\n            if (shouldUpdateValue(elm, strCur)) {\r\n                elm.value = strCur;\r\n            }\r\n        }\r\n        else if (key === 'innerHTML' &&\r\n            isSVG(elm.tagName) &&\r\n            isUndef(elm.innerHTML)) {\r\n            // IE doesn't support innerHTML for SVG elements\r\n            svgContainer = svgContainer || document.createElement('div');\r\n            svgContainer.innerHTML = \"<svg>\".concat(cur, \"</svg>\");\r\n            var svg = svgContainer.firstChild;\r\n            while (elm.firstChild) {\r\n                elm.removeChild(elm.firstChild);\r\n            }\r\n            while (svg.firstChild) {\r\n                elm.appendChild(svg.firstChild);\r\n            }\r\n        }\r\n        else if (\r\n        // skip the update if old and new VDOM state is the same.\r\n        // `value` is handled separately because the DOM value may be temporarily\r\n        // out of sync with VDOM state due to focus, composition and modifiers.\r\n        // This  #4521 by skipping the unnecessary `checked` update.\r\n        cur !== oldProps[key]) {\r\n            // some property updates can throw\r\n            // e.g. `value` on <progress> w/ non-finite value\r\n            try {\r\n                elm[key] = cur;\r\n            }\r\n            catch (e) { }\r\n        }\r\n    }\r\n}\r\nfunction shouldUpdateValue(elm, checkVal) {\r\n    return (\r\n    //@ts-expect-error\r\n    !elm.composing &&\r\n        (elm.tagName === 'OPTION' ||\r\n            isNotInFocusAndDirty(elm, checkVal) ||\r\n            isDirtyWithModifiers(elm, checkVal)));\r\n}\r\nfunction isNotInFocusAndDirty(elm, checkVal) {\r\n    // return true when textbox (.number and .trim) loses focus and its value is\r\n    // not equal to the updated value\r\n    var notInFocus = true;\r\n    // #6157\r\n    // work around IE bug when accessing document.activeElement in an iframe\r\n    try {\r\n        notInFocus = document.activeElement !== elm;\r\n    }\r\n    catch (e) { }\r\n    return notInFocus && elm.value !== checkVal;\r\n}\r\nfunction isDirtyWithModifiers(elm, newVal) {\r\n    var value = elm.value;\r\n    var modifiers = elm._vModifiers; // injected by v-model runtime\r\n    if (isDef(modifiers)) {\r\n        if (modifiers.number) {\r\n            return toNumber(value) !== toNumber(newVal);\r\n        }\r\n        if (modifiers.trim) {\r\n            return value.trim() !== newVal.trim();\r\n        }\r\n    }\r\n    return value !== newVal;\r\n}\r\nvar domProps = {\r\n    create: updateDOMProps,\r\n    update: updateDOMProps\r\n};\r\n\r\nvar parseStyleText = cached(function (cssText) {\r\n    var res = {};\r\n    var listDelimiter = /;(?![^(]*\\))/g;\r\n    var propertyDelimiter = /:(.+)/;\r\n    cssText.split(listDelimiter).forEach(function (item) {\r\n        if (item) {\r\n            var tmp = item.split(propertyDelimiter);\r\n            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return res;\r\n});\r\n// merge static and dynamic style data on the same vnode\r\nfunction normalizeStyleData(data) {\r\n    var style = normalizeStyleBinding(data.style);\r\n    // static style is pre-processed into an object during compilation\r\n    // and is always a fresh object, so it's safe to merge into it\r\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\r\n}\r\n// normalize possible array / string values into Object\r\nfunction normalizeStyleBinding(bindingStyle) {\r\n    if (Array.isArray(bindingStyle)) {\r\n        return toObject(bindingStyle);\r\n    }\r\n    if (typeof bindingStyle === 'string') {\r\n        return parseStyleText(bindingStyle);\r\n    }\r\n    return bindingStyle;\r\n}\r\n/**\r\n * parent component style should be after child's\r\n * so that parent component's style could override it\r\n */\r\nfunction getStyle(vnode, checkChild) {\r\n    var res = {};\r\n    var styleData;\r\n    if (checkChild) {\r\n        var childNode = vnode;\r\n        while (childNode.componentInstance) {\r\n            childNode = childNode.componentInstance._vnode;\r\n            if (childNode &&\r\n                childNode.data &&\r\n                (styleData = normalizeStyleData(childNode.data))) {\r\n                extend(res, styleData);\r\n            }\r\n        }\r\n    }\r\n    if ((styleData = normalizeStyleData(vnode.data))) {\r\n        extend(res, styleData);\r\n    }\r\n    var parentNode = vnode;\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while ((parentNode = parentNode.parent)) {\r\n        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\r\n            extend(res, styleData);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvar cssVarRE = /^--/;\r\nvar importantRE = /\\s*!important$/;\r\nvar setProp = function (el, name, val) {\r\n    /* istanbul ignore if */\r\n    if (cssVarRE.test(name)) {\r\n        el.style.setProperty(name, val);\r\n    }\r\n    else if (importantRE.test(val)) {\r\n        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\r\n    }\r\n    else {\r\n        var normalizedName = normalize(name);\r\n        if (Array.isArray(val)) {\r\n            // Support values array created by autoprefixer, e.g.\r\n            // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\r\n            // Set them one by one, and the browser will only set those it can recognize\r\n            for (var i = 0, len = val.length; i < len; i++) {\r\n                el.style[normalizedName] = val[i];\r\n            }\r\n        }\r\n        else {\r\n            el.style[normalizedName] = val;\r\n        }\r\n    }\r\n};\r\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\r\nvar emptyStyle;\r\nvar normalize = cached(function (prop) {\r\n    emptyStyle = emptyStyle || document.createElement('div').style;\r\n    prop = camelize(prop);\r\n    if (prop !== 'filter' && prop in emptyStyle) {\r\n        return prop;\r\n    }\r\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\r\n    for (var i = 0; i < vendorNames.length; i++) {\r\n        var name_1 = vendorNames[i] + capName;\r\n        if (name_1 in emptyStyle) {\r\n            return name_1;\r\n        }\r\n    }\r\n});\r\nfunction updateStyle(oldVnode, vnode) {\r\n    var data = vnode.data;\r\n    var oldData = oldVnode.data;\r\n    if (isUndef(data.staticStyle) &&\r\n        isUndef(data.style) &&\r\n        isUndef(oldData.staticStyle) &&\r\n        isUndef(oldData.style)) {\r\n        return;\r\n    }\r\n    var cur, name;\r\n    var el = vnode.elm;\r\n    var oldStaticStyle = oldData.staticStyle;\r\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\r\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\r\n    var oldStyle = oldStaticStyle || oldStyleBinding;\r\n    var style = normalizeStyleBinding(vnode.data.style) || {};\r\n    // store normalized style under a different key for next diff\r\n    // make sure to clone it if it's reactive, since the user likely wants\r\n    // to mutate it.\r\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\r\n    var newStyle = getStyle(vnode, true);\r\n    for (name in oldStyle) {\r\n        if (isUndef(newStyle[name])) {\r\n            setProp(el, name, '');\r\n        }\r\n    }\r\n    for (name in newStyle) {\r\n        cur = newStyle[name];\r\n        // ie9 setting to null has no effect, must use empty string\r\n        setProp(el, name, cur == null ? '' : cur);\r\n    }\r\n}\r\nvar style$1 = {\r\n    create: updateStyle,\r\n    update: updateStyle\r\n};\r\n\r\nvar whitespaceRE$1 = /\\s+/;\r\n/**\r\n * Add class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction addClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.add(c); });\r\n        }\r\n        else {\r\n            el.classList.add(cls);\r\n        }\r\n    }\r\n    else {\r\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\r\n        if (cur.indexOf(' ' + cls + ' ') < 0) {\r\n            el.setAttribute('class', (cur + cls).trim());\r\n        }\r\n    }\r\n}\r\n/**\r\n * Remove class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction removeClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.remove(c); });\r\n        }\r\n        else {\r\n            el.classList.remove(cls);\r\n        }\r\n        if (!el.classList.length) {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n    else {\r\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\r\n        var tar = ' ' + cls + ' ';\r\n        while (cur.indexOf(tar) >= 0) {\r\n            cur = cur.replace(tar, ' ');\r\n        }\r\n        cur = cur.trim();\r\n        if (cur) {\r\n            el.setAttribute('class', cur);\r\n        }\r\n        else {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n}\r\n\r\nfunction resolveTransition(def) {\r\n    if (!def) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (typeof def === 'object') {\r\n        var res = {};\r\n        if (def.css !== false) {\r\n            extend(res, autoCssTransition(def.name || 'v'));\r\n        }\r\n        extend(res, def);\r\n        return res;\r\n    }\r\n    else if (typeof def === 'string') {\r\n        return autoCssTransition(def);\r\n    }\r\n}\r\nvar autoCssTransition = cached(function (name) {\r\n    return {\r\n        enterClass: \"\".concat(name, \"-enter\"),\r\n        enterToClass: \"\".concat(name, \"-enter-to\"),\r\n        enterActiveClass: \"\".concat(name, \"-enter-active\"),\r\n        leaveClass: \"\".concat(name, \"-leave\"),\r\n        leaveToClass: \"\".concat(name, \"-leave-to\"),\r\n        leaveActiveClass: \"\".concat(name, \"-leave-active\")\r\n    };\r\n});\r\nvar hasTransition = inBrowser && !isIE9;\r\nvar TRANSITION = 'transition';\r\nvar ANIMATION = 'animation';\r\n// Transition property/event sniffing\r\nvar transitionProp = 'transition';\r\nvar transitionEndEvent = 'transitionend';\r\nvar animationProp = 'animation';\r\nvar animationEndEvent = 'animationend';\r\nif (hasTransition) {\r\n    /* istanbul ignore if */\r\n    if (window.ontransitionend === undefined &&\r\n        window.onwebkittransitionend !== undefined) {\r\n        transitionProp = 'WebkitTransition';\r\n        transitionEndEvent = 'webkitTransitionEnd';\r\n    }\r\n    if (window.onanimationend === undefined &&\r\n        window.onwebkitanimationend !== undefined) {\r\n        animationProp = 'WebkitAnimation';\r\n        animationEndEvent = 'webkitAnimationEnd';\r\n    }\r\n}\r\n// binding to window is necessary to make hot reload work in IE in strict mode\r\nvar raf = inBrowser\r\n    ? window.requestAnimationFrame\r\n        ? window.requestAnimationFrame.bind(window)\r\n        : setTimeout\r\n    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };\r\nfunction nextFrame(fn) {\r\n    raf(function () {\r\n        // @ts-expect-error\r\n        raf(fn);\r\n    });\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\r\n    if (transitionClasses.indexOf(cls) < 0) {\r\n        transitionClasses.push(cls);\r\n        addClass(el, cls);\r\n    }\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    if (el._transitionClasses) {\r\n        remove$2(el._transitionClasses, cls);\r\n    }\r\n    removeClass(el, cls);\r\n}\r\nfunction whenTransitionEnds(el, expectedType, cb) {\r\n    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;\r\n    if (!type)\r\n        return cb();\r\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\r\n    var ended = 0;\r\n    var end = function () {\r\n        el.removeEventListener(event, onEnd);\r\n        cb();\r\n    };\r\n    var onEnd = function (e) {\r\n        if (e.target === el) {\r\n            if (++ended >= propCount) {\r\n                end();\r\n            }\r\n        }\r\n    };\r\n    setTimeout(function () {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(event, onEnd);\r\n}\r\nvar transformRE = /\\b(transform|all)(,|$)/;\r\nfunction getTransitionInfo(el, expectedType) {\r\n    var styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\r\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\r\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\r\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\r\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    var type;\r\n    var timeout = 0;\r\n    var propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\r\n    return {\r\n        type: type,\r\n        timeout: timeout,\r\n        propCount: propCount,\r\n        hasTransform: hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    /* istanbul ignore next */\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max.apply(null, durations.map(function (d, i) {\r\n        return toMs(d) + toMs(delays[i]);\r\n    }));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\r\n// in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\r\n// as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n}\r\n\r\nfunction enter(vnode, toggleDisplay) {\r\n    var el = vnode.elm;\r\n    // call leave callback now\r\n    if (isDef(el._leaveCb)) {\r\n        el._leaveCb.cancelled = true;\r\n        el._leaveCb();\r\n    }\r\n    var data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data)) {\r\n        return;\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\r\n        return;\r\n    }\r\n    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;\r\n    // activeInstance will always be the <transition> component managing this\r\n    // transition. One edge case to check is when the <transition> is placed\r\n    // as the root node of a child component. In that case we need to check\r\n    // <transition>'s parent for appear check.\r\n    var context = activeInstance;\r\n    var transitionNode = activeInstance.$vnode;\r\n    while (transitionNode && transitionNode.parent) {\r\n        context = transitionNode.context;\r\n        transitionNode = transitionNode.parent;\r\n    }\r\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\r\n    if (isAppear && !appear && appear !== '') {\r\n        return;\r\n    }\r\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\r\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\r\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\r\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\r\n    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;\r\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\r\n    var enterCancelledHook = isAppear\r\n        ? appearCancelled || enterCancelled\r\n        : enterCancelled;\r\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\r\n    if (false) // removed by dead control flow\n{}\r\n    var expectsCSS = css !== false && !isIE9;\r\n    var userWantsControl = getHookArgumentsLength(enterHook);\r\n    var cb = (el._enterCb = once(function () {\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, toClass);\r\n            removeTransitionClass(el, activeClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, startClass);\r\n            }\r\n            enterCancelledHook && enterCancelledHook(el);\r\n        }\r\n        else {\r\n            afterEnterHook && afterEnterHook(el);\r\n        }\r\n        el._enterCb = null;\r\n    }));\r\n    if (!vnode.data.show) {\r\n        // remove pending leave element on enter by injecting an insert hook\r\n        mergeVNodeHook(vnode, 'insert', function () {\r\n            var parent = el.parentNode;\r\n            var pendingNode = parent && parent._pending && parent._pending[vnode.key];\r\n            if (pendingNode &&\r\n                pendingNode.tag === vnode.tag &&\r\n                pendingNode.elm._leaveCb) {\r\n                pendingNode.elm._leaveCb();\r\n            }\r\n            enterHook && enterHook(el, cb);\r\n        });\r\n    }\r\n    // start enter transition\r\n    beforeEnterHook && beforeEnterHook(el);\r\n    if (expectsCSS) {\r\n        addTransitionClass(el, startClass);\r\n        addTransitionClass(el, activeClass);\r\n        nextFrame(function () {\r\n            removeTransitionClass(el, startClass);\r\n            // @ts-expect-error\r\n            if (!cb.cancelled) {\r\n                addTransitionClass(el, toClass);\r\n                if (!userWantsControl) {\r\n                    if (isValidDuration(explicitEnterDuration)) {\r\n                        setTimeout(cb, explicitEnterDuration);\r\n                    }\r\n                    else {\r\n                        whenTransitionEnds(el, type, cb);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (vnode.data.show) {\r\n        toggleDisplay && toggleDisplay();\r\n        enterHook && enterHook(el, cb);\r\n    }\r\n    if (!expectsCSS && !userWantsControl) {\r\n        cb();\r\n    }\r\n}\r\nfunction leave(vnode, rm) {\r\n    var el = vnode.elm;\r\n    // call enter callback now\r\n    if (isDef(el._enterCb)) {\r\n        el._enterCb.cancelled = true;\r\n        el._enterCb();\r\n    }\r\n    var data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data) || el.nodeType !== 1) {\r\n        return rm();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._leaveCb)) {\r\n        return;\r\n    }\r\n    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;\r\n    var expectsCSS = css !== false && !isIE9;\r\n    var userWantsControl = getHookArgumentsLength(leave);\r\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\r\n    if (false) // removed by dead control flow\n{}\r\n    var cb = (el._leaveCb = once(function () {\r\n        if (el.parentNode && el.parentNode._pending) {\r\n            el.parentNode._pending[vnode.key] = null;\r\n        }\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, leaveToClass);\r\n            removeTransitionClass(el, leaveActiveClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, leaveClass);\r\n            }\r\n            leaveCancelled && leaveCancelled(el);\r\n        }\r\n        else {\r\n            rm();\r\n            afterLeave && afterLeave(el);\r\n        }\r\n        el._leaveCb = null;\r\n    }));\r\n    if (delayLeave) {\r\n        delayLeave(performLeave);\r\n    }\r\n    else {\r\n        performLeave();\r\n    }\r\n    function performLeave() {\r\n        // the delayed leave may have already been cancelled\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            return;\r\n        }\r\n        // record leaving element\r\n        if (!vnode.data.show && el.parentNode) {\r\n            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =\r\n                vnode;\r\n        }\r\n        beforeLeave && beforeLeave(el);\r\n        if (expectsCSS) {\r\n            addTransitionClass(el, leaveClass);\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(function () {\r\n                removeTransitionClass(el, leaveClass);\r\n                // @ts-expect-error\r\n                if (!cb.cancelled) {\r\n                    addTransitionClass(el, leaveToClass);\r\n                    if (!userWantsControl) {\r\n                        if (isValidDuration(explicitLeaveDuration)) {\r\n                            setTimeout(cb, explicitLeaveDuration);\r\n                        }\r\n                        else {\r\n                            whenTransitionEnds(el, type, cb);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        leave && leave(el, cb);\r\n        if (!expectsCSS && !userWantsControl) {\r\n            cb();\r\n        }\r\n    }\r\n}\r\n// only used in dev mode\r\nfunction checkDuration(val, name, vnode) {\r\n    if (typeof val !== 'number') {\r\n        warn$2(\"<transition> explicit \".concat(name, \" duration is not a valid number - \") +\r\n            \"got \".concat(JSON.stringify(val), \".\"), vnode.context);\r\n    }\r\n    else if (isNaN(val)) {\r\n        warn$2(\"<transition> explicit \".concat(name, \" duration is NaN - \") +\r\n            'the duration expression might be incorrect.', vnode.context);\r\n    }\r\n}\r\nfunction isValidDuration(val) {\r\n    return typeof val === 'number' && !isNaN(val);\r\n}\r\n/**\r\n * Normalize a transition hook's argument length. The hook may be:\r\n * - a merged hook (invoker) with the original in .fns\r\n * - a wrapped component method (check ._length)\r\n * - a plain function (.length)\r\n */\r\nfunction getHookArgumentsLength(fn) {\r\n    if (isUndef(fn)) {\r\n        return false;\r\n    }\r\n    // @ts-expect-error\r\n    var invokerFns = fn.fns;\r\n    if (isDef(invokerFns)) {\r\n        // invoker\r\n        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\r\n    }\r\n    else {\r\n        // @ts-expect-error\r\n        return (fn._length || fn.length) > 1;\r\n    }\r\n}\r\nfunction _enter(_, vnode) {\r\n    if (vnode.data.show !== true) {\r\n        enter(vnode);\r\n    }\r\n}\r\nvar transition = inBrowser\r\n    ? {\r\n        create: _enter,\r\n        activate: _enter,\r\n        remove: function (vnode, rm) {\r\n            /* istanbul ignore else */\r\n            if (vnode.data.show !== true) {\r\n                // @ts-expect-error\r\n                leave(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n    }\r\n    : {};\r\n\r\nvar platformModules = [attrs, klass$1, events, domProps, style$1, transition];\r\n\r\n// the directive module should be applied last, after all\r\n// built-in modules have been applied.\r\nvar modules$1 = platformModules.concat(baseModules);\r\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules$1 });\r\n\r\n/**\r\n * Not type checking this file because flow doesn't like attaching\r\n * properties to Elements.\r\n */\r\n/* istanbul ignore if */\r\nif (isIE9) {\r\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\r\n    document.addEventListener('selectionchange', function () {\r\n        var el = document.activeElement;\r\n        // @ts-expect-error\r\n        if (el && el.vmodel) {\r\n            trigger(el, 'input');\r\n        }\r\n    });\r\n}\r\nvar directive = {\r\n    inserted: function (el, binding, vnode, oldVnode) {\r\n        if (vnode.tag === 'select') {\r\n            // #6903\r\n            if (oldVnode.elm && !oldVnode.elm._vOptions) {\r\n                mergeVNodeHook(vnode, 'postpatch', function () {\r\n                    directive.componentUpdated(el, binding, vnode);\r\n                });\r\n            }\r\n            else {\r\n                setSelected(el, binding, vnode.context);\r\n            }\r\n            el._vOptions = [].map.call(el.options, getValue);\r\n        }\r\n        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\r\n            el._vModifiers = binding.modifiers;\r\n            if (!binding.modifiers.lazy) {\r\n                el.addEventListener('compositionstart', onCompositionStart);\r\n                el.addEventListener('compositionend', onCompositionEnd);\r\n                // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n                // switching focus before confirming composition choice\r\n                // this also fixes the issue where some browsers e.g. iOS Chrome\r\n                // fires \"change\" instead of \"input\" on autocomplete.\r\n                el.addEventListener('change', onCompositionEnd);\r\n                /* istanbul ignore if */\r\n                if (isIE9) {\r\n                    el.vmodel = true;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    componentUpdated: function (el, binding, vnode) {\r\n        if (vnode.tag === 'select') {\r\n            setSelected(el, binding, vnode.context);\r\n            // in case the options rendered by v-for have changed,\r\n            // it's possible that the value is out-of-sync with the rendered options.\r\n            // detect such cases and filter out values that no longer has a matching\r\n            // option in the DOM.\r\n            var prevOptions_1 = el._vOptions;\r\n            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));\r\n            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {\r\n                // trigger change event if\r\n                // no matching option found for at least one value\r\n                var needReset = el.multiple\r\n                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })\r\n                    : binding.value !== binding.oldValue &&\r\n                        hasNoMatchingOption(binding.value, curOptions_1);\r\n                if (needReset) {\r\n                    trigger(el, 'change');\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nfunction setSelected(el, binding, vm) {\r\n    actuallySetSelected(el, binding, vm);\r\n    /* istanbul ignore if */\r\n    if (isIE || isEdge) {\r\n        setTimeout(function () {\r\n            actuallySetSelected(el, binding, vm);\r\n        }, 0);\r\n    }\r\n}\r\nfunction actuallySetSelected(el, binding, vm) {\r\n    var value = binding.value;\r\n    var isMultiple = el.multiple;\r\n    if (isMultiple && !Array.isArray(value)) {\r\n         false &&\r\n            0;\r\n        return;\r\n    }\r\n    var selected, option;\r\n    for (var i = 0, l = el.options.length; i < l; i++) {\r\n        option = el.options[i];\r\n        if (isMultiple) {\r\n            selected = looseIndexOf(value, getValue(option)) > -1;\r\n            if (option.selected !== selected) {\r\n                option.selected = selected;\r\n            }\r\n        }\r\n        else {\r\n            if (looseEqual(getValue(option), value)) {\r\n                if (el.selectedIndex !== i) {\r\n                    el.selectedIndex = i;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\nfunction hasNoMatchingOption(value, options) {\r\n    return options.every(function (o) { return !looseEqual(o, value); });\r\n}\r\nfunction getValue(option) {\r\n    return '_value' in option ? option._value : option.value;\r\n}\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    // prevent triggering an input event for no reason\r\n    if (!e.target.composing)\r\n        return;\r\n    e.target.composing = false;\r\n    trigger(e.target, 'input');\r\n}\r\nfunction trigger(el, type) {\r\n    var e = document.createEvent('HTMLEvents');\r\n    e.initEvent(type, true, true);\r\n    el.dispatchEvent(e);\r\n}\r\n\r\n// recursively search for possible transition defined inside the component root\r\nfunction locateNode(vnode) {\r\n    // @ts-expect-error\r\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\r\n        ? locateNode(vnode.componentInstance._vnode)\r\n        : vnode;\r\n}\r\nvar show = {\r\n    bind: function (el, _a, vnode) {\r\n        var value = _a.value;\r\n        vnode = locateNode(vnode);\r\n        var transition = vnode.data && vnode.data.transition;\r\n        var originalDisplay = (el.__vOriginalDisplay =\r\n            el.style.display === 'none' ? '' : el.style.display);\r\n        if (value && transition) {\r\n            vnode.data.show = true;\r\n            enter(vnode, function () {\r\n                el.style.display = originalDisplay;\r\n            });\r\n        }\r\n        else {\r\n            el.style.display = value ? originalDisplay : 'none';\r\n        }\r\n    },\r\n    update: function (el, _a, vnode) {\r\n        var value = _a.value, oldValue = _a.oldValue;\r\n        /* istanbul ignore if */\r\n        if (!value === !oldValue)\r\n            return;\r\n        vnode = locateNode(vnode);\r\n        var transition = vnode.data && vnode.data.transition;\r\n        if (transition) {\r\n            vnode.data.show = true;\r\n            if (value) {\r\n                enter(vnode, function () {\r\n                    el.style.display = el.__vOriginalDisplay;\r\n                });\r\n            }\r\n            else {\r\n                leave(vnode, function () {\r\n                    el.style.display = 'none';\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            el.style.display = value ? el.__vOriginalDisplay : 'none';\r\n        }\r\n    },\r\n    unbind: function (el, binding, vnode, oldVnode, isDestroy) {\r\n        if (!isDestroy) {\r\n            el.style.display = el.__vOriginalDisplay;\r\n        }\r\n    }\r\n};\r\n\r\nvar platformDirectives = {\r\n    model: directive,\r\n    show: show\r\n};\r\n\r\n// Provides transition support for a single element/component.\r\nvar transitionProps = {\r\n    name: String,\r\n    appear: Boolean,\r\n    css: Boolean,\r\n    mode: String,\r\n    type: String,\r\n    enterClass: String,\r\n    leaveClass: String,\r\n    enterToClass: String,\r\n    leaveToClass: String,\r\n    enterActiveClass: String,\r\n    leaveActiveClass: String,\r\n    appearClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    duration: [Number, String, Object]\r\n};\r\n// in case the child is also an abstract component, e.g. <keep-alive>\r\n// we want to recursively retrieve the real component to be rendered\r\nfunction getRealChild(vnode) {\r\n    var compOptions = vnode && vnode.componentOptions;\r\n    if (compOptions && compOptions.Ctor.options.abstract) {\r\n        return getRealChild(getFirstComponentChild(compOptions.children));\r\n    }\r\n    else {\r\n        return vnode;\r\n    }\r\n}\r\nfunction extractTransitionData(comp) {\r\n    var data = {};\r\n    var options = comp.$options;\r\n    // props\r\n    for (var key in options.propsData) {\r\n        data[key] = comp[key];\r\n    }\r\n    // events.\r\n    // extract listeners and pass them directly to the transition methods\r\n    var listeners = options._parentListeners;\r\n    for (var key in listeners) {\r\n        data[camelize(key)] = listeners[key];\r\n    }\r\n    return data;\r\n}\r\nfunction placeholder(h, rawChild) {\r\n    // @ts-expect-error\r\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\r\n        return h('keep-alive', {\r\n            props: rawChild.componentOptions.propsData\r\n        });\r\n    }\r\n}\r\nfunction hasParentTransition(vnode) {\r\n    while ((vnode = vnode.parent)) {\r\n        if (vnode.data.transition) {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nfunction isSameChild(child, oldChild) {\r\n    return oldChild.key === child.key && oldChild.tag === child.tag;\r\n}\r\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\r\nvar isVShowDirective = function (d) { return d.name === 'show'; };\r\nvar Transition = {\r\n    name: 'transition',\r\n    props: transitionProps,\r\n    abstract: true,\r\n    render: function (h) {\r\n        var _this = this;\r\n        var children = this.$slots.default;\r\n        if (!children) {\r\n            return;\r\n        }\r\n        // filter out text nodes (possible whitespaces)\r\n        children = children.filter(isNotTextNode);\r\n        /* istanbul ignore if */\r\n        if (!children.length) {\r\n            return;\r\n        }\r\n        // warn multiple elements\r\n        if (false) // removed by dead control flow\n{}\r\n        var mode = this.mode;\r\n        // warn invalid mode\r\n        if (false) // removed by dead control flow\n{}\r\n        var rawChild = children[0];\r\n        // if this is a component root node and the component's\r\n        // parent container node also has transition, skip.\r\n        if (hasParentTransition(this.$vnode)) {\r\n            return rawChild;\r\n        }\r\n        // apply transition data to child\r\n        // use getRealChild() to ignore abstract components e.g. keep-alive\r\n        var child = getRealChild(rawChild);\r\n        /* istanbul ignore if */\r\n        if (!child) {\r\n            return rawChild;\r\n        }\r\n        if (this._leaving) {\r\n            return placeholder(h, rawChild);\r\n        }\r\n        // ensure a key that is unique to the vnode type and to this transition\r\n        // component instance. This key will be used to remove pending leaving nodes\r\n        // during entering.\r\n        var id = \"__transition-\".concat(this._uid, \"-\");\r\n        child.key =\r\n            child.key == null\r\n                ? child.isComment\r\n                    ? id + 'comment'\r\n                    : id + child.tag\r\n                : isPrimitive(child.key)\r\n                    ? String(child.key).indexOf(id) === 0\r\n                        ? child.key\r\n                        : id + child.key\r\n                    : child.key;\r\n        var data = ((child.data || (child.data = {})).transition =\r\n            extractTransitionData(this));\r\n        var oldRawChild = this._vnode;\r\n        var oldChild = getRealChild(oldRawChild);\r\n        // mark v-show\r\n        // so that the transition module can hand over the control to the directive\r\n        if (child.data.directives && child.data.directives.some(isVShowDirective)) {\r\n            child.data.show = true;\r\n        }\r\n        if (oldChild &&\r\n            oldChild.data &&\r\n            !isSameChild(child, oldChild) &&\r\n            !isAsyncPlaceholder(oldChild) &&\r\n            // #6687 component root is a comment node\r\n            !(oldChild.componentInstance &&\r\n                oldChild.componentInstance._vnode.isComment)) {\r\n            // replace old child transition data with fresh one\r\n            // important for dynamic transitions!\r\n            var oldData = (oldChild.data.transition = extend({}, data));\r\n            // handle transition mode\r\n            if (mode === 'out-in') {\r\n                // return placeholder node and queue update when leave finishes\r\n                this._leaving = true;\r\n                mergeVNodeHook(oldData, 'afterLeave', function () {\r\n                    _this._leaving = false;\r\n                    _this.$forceUpdate();\r\n                });\r\n                return placeholder(h, rawChild);\r\n            }\r\n            else if (mode === 'in-out') {\r\n                if (isAsyncPlaceholder(child)) {\r\n                    return oldRawChild;\r\n                }\r\n                var delayedLeave_1;\r\n                var performLeave = function () {\r\n                    delayedLeave_1();\r\n                };\r\n                mergeVNodeHook(data, 'afterEnter', performLeave);\r\n                mergeVNodeHook(data, 'enterCancelled', performLeave);\r\n                mergeVNodeHook(oldData, 'delayLeave', function (leave) {\r\n                    delayedLeave_1 = leave;\r\n                });\r\n            }\r\n        }\r\n        return rawChild;\r\n    }\r\n};\r\n\r\n// Provides transition support for list items.\r\nvar props = extend({\r\n    tag: String,\r\n    moveClass: String\r\n}, transitionProps);\r\ndelete props.mode;\r\nvar TransitionGroup = {\r\n    props: props,\r\n    beforeMount: function () {\r\n        var _this = this;\r\n        var update = this._update;\r\n        this._update = function (vnode, hydrating) {\r\n            var restoreActiveInstance = setActiveInstance(_this);\r\n            // force removing pass\r\n            _this.__patch__(_this._vnode, _this.kept, false, // hydrating\r\n            true // removeOnly (!important, avoids unnecessary moves)\r\n            );\r\n            _this._vnode = _this.kept;\r\n            restoreActiveInstance();\r\n            update.call(_this, vnode, hydrating);\r\n        };\r\n    },\r\n    render: function (h) {\r\n        var tag = this.tag || this.$vnode.data.tag || 'span';\r\n        var map = Object.create(null);\r\n        var prevChildren = (this.prevChildren = this.children);\r\n        var rawChildren = this.$slots.default || [];\r\n        var children = (this.children = []);\r\n        var transitionData = extractTransitionData(this);\r\n        for (var i = 0; i < rawChildren.length; i++) {\r\n            var c = rawChildren[i];\r\n            if (c.tag) {\r\n                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\r\n                    children.push(c);\r\n                    map[c.key] = c;\r\n                    (c.data || (c.data = {})).transition = transitionData;\r\n                }\r\n                else if (false) // removed by dead control flow\n{ var name_1, opts; }\r\n            }\r\n        }\r\n        if (prevChildren) {\r\n            var kept = [];\r\n            var removed = [];\r\n            for (var i = 0; i < prevChildren.length; i++) {\r\n                var c = prevChildren[i];\r\n                c.data.transition = transitionData;\r\n                // @ts-expect-error .getBoundingClientRect is not typed in Node\r\n                c.data.pos = c.elm.getBoundingClientRect();\r\n                if (map[c.key]) {\r\n                    kept.push(c);\r\n                }\r\n                else {\r\n                    removed.push(c);\r\n                }\r\n            }\r\n            this.kept = h(tag, null, kept);\r\n            this.removed = removed;\r\n        }\r\n        return h(tag, null, children);\r\n    },\r\n    updated: function () {\r\n        var children = this.prevChildren;\r\n        var moveClass = this.moveClass || (this.name || 'v') + '-move';\r\n        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\r\n            return;\r\n        }\r\n        // we divide the work into three loops to avoid mixing DOM reads and writes\r\n        // in each iteration - which helps prevent layout thrashing.\r\n        children.forEach(callPendingCbs);\r\n        children.forEach(recordPosition);\r\n        children.forEach(applyTranslation);\r\n        // force reflow to put everything in position\r\n        // assign to this to avoid being removed in tree-shaking\r\n        // $flow-disable-line\r\n        this._reflow = document.body.offsetHeight;\r\n        children.forEach(function (c) {\r\n            if (c.data.moved) {\r\n                var el_1 = c.elm;\r\n                var s = el_1.style;\r\n                addTransitionClass(el_1, moveClass);\r\n                s.transform = s.WebkitTransform = s.transitionDuration = '';\r\n                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {\r\n                    if (e && e.target !== el_1) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el_1.removeEventListener(transitionEndEvent, cb);\r\n                        el_1._moveCb = null;\r\n                        removeTransitionClass(el_1, moveClass);\r\n                    }\r\n                }));\r\n            }\r\n        });\r\n    },\r\n    methods: {\r\n        hasMove: function (el, moveClass) {\r\n            /* istanbul ignore if */\r\n            if (!hasTransition) {\r\n                return false;\r\n            }\r\n            /* istanbul ignore if */\r\n            if (this._hasMove) {\r\n                return this._hasMove;\r\n            }\r\n            // Detect whether an element with the move class applied has\r\n            // CSS transitions. Since the element may be inside an entering\r\n            // transition at this very moment, we make a clone of it and remove\r\n            // all other transition classes applied to ensure only the move class\r\n            // is applied.\r\n            var clone = el.cloneNode();\r\n            if (el._transitionClasses) {\r\n                el._transitionClasses.forEach(function (cls) {\r\n                    removeClass(clone, cls);\r\n                });\r\n            }\r\n            addClass(clone, moveClass);\r\n            clone.style.display = 'none';\r\n            this.$el.appendChild(clone);\r\n            var info = getTransitionInfo(clone);\r\n            this.$el.removeChild(clone);\r\n            return (this._hasMove = info.hasTransform);\r\n        }\r\n    }\r\n};\r\nfunction callPendingCbs(c) {\r\n    /* istanbul ignore if */\r\n    if (c.elm._moveCb) {\r\n        c.elm._moveCb();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (c.elm._enterCb) {\r\n        c.elm._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    c.data.newPos = c.elm.getBoundingClientRect();\r\n}\r\nfunction applyTranslation(c) {\r\n    var oldPos = c.data.pos;\r\n    var newPos = c.data.newPos;\r\n    var dx = oldPos.left - newPos.left;\r\n    var dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        c.data.moved = true;\r\n        var s = c.elm.style;\r\n        s.transform = s.WebkitTransform = \"translate(\".concat(dx, \"px,\").concat(dy, \"px)\");\r\n        s.transitionDuration = '0s';\r\n    }\r\n}\r\n\r\nvar platformComponents = {\r\n    Transition: Transition,\r\n    TransitionGroup: TransitionGroup\r\n};\r\n\r\n// install platform specific utils\r\nVue.config.mustUseProp = mustUseProp;\r\nVue.config.isReservedTag = isReservedTag;\r\nVue.config.isReservedAttr = isReservedAttr;\r\nVue.config.getTagNamespace = getTagNamespace;\r\nVue.config.isUnknownElement = isUnknownElement;\r\n// install platform runtime directives & components\r\nextend(Vue.options.directives, platformDirectives);\r\nextend(Vue.options.components, platformComponents);\r\n// install platform patch function\r\nVue.prototype.__patch__ = inBrowser ? patch : noop;\r\n// public mount method\r\nVue.prototype.$mount = function (el, hydrating) {\r\n    el = el && inBrowser ? query(el) : undefined;\r\n    return mountComponent(this, el, hydrating);\r\n};\r\n// devtools global hook\r\n/* istanbul ignore next */\r\nif (inBrowser) {\r\n    setTimeout(function () {\r\n        if (config.devtools) {\r\n            if (devtools) {\r\n                devtools.emit('init', Vue);\r\n            }\r\n            else if (false) // removed by dead control flow\n{}\r\n        }\r\n        if (false) // removed by dead control flow\n{}\r\n    }, 0);\r\n}\r\n\r\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\r\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\r\nvar buildRegex = cached(function (delimiters) {\r\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\r\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\r\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\r\n});\r\nfunction parseText(text, delimiters) {\r\n    //@ts-expect-error\r\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\r\n    if (!tagRE.test(text)) {\r\n        return;\r\n    }\r\n    var tokens = [];\r\n    var rawTokens = [];\r\n    var lastIndex = (tagRE.lastIndex = 0);\r\n    var match, index, tokenValue;\r\n    while ((match = tagRE.exec(text))) {\r\n        index = match.index;\r\n        // push text token\r\n        if (index > lastIndex) {\r\n            rawTokens.push((tokenValue = text.slice(lastIndex, index)));\r\n            tokens.push(JSON.stringify(tokenValue));\r\n        }\r\n        // tag token\r\n        var exp = parseFilters(match[1].trim());\r\n        tokens.push(\"_s(\".concat(exp, \")\"));\r\n        rawTokens.push({ '@binding': exp });\r\n        lastIndex = index + match[0].length;\r\n    }\r\n    if (lastIndex < text.length) {\r\n        rawTokens.push((tokenValue = text.slice(lastIndex)));\r\n        tokens.push(JSON.stringify(tokenValue));\r\n    }\r\n    return {\r\n        expression: tokens.join('+'),\r\n        tokens: rawTokens\r\n    };\r\n}\r\n\r\nfunction transformNode$1(el, options) {\r\n    var warn = options.warn || baseWarn;\r\n    var staticClass = getAndRemoveAttr(el, 'class');\r\n    if (false) // removed by dead control flow\n{ var res; }\r\n    if (staticClass) {\r\n        el.staticClass = JSON.stringify(staticClass.replace(/\\s+/g, ' ').trim());\r\n    }\r\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\r\n    if (classBinding) {\r\n        el.classBinding = classBinding;\r\n    }\r\n}\r\nfunction genData$2(el) {\r\n    var data = '';\r\n    if (el.staticClass) {\r\n        data += \"staticClass:\".concat(el.staticClass, \",\");\r\n    }\r\n    if (el.classBinding) {\r\n        data += \"class:\".concat(el.classBinding, \",\");\r\n    }\r\n    return data;\r\n}\r\nvar klass = {\r\n    staticKeys: ['staticClass'],\r\n    transformNode: transformNode$1,\r\n    genData: genData$2\r\n};\r\n\r\nfunction transformNode(el, options) {\r\n    var warn = options.warn || baseWarn;\r\n    var staticStyle = getAndRemoveAttr(el, 'style');\r\n    if (staticStyle) {\r\n        /* istanbul ignore if */\r\n        if (false) // removed by dead control flow\n{ var res; }\r\n        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\r\n    }\r\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\r\n    if (styleBinding) {\r\n        el.styleBinding = styleBinding;\r\n    }\r\n}\r\nfunction genData$1(el) {\r\n    var data = '';\r\n    if (el.staticStyle) {\r\n        data += \"staticStyle:\".concat(el.staticStyle, \",\");\r\n    }\r\n    if (el.styleBinding) {\r\n        data += \"style:(\".concat(el.styleBinding, \"),\");\r\n    }\r\n    return data;\r\n}\r\nvar style = {\r\n    staticKeys: ['staticStyle'],\r\n    transformNode: transformNode,\r\n    genData: genData$1\r\n};\r\n\r\nvar decoder;\r\nvar he = {\r\n    decode: function (html) {\r\n        decoder = decoder || document.createElement('div');\r\n        decoder.innerHTML = html;\r\n        return decoder.textContent;\r\n    }\r\n};\r\n\r\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\r\n    'link,meta,param,source,track,wbr');\r\n// Elements that you can, intentionally, leave open\r\n// (and which close themselves)\r\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\r\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\r\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\r\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\r\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\r\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\r\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\r\n    'title,tr,track');\r\n\r\n/**\r\n * Not type-checking this file because it's mostly vendor code.\r\n */\r\n// Regular Expressions for parsing tags and attributes\r\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\r\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\r\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\".concat(unicodeRegExp.source, \"]*\");\r\nvar qnameCapture = \"((?:\".concat(ncname, \"\\\\:)?\").concat(ncname, \")\");\r\nvar startTagOpen = new RegExp(\"^<\".concat(qnameCapture));\r\nvar startTagClose = /^\\s*(\\/?)>/;\r\nvar endTag = new RegExp(\"^<\\\\/\".concat(qnameCapture, \"[^>]*>\"));\r\nvar doctype = /^<!DOCTYPE [^>]+>/i;\r\n// #7298: escape - to avoid being passed as HTML comment when inlined in page\r\nvar comment = /^<!\\--/;\r\nvar conditionalComment = /^<!\\[/;\r\n// Special Elements (can contain anything)\r\nvar isPlainTextElement = makeMap('script,style,textarea', true);\r\nvar reCache = {};\r\nvar decodingMap = {\r\n    '&lt;': '<',\r\n    '&gt;': '>',\r\n    '&quot;': '\"',\r\n    '&amp;': '&',\r\n    '&#10;': '\\n',\r\n    '&#9;': '\\t',\r\n    '&#39;': \"'\"\r\n};\r\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\r\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\r\n// #5992\r\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\r\nvar shouldIgnoreFirstNewline = function (tag, html) {\r\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\r\n};\r\nfunction decodeAttr(value, shouldDecodeNewlines) {\r\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\r\n    return value.replace(re, function (match) { return decodingMap[match]; });\r\n}\r\nfunction parseHTML(html, options) {\r\n    var stack = [];\r\n    var expectHTML = options.expectHTML;\r\n    var isUnaryTag = options.isUnaryTag || no;\r\n    var canBeLeftOpenTag = options.canBeLeftOpenTag || no;\r\n    var index = 0;\r\n    var last, lastTag;\r\n    var _loop_1 = function () {\r\n        last = html;\r\n        // Make sure we're not in a plaintext content element like script/style\r\n        if (!lastTag || !isPlainTextElement(lastTag)) {\r\n            var textEnd = html.indexOf('<');\r\n            if (textEnd === 0) {\r\n                // Comment:\r\n                if (comment.test(html)) {\r\n                    var commentEnd = html.indexOf('--\x3e');\r\n                    if (commentEnd >= 0) {\r\n                        if (options.shouldKeepComment && options.comment) {\r\n                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\r\n                        }\r\n                        advance(commentEnd + 3);\r\n                        return \"continue\";\r\n                    }\r\n                }\r\n                // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\r\n                if (conditionalComment.test(html)) {\r\n                    var conditionalEnd = html.indexOf(']>');\r\n                    if (conditionalEnd >= 0) {\r\n                        advance(conditionalEnd + 2);\r\n                        return \"continue\";\r\n                    }\r\n                }\r\n                // Doctype:\r\n                var doctypeMatch = html.match(doctype);\r\n                if (doctypeMatch) {\r\n                    advance(doctypeMatch[0].length);\r\n                    return \"continue\";\r\n                }\r\n                // End tag:\r\n                var endTagMatch = html.match(endTag);\r\n                if (endTagMatch) {\r\n                    var curIndex = index;\r\n                    advance(endTagMatch[0].length);\r\n                    parseEndTag(endTagMatch[1], curIndex, index);\r\n                    return \"continue\";\r\n                }\r\n                // Start tag:\r\n                var startTagMatch = parseStartTag();\r\n                if (startTagMatch) {\r\n                    handleStartTag(startTagMatch);\r\n                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\r\n                        advance(1);\r\n                    }\r\n                    return \"continue\";\r\n                }\r\n            }\r\n            var text = void 0, rest = void 0, next = void 0;\r\n            if (textEnd >= 0) {\r\n                rest = html.slice(textEnd);\r\n                while (!endTag.test(rest) &&\r\n                    !startTagOpen.test(rest) &&\r\n                    !comment.test(rest) &&\r\n                    !conditionalComment.test(rest)) {\r\n                    // < in plain text, be forgiving and treat it as text\r\n                    next = rest.indexOf('<', 1);\r\n                    if (next < 0)\r\n                        break;\r\n                    textEnd += next;\r\n                    rest = html.slice(textEnd);\r\n                }\r\n                text = html.substring(0, textEnd);\r\n            }\r\n            if (textEnd < 0) {\r\n                text = html;\r\n            }\r\n            if (text) {\r\n                advance(text.length);\r\n            }\r\n            if (options.chars && text) {\r\n                options.chars(text, index - text.length, index);\r\n            }\r\n        }\r\n        else {\r\n            var endTagLength_1 = 0;\r\n            var stackedTag_1 = lastTag.toLowerCase();\r\n            var reStackedTag = reCache[stackedTag_1] ||\r\n                (reCache[stackedTag_1] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag_1 + '[^>]*>)', 'i'));\r\n            var rest = html.replace(reStackedTag, function (all, text, endTag) {\r\n                endTagLength_1 = endTag.length;\r\n                if (!isPlainTextElement(stackedTag_1) && stackedTag_1 !== 'noscript') {\r\n                    text = text\r\n                        .replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\r\n                        .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\r\n                }\r\n                if (shouldIgnoreFirstNewline(stackedTag_1, text)) {\r\n                    text = text.slice(1);\r\n                }\r\n                if (options.chars) {\r\n                    options.chars(text);\r\n                }\r\n                return '';\r\n            });\r\n            index += html.length - rest.length;\r\n            html = rest;\r\n            parseEndTag(stackedTag_1, index - endTagLength_1, index);\r\n        }\r\n        if (html === last) {\r\n            options.chars && options.chars(html);\r\n            if (false) // removed by dead control flow\n{}\r\n            return \"break\";\r\n        }\r\n    };\r\n    while (html) {\r\n        var state_1 = _loop_1();\r\n        if (state_1 === \"break\")\r\n            break;\r\n    }\r\n    // Clean up any remaining tags\r\n    parseEndTag();\r\n    function advance(n) {\r\n        index += n;\r\n        html = html.substring(n);\r\n    }\r\n    function parseStartTag() {\r\n        var start = html.match(startTagOpen);\r\n        if (start) {\r\n            var match = {\r\n                tagName: start[1],\r\n                attrs: [],\r\n                start: index\r\n            };\r\n            advance(start[0].length);\r\n            var end = void 0, attr = void 0;\r\n            while (!(end = html.match(startTagClose)) &&\r\n                (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\r\n                attr.start = index;\r\n                advance(attr[0].length);\r\n                attr.end = index;\r\n                match.attrs.push(attr);\r\n            }\r\n            if (end) {\r\n                match.unarySlash = end[1];\r\n                advance(end[0].length);\r\n                match.end = index;\r\n                return match;\r\n            }\r\n        }\r\n    }\r\n    function handleStartTag(match) {\r\n        var tagName = match.tagName;\r\n        var unarySlash = match.unarySlash;\r\n        if (expectHTML) {\r\n            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\r\n                parseEndTag(lastTag);\r\n            }\r\n            if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\r\n                parseEndTag(tagName);\r\n            }\r\n        }\r\n        var unary = isUnaryTag(tagName) || !!unarySlash;\r\n        var l = match.attrs.length;\r\n        var attrs = new Array(l);\r\n        for (var i = 0; i < l; i++) {\r\n            var args = match.attrs[i];\r\n            var value = args[3] || args[4] || args[5] || '';\r\n            var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\r\n                ? options.shouldDecodeNewlinesForHref\r\n                : options.shouldDecodeNewlines;\r\n            attrs[i] = {\r\n                name: args[1],\r\n                value: decodeAttr(value, shouldDecodeNewlines)\r\n            };\r\n            if (false) // removed by dead control flow\n{}\r\n        }\r\n        if (!unary) {\r\n            stack.push({\r\n                tag: tagName,\r\n                lowerCasedTag: tagName.toLowerCase(),\r\n                attrs: attrs,\r\n                start: match.start,\r\n                end: match.end\r\n            });\r\n            lastTag = tagName;\r\n        }\r\n        if (options.start) {\r\n            options.start(tagName, attrs, unary, match.start, match.end);\r\n        }\r\n    }\r\n    function parseEndTag(tagName, start, end) {\r\n        var pos, lowerCasedTagName;\r\n        if (start == null)\r\n            start = index;\r\n        if (end == null)\r\n            end = index;\r\n        // Find the closest opened tag of the same type\r\n        if (tagName) {\r\n            lowerCasedTagName = tagName.toLowerCase();\r\n            for (pos = stack.length - 1; pos >= 0; pos--) {\r\n                if (stack[pos].lowerCasedTag === lowerCasedTagName) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // If no tag name is provided, clean shop\r\n            pos = 0;\r\n        }\r\n        if (pos >= 0) {\r\n            // Close all the open elements, up the stack\r\n            for (var i = stack.length - 1; i >= pos; i--) {\r\n                if (false) // removed by dead control flow\n{}\r\n                if (options.end) {\r\n                    options.end(stack[i].tag, start, end);\r\n                }\r\n            }\r\n            // Remove the open elements from the stack\r\n            stack.length = pos;\r\n            lastTag = pos && stack[pos - 1].tag;\r\n        }\r\n        else if (lowerCasedTagName === 'br') {\r\n            if (options.start) {\r\n                options.start(tagName, [], true, start, end);\r\n            }\r\n        }\r\n        else if (lowerCasedTagName === 'p') {\r\n            if (options.start) {\r\n                options.start(tagName, [], false, start, end);\r\n            }\r\n            if (options.end) {\r\n                options.end(tagName, start, end);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar onRE = /^@|^v-on:/;\r\nvar dirRE = /^v-|^@|^:|^#/;\r\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\nvar stripParensRE = /^\\(|\\)$/g;\r\nvar dynamicArgRE = /^\\[.*\\]$/;\r\nvar argRE = /:(.*)$/;\r\nvar bindRE = /^:|^\\.|^v-bind:/;\r\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\r\nvar slotRE = /^v-slot(:|$)|^#/;\r\nvar lineBreakRE = /[\\r\\n]/;\r\nvar whitespaceRE = /[ \\f\\t\\r\\n]+/g;\r\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\r\nvar decodeHTMLCached = cached(he.decode);\r\nvar emptySlotScopeToken = \"_empty_\";\r\n// configurable state\r\nvar warn;\r\nvar delimiters;\r\nvar transforms;\r\nvar preTransforms;\r\nvar postTransforms;\r\nvar platformIsPreTag;\r\nvar platformMustUseProp;\r\nvar platformGetTagNamespace;\r\nvar maybeComponent;\r\nfunction createASTElement(tag, attrs, parent) {\r\n    return {\r\n        type: 1,\r\n        tag: tag,\r\n        attrsList: attrs,\r\n        attrsMap: makeAttrsMap(attrs),\r\n        rawAttrsMap: {},\r\n        parent: parent,\r\n        children: []\r\n    };\r\n}\r\n/**\r\n * Convert HTML string to AST.\r\n */\r\nfunction parse(template, options) {\r\n    warn = options.warn || baseWarn;\r\n    platformIsPreTag = options.isPreTag || no;\r\n    platformMustUseProp = options.mustUseProp || no;\r\n    platformGetTagNamespace = options.getTagNamespace || no;\r\n    var isReservedTag = options.isReservedTag || no;\r\n    maybeComponent = function (el) {\r\n        return !!(el.component ||\r\n            el.attrsMap[':is'] ||\r\n            el.attrsMap['v-bind:is'] ||\r\n            !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));\r\n    };\r\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\r\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\r\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\r\n    delimiters = options.delimiters;\r\n    var stack = [];\r\n    var preserveWhitespace = options.preserveWhitespace !== false;\r\n    var whitespaceOption = options.whitespace;\r\n    var root;\r\n    var currentParent;\r\n    var inVPre = false;\r\n    var inPre = false;\r\n    var warned = false;\r\n    function warnOnce(msg, range) {\r\n        if (!warned) {\r\n            warned = true;\r\n            warn(msg, range);\r\n        }\r\n    }\r\n    function closeElement(element) {\r\n        trimEndingWhitespace(element);\r\n        if (!inVPre && !element.processed) {\r\n            element = processElement(element, options);\r\n        }\r\n        // tree management\r\n        if (!stack.length && element !== root) {\r\n            // allow root elements with v-if, v-else-if and v-else\r\n            if (root.if && (element.elseif || element.else)) {\r\n                if (false) // removed by dead control flow\n{}\r\n                addIfCondition(root, {\r\n                    exp: element.elseif,\r\n                    block: element\r\n                });\r\n            }\r\n            else if (false) // removed by dead control flow\n{}\r\n        }\r\n        if (currentParent && !element.forbidden) {\r\n            if (element.elseif || element.else) {\r\n                processIfConditions(element, currentParent);\r\n            }\r\n            else {\r\n                if (element.slotScope) {\r\n                    // scoped slot\r\n                    // keep it in the children list so that v-else(-if) conditions can\r\n                    // find it as the prev node.\r\n                    var name_1 = element.slotTarget || '\"default\"';\r\n                    (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name_1] = element;\r\n                }\r\n                currentParent.children.push(element);\r\n                element.parent = currentParent;\r\n            }\r\n        }\r\n        // final children cleanup\r\n        // filter out scoped slots\r\n        element.children = element.children.filter(function (c) { return !c.slotScope; });\r\n        // remove trailing whitespace node again\r\n        trimEndingWhitespace(element);\r\n        // check pre state\r\n        if (element.pre) {\r\n            inVPre = false;\r\n        }\r\n        if (platformIsPreTag(element.tag)) {\r\n            inPre = false;\r\n        }\r\n        // apply post-transforms\r\n        for (var i = 0; i < postTransforms.length; i++) {\r\n            postTransforms[i](element, options);\r\n        }\r\n    }\r\n    function trimEndingWhitespace(el) {\r\n        // remove trailing whitespace node\r\n        if (!inPre) {\r\n            var lastNode = void 0;\r\n            while ((lastNode = el.children[el.children.length - 1]) &&\r\n                lastNode.type === 3 &&\r\n                lastNode.text === ' ') {\r\n                el.children.pop();\r\n            }\r\n        }\r\n    }\r\n    function checkRootConstraints(el) {\r\n        if (el.tag === 'slot' || el.tag === 'template') {\r\n            warnOnce(\"Cannot use <\".concat(el.tag, \"> as component root element because it may \") +\r\n                'contain multiple nodes.', { start: el.start });\r\n        }\r\n        if (el.attrsMap.hasOwnProperty('v-for')) {\r\n            warnOnce('Cannot use v-for on stateful component root element because ' +\r\n                'it renders multiple elements.', el.rawAttrsMap['v-for']);\r\n        }\r\n    }\r\n    parseHTML(template, {\r\n        warn: warn,\r\n        expectHTML: options.expectHTML,\r\n        isUnaryTag: options.isUnaryTag,\r\n        canBeLeftOpenTag: options.canBeLeftOpenTag,\r\n        shouldDecodeNewlines: options.shouldDecodeNewlines,\r\n        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\r\n        shouldKeepComment: options.comments,\r\n        outputSourceRange: options.outputSourceRange,\r\n        start: function (tag, attrs, unary, start, end) {\r\n            // check namespace.\r\n            // inherit parent ns if there is one\r\n            var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\r\n            // handle IE svg bug\r\n            /* istanbul ignore if */\r\n            if (isIE && ns === 'svg') {\r\n                attrs = guardIESVGBug(attrs);\r\n            }\r\n            var element = createASTElement(tag, attrs, currentParent);\r\n            if (ns) {\r\n                element.ns = ns;\r\n            }\r\n            if (false) // removed by dead control flow\n{}\r\n            if (isForbiddenTag(element) && !isServerRendering()) {\r\n                element.forbidden = true;\r\n                 false &&\r\n                    0;\r\n            }\r\n            // apply pre-transforms\r\n            for (var i = 0; i < preTransforms.length; i++) {\r\n                element = preTransforms[i](element, options) || element;\r\n            }\r\n            if (!inVPre) {\r\n                processPre(element);\r\n                if (element.pre) {\r\n                    inVPre = true;\r\n                }\r\n            }\r\n            if (platformIsPreTag(element.tag)) {\r\n                inPre = true;\r\n            }\r\n            if (inVPre) {\r\n                processRawAttrs(element);\r\n            }\r\n            else if (!element.processed) {\r\n                // structural directives\r\n                processFor(element);\r\n                processIf(element);\r\n                processOnce(element);\r\n            }\r\n            if (!root) {\r\n                root = element;\r\n                if (false) // removed by dead control flow\n{}\r\n            }\r\n            if (!unary) {\r\n                currentParent = element;\r\n                stack.push(element);\r\n            }\r\n            else {\r\n                closeElement(element);\r\n            }\r\n        },\r\n        end: function (tag, start, end) {\r\n            var element = stack[stack.length - 1];\r\n            // pop stack\r\n            stack.length -= 1;\r\n            currentParent = stack[stack.length - 1];\r\n            if (false) // removed by dead control flow\n{}\r\n            closeElement(element);\r\n        },\r\n        chars: function (text, start, end) {\r\n            if (!currentParent) {\r\n                if (false) // removed by dead control flow\n{}\r\n                return;\r\n            }\r\n            // IE textarea placeholder bug\r\n            /* istanbul ignore if */\r\n            if (isIE &&\r\n                currentParent.tag === 'textarea' &&\r\n                currentParent.attrsMap.placeholder === text) {\r\n                return;\r\n            }\r\n            var children = currentParent.children;\r\n            if (inPre || text.trim()) {\r\n                text = isTextTag(currentParent)\r\n                    ? text\r\n                    : decodeHTMLCached(text);\r\n            }\r\n            else if (!children.length) {\r\n                // remove the whitespace-only node right after an opening tag\r\n                text = '';\r\n            }\r\n            else if (whitespaceOption) {\r\n                if (whitespaceOption === 'condense') {\r\n                    // in condense mode, remove the whitespace node if it contains\r\n                    // line break, otherwise condense to a single space\r\n                    text = lineBreakRE.test(text) ? '' : ' ';\r\n                }\r\n                else {\r\n                    text = ' ';\r\n                }\r\n            }\r\n            else {\r\n                text = preserveWhitespace ? ' ' : '';\r\n            }\r\n            if (text) {\r\n                if (!inPre && whitespaceOption === 'condense') {\r\n                    // condense consecutive whitespaces into single space\r\n                    text = text.replace(whitespaceRE, ' ');\r\n                }\r\n                var res = void 0;\r\n                var child = void 0;\r\n                if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\r\n                    child = {\r\n                        type: 2,\r\n                        expression: res.expression,\r\n                        tokens: res.tokens,\r\n                        text: text\r\n                    };\r\n                }\r\n                else if (text !== ' ' ||\r\n                    !children.length ||\r\n                    children[children.length - 1].text !== ' ') {\r\n                    child = {\r\n                        type: 3,\r\n                        text: text\r\n                    };\r\n                }\r\n                if (child) {\r\n                    if (false) // removed by dead control flow\n{}\r\n                    children.push(child);\r\n                }\r\n            }\r\n        },\r\n        comment: function (text, start, end) {\r\n            // adding anything as a sibling to the root node is forbidden\r\n            // comments should still be allowed, but ignored\r\n            if (currentParent) {\r\n                var child = {\r\n                    type: 3,\r\n                    text: text,\r\n                    isComment: true\r\n                };\r\n                if (false) // removed by dead control flow\n{}\r\n                currentParent.children.push(child);\r\n            }\r\n        }\r\n    });\r\n    return root;\r\n}\r\nfunction processPre(el) {\r\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\r\n        el.pre = true;\r\n    }\r\n}\r\nfunction processRawAttrs(el) {\r\n    var list = el.attrsList;\r\n    var len = list.length;\r\n    if (len) {\r\n        var attrs = (el.attrs = new Array(len));\r\n        for (var i = 0; i < len; i++) {\r\n            attrs[i] = {\r\n                name: list[i].name,\r\n                value: JSON.stringify(list[i].value)\r\n            };\r\n            if (list[i].start != null) {\r\n                attrs[i].start = list[i].start;\r\n                attrs[i].end = list[i].end;\r\n            }\r\n        }\r\n    }\r\n    else if (!el.pre) {\r\n        // non root node in pre blocks with no attributes\r\n        el.plain = true;\r\n    }\r\n}\r\nfunction processElement(element, options) {\r\n    processKey(element);\r\n    // determine whether this is a plain element after\r\n    // removing structural attributes\r\n    element.plain =\r\n        !element.key && !element.scopedSlots && !element.attrsList.length;\r\n    processRef(element);\r\n    processSlotContent(element);\r\n    processSlotOutlet(element);\r\n    processComponent(element);\r\n    for (var i = 0; i < transforms.length; i++) {\r\n        element = transforms[i](element, options) || element;\r\n    }\r\n    processAttrs(element);\r\n    return element;\r\n}\r\nfunction processKey(el) {\r\n    var exp = getBindingAttr(el, 'key');\r\n    if (exp) {\r\n        if (false) // removed by dead control flow\n{ var parent_1, iterator; }\r\n        el.key = exp;\r\n    }\r\n}\r\nfunction processRef(el) {\r\n    var ref = getBindingAttr(el, 'ref');\r\n    if (ref) {\r\n        el.ref = ref;\r\n        el.refInFor = checkInFor(el);\r\n    }\r\n}\r\nfunction processFor(el) {\r\n    var exp;\r\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\r\n        var res = parseFor(exp);\r\n        if (res) {\r\n            extend(el, res);\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n}\r\nfunction parseFor(exp) {\r\n    var inMatch = exp.match(forAliasRE);\r\n    if (!inMatch)\r\n        return;\r\n    var res = {};\r\n    res.for = inMatch[2].trim();\r\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\r\n    var iteratorMatch = alias.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n        res.alias = alias.replace(forIteratorRE, '').trim();\r\n        res.iterator1 = iteratorMatch[1].trim();\r\n        if (iteratorMatch[2]) {\r\n            res.iterator2 = iteratorMatch[2].trim();\r\n        }\r\n    }\r\n    else {\r\n        res.alias = alias;\r\n    }\r\n    return res;\r\n}\r\nfunction processIf(el) {\r\n    var exp = getAndRemoveAttr(el, 'v-if');\r\n    if (exp) {\r\n        el.if = exp;\r\n        addIfCondition(el, {\r\n            exp: exp,\r\n            block: el\r\n        });\r\n    }\r\n    else {\r\n        if (getAndRemoveAttr(el, 'v-else') != null) {\r\n            el.else = true;\r\n        }\r\n        var elseif = getAndRemoveAttr(el, 'v-else-if');\r\n        if (elseif) {\r\n            el.elseif = elseif;\r\n        }\r\n    }\r\n}\r\nfunction processIfConditions(el, parent) {\r\n    var prev = findPrevElement(parent.children);\r\n    if (prev && prev.if) {\r\n        addIfCondition(prev, {\r\n            exp: el.elseif,\r\n            block: el\r\n        });\r\n    }\r\n    else if (false) // removed by dead control flow\n{}\r\n}\r\nfunction findPrevElement(children) {\r\n    var i = children.length;\r\n    while (i--) {\r\n        if (children[i].type === 1) {\r\n            return children[i];\r\n        }\r\n        else {\r\n            if (false) // removed by dead control flow\n{}\r\n            children.pop();\r\n        }\r\n    }\r\n}\r\nfunction addIfCondition(el, condition) {\r\n    if (!el.ifConditions) {\r\n        el.ifConditions = [];\r\n    }\r\n    el.ifConditions.push(condition);\r\n}\r\nfunction processOnce(el) {\r\n    var once = getAndRemoveAttr(el, 'v-once');\r\n    if (once != null) {\r\n        el.once = true;\r\n    }\r\n}\r\n// handle content being passed to a component as slot,\r\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\r\nfunction processSlotContent(el) {\r\n    var slotScope;\r\n    if (el.tag === 'template') {\r\n        slotScope = getAndRemoveAttr(el, 'scope');\r\n        /* istanbul ignore if */\r\n        if (false) // removed by dead control flow\n{}\r\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\r\n    }\r\n    else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\r\n        /* istanbul ignore if */\r\n        if (false) // removed by dead control flow\n{}\r\n        el.slotScope = slotScope;\r\n    }\r\n    // slot=\"xxx\"\r\n    var slotTarget = getBindingAttr(el, 'slot');\r\n    if (slotTarget) {\r\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\r\n        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\r\n        // preserve slot as an attribute for native shadow DOM compat\r\n        // only for non-scoped slots.\r\n        if (el.tag !== 'template' && !el.slotScope) {\r\n            addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\r\n        }\r\n    }\r\n    // 2.6 v-slot syntax\r\n    {\r\n        if (el.tag === 'template') {\r\n            // v-slot on <template>\r\n            var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\r\n            if (slotBinding) {\r\n                if (false) // removed by dead control flow\n{}\r\n                var _a = getSlotName(slotBinding), name_2 = _a.name, dynamic = _a.dynamic;\r\n                el.slotTarget = name_2;\r\n                el.slotTargetDynamic = dynamic;\r\n                el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\r\n            }\r\n        }\r\n        else {\r\n            // v-slot on component, denotes default slot\r\n            var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\r\n            if (slotBinding) {\r\n                if (false) // removed by dead control flow\n{}\r\n                // add the component's children to its default slot\r\n                var slots = el.scopedSlots || (el.scopedSlots = {});\r\n                var _b = getSlotName(slotBinding), name_3 = _b.name, dynamic = _b.dynamic;\r\n                var slotContainer_1 = (slots[name_3] = createASTElement('template', [], el));\r\n                slotContainer_1.slotTarget = name_3;\r\n                slotContainer_1.slotTargetDynamic = dynamic;\r\n                slotContainer_1.children = el.children.filter(function (c) {\r\n                    if (!c.slotScope) {\r\n                        c.parent = slotContainer_1;\r\n                        return true;\r\n                    }\r\n                });\r\n                slotContainer_1.slotScope = slotBinding.value || emptySlotScopeToken;\r\n                // remove children as they are returned from scopedSlots now\r\n                el.children = [];\r\n                // mark el non-plain so data gets generated\r\n                el.plain = false;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction getSlotName(binding) {\r\n    var name = binding.name.replace(slotRE, '');\r\n    if (!name) {\r\n        if (binding.name[0] !== '#') {\r\n            name = 'default';\r\n        }\r\n        else if (false) // removed by dead control flow\n{}\r\n    }\r\n    return dynamicArgRE.test(name)\r\n        ? // dynamic [name]\r\n            { name: name.slice(1, -1), dynamic: true }\r\n        : // static name\r\n            { name: \"\\\"\".concat(name, \"\\\"\"), dynamic: false };\r\n}\r\n// handle <slot/> outlets\r\nfunction processSlotOutlet(el) {\r\n    if (el.tag === 'slot') {\r\n        el.slotName = getBindingAttr(el, 'name');\r\n        if (false) // removed by dead control flow\n{}\r\n    }\r\n}\r\nfunction processComponent(el) {\r\n    var binding;\r\n    if ((binding = getBindingAttr(el, 'is'))) {\r\n        el.component = binding;\r\n    }\r\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\r\n        el.inlineTemplate = true;\r\n    }\r\n}\r\nfunction processAttrs(el) {\r\n    var list = el.attrsList;\r\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\r\n    for (i = 0, l = list.length; i < l; i++) {\r\n        name = rawName = list[i].name;\r\n        value = list[i].value;\r\n        if (dirRE.test(name)) {\r\n            // mark element as dynamic\r\n            el.hasBindings = true;\r\n            // modifiers\r\n            modifiers = parseModifiers(name.replace(dirRE, ''));\r\n            // support .foo shorthand syntax for the .prop modifier\r\n            if (modifiers) {\r\n                name = name.replace(modifierRE, '');\r\n            }\r\n            if (bindRE.test(name)) {\r\n                // v-bind\r\n                name = name.replace(bindRE, '');\r\n                value = parseFilters(value);\r\n                isDynamic = dynamicArgRE.test(name);\r\n                if (isDynamic) {\r\n                    name = name.slice(1, -1);\r\n                }\r\n                if (false) // removed by dead control flow\n{}\r\n                if (modifiers) {\r\n                    if (modifiers.prop && !isDynamic) {\r\n                        name = camelize(name);\r\n                        if (name === 'innerHtml')\r\n                            name = 'innerHTML';\r\n                    }\r\n                    if (modifiers.camel && !isDynamic) {\r\n                        name = camelize(name);\r\n                    }\r\n                    if (modifiers.sync) {\r\n                        syncGen = genAssignmentCode(value, \"$event\");\r\n                        if (!isDynamic) {\r\n                            addHandler(el, \"update:\".concat(camelize(name)), syncGen, null, false, warn, list[i]);\r\n                            if (hyphenate(name) !== camelize(name)) {\r\n                                addHandler(el, \"update:\".concat(hyphenate(name)), syncGen, null, false, warn, list[i]);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // handler w/ dynamic event name\r\n                            addHandler(el, \"\\\"update:\\\"+(\".concat(name, \")\"), syncGen, null, false, warn, list[i], true // dynamic\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if ((modifiers && modifiers.prop) ||\r\n                    (!el.component && platformMustUseProp(el.tag, el.attrsMap.type, name))) {\r\n                    addProp(el, name, value, list[i], isDynamic);\r\n                }\r\n                else {\r\n                    addAttr(el, name, value, list[i], isDynamic);\r\n                }\r\n            }\r\n            else if (onRE.test(name)) {\r\n                // v-on\r\n                name = name.replace(onRE, '');\r\n                isDynamic = dynamicArgRE.test(name);\r\n                if (isDynamic) {\r\n                    name = name.slice(1, -1);\r\n                }\r\n                addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic);\r\n            }\r\n            else {\r\n                // normal directives\r\n                name = name.replace(dirRE, '');\r\n                // parse arg\r\n                var argMatch = name.match(argRE);\r\n                var arg = argMatch && argMatch[1];\r\n                isDynamic = false;\r\n                if (arg) {\r\n                    name = name.slice(0, -(arg.length + 1));\r\n                    if (dynamicArgRE.test(arg)) {\r\n                        arg = arg.slice(1, -1);\r\n                        isDynamic = true;\r\n                    }\r\n                }\r\n                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\r\n                if (false) // removed by dead control flow\n{}\r\n            }\r\n        }\r\n        else {\r\n            // literal attribute\r\n            if (false) // removed by dead control flow\n{ var res; }\r\n            addAttr(el, name, JSON.stringify(value), list[i]);\r\n            // #6887 firefox doesn't update muted state if set via attribute\r\n            // even immediately after element creation\r\n            if (!el.component &&\r\n                name === 'muted' &&\r\n                platformMustUseProp(el.tag, el.attrsMap.type, name)) {\r\n                addProp(el, name, 'true', list[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction checkInFor(el) {\r\n    var parent = el;\r\n    while (parent) {\r\n        if (parent.for !== undefined) {\r\n            return true;\r\n        }\r\n        parent = parent.parent;\r\n    }\r\n    return false;\r\n}\r\nfunction parseModifiers(name) {\r\n    var match = name.match(modifierRE);\r\n    if (match) {\r\n        var ret_1 = {};\r\n        match.forEach(function (m) {\r\n            ret_1[m.slice(1)] = true;\r\n        });\r\n        return ret_1;\r\n    }\r\n}\r\nfunction makeAttrsMap(attrs) {\r\n    var map = {};\r\n    for (var i = 0, l = attrs.length; i < l; i++) {\r\n        if (false) // removed by dead control flow\n{}\r\n        map[attrs[i].name] = attrs[i].value;\r\n    }\r\n    return map;\r\n}\r\n// for script (e.g. type=\"x/template\") or style, do not decode content\r\nfunction isTextTag(el) {\r\n    return el.tag === 'script' || el.tag === 'style';\r\n}\r\nfunction isForbiddenTag(el) {\r\n    return (el.tag === 'style' ||\r\n        (el.tag === 'script' &&\r\n            (!el.attrsMap.type || el.attrsMap.type === 'text/javascript')));\r\n}\r\nvar ieNSBug = /^xmlns:NS\\d+/;\r\nvar ieNSPrefix = /^NS\\d+:/;\r\n/* istanbul ignore next */\r\nfunction guardIESVGBug(attrs) {\r\n    var res = [];\r\n    for (var i = 0; i < attrs.length; i++) {\r\n        var attr = attrs[i];\r\n        if (!ieNSBug.test(attr.name)) {\r\n            attr.name = attr.name.replace(ieNSPrefix, '');\r\n            res.push(attr);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction checkForAliasModel(el, value) {\r\n    var _el = el;\r\n    while (_el) {\r\n        if (_el.for && _el.alias === value) {\r\n            warn(\"<\".concat(el.tag, \" v-model=\\\"\").concat(value, \"\\\">: \") +\r\n                \"You are binding v-model directly to a v-for iteration alias. \" +\r\n                \"This will not be able to modify the v-for source array because \" +\r\n                \"writing to the alias is like modifying a function local variable. \" +\r\n                \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\r\n        }\r\n        _el = _el.parent;\r\n    }\r\n}\r\n\r\n/**\r\n * Expand input[v-model] with dynamic type bindings into v-if-else chains\r\n * Turn this:\r\n *   <input v-model=\"data[type]\" :type=\"type\">\r\n * into this:\r\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\r\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\r\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\r\n */\r\nfunction preTransformNode(el, options) {\r\n    if (el.tag === 'input') {\r\n        var map = el.attrsMap;\r\n        if (!map['v-model']) {\r\n            return;\r\n        }\r\n        var typeBinding = void 0;\r\n        if (map[':type'] || map['v-bind:type']) {\r\n            typeBinding = getBindingAttr(el, 'type');\r\n        }\r\n        if (!map.type && !typeBinding && map['v-bind']) {\r\n            typeBinding = \"(\".concat(map['v-bind'], \").type\");\r\n        }\r\n        if (typeBinding) {\r\n            var ifCondition = getAndRemoveAttr(el, 'v-if', true);\r\n            var ifConditionExtra = ifCondition ? \"&&(\".concat(ifCondition, \")\") : \"\";\r\n            var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\r\n            var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\r\n            // 1. checkbox\r\n            var branch0 = cloneASTElement(el);\r\n            // process for on the main node\r\n            processFor(branch0);\r\n            addRawAttr(branch0, 'type', 'checkbox');\r\n            processElement(branch0, options);\r\n            branch0.processed = true; // prevent it from double-processed\r\n            branch0.if = \"(\".concat(typeBinding, \")==='checkbox'\") + ifConditionExtra;\r\n            addIfCondition(branch0, {\r\n                exp: branch0.if,\r\n                block: branch0\r\n            });\r\n            // 2. add radio else-if condition\r\n            var branch1 = cloneASTElement(el);\r\n            getAndRemoveAttr(branch1, 'v-for', true);\r\n            addRawAttr(branch1, 'type', 'radio');\r\n            processElement(branch1, options);\r\n            addIfCondition(branch0, {\r\n                exp: \"(\".concat(typeBinding, \")==='radio'\") + ifConditionExtra,\r\n                block: branch1\r\n            });\r\n            // 3. other\r\n            var branch2 = cloneASTElement(el);\r\n            getAndRemoveAttr(branch2, 'v-for', true);\r\n            addRawAttr(branch2, ':type', typeBinding);\r\n            processElement(branch2, options);\r\n            addIfCondition(branch0, {\r\n                exp: ifCondition,\r\n                block: branch2\r\n            });\r\n            if (hasElse) {\r\n                branch0.else = true;\r\n            }\r\n            else if (elseIfCondition) {\r\n                branch0.elseif = elseIfCondition;\r\n            }\r\n            return branch0;\r\n        }\r\n    }\r\n}\r\nfunction cloneASTElement(el) {\r\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\r\n}\r\nvar model = {\r\n    preTransformNode: preTransformNode\r\n};\r\n\r\nvar modules = [klass, style, model];\r\n\r\nfunction text(el, dir) {\r\n    if (dir.value) {\r\n        addProp(el, 'textContent', \"_s(\".concat(dir.value, \")\"), dir);\r\n    }\r\n}\r\n\r\nfunction html(el, dir) {\r\n    if (dir.value) {\r\n        addProp(el, 'innerHTML', \"_s(\".concat(dir.value, \")\"), dir);\r\n    }\r\n}\r\n\r\nvar directives = {\r\n    model: model$1,\r\n    text: text,\r\n    html: html\r\n};\r\n\r\nvar baseOptions = {\r\n    expectHTML: true,\r\n    modules: modules,\r\n    directives: directives,\r\n    isPreTag: isPreTag,\r\n    isUnaryTag: isUnaryTag,\r\n    mustUseProp: mustUseProp,\r\n    canBeLeftOpenTag: canBeLeftOpenTag,\r\n    isReservedTag: isReservedTag,\r\n    getTagNamespace: getTagNamespace,\r\n    staticKeys: genStaticKeys$1(modules)\r\n};\r\n\r\nvar isStaticKey;\r\nvar isPlatformReservedTag;\r\nvar genStaticKeysCached = cached(genStaticKeys);\r\n/**\r\n * Goal of the optimizer: walk the generated template AST tree\r\n * and detect sub-trees that are purely static, i.e. parts of\r\n * the DOM that never needs to change.\r\n *\r\n * Once we detect these sub-trees, we can:\r\n *\r\n * 1. Hoist them into constants, so that we no longer need to\r\n *    create fresh nodes for them on each re-render;\r\n * 2. Completely skip them in the patching process.\r\n */\r\nfunction optimize(root, options) {\r\n    if (!root)\r\n        return;\r\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\r\n    isPlatformReservedTag = options.isReservedTag || no;\r\n    // first pass: mark all non-static nodes.\r\n    markStatic(root);\r\n    // second pass: mark static roots.\r\n    markStaticRoots(root, false);\r\n}\r\nfunction genStaticKeys(keys) {\r\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\r\n        (keys ? ',' + keys : ''));\r\n}\r\nfunction markStatic(node) {\r\n    node.static = isStatic(node);\r\n    if (node.type === 1) {\r\n        // do not make component slot content static. this avoids\r\n        // 1. components not able to mutate slot nodes\r\n        // 2. static slot content fails for hot-reloading\r\n        if (!isPlatformReservedTag(node.tag) &&\r\n            node.tag !== 'slot' &&\r\n            node.attrsMap['inline-template'] == null) {\r\n            return;\r\n        }\r\n        for (var i = 0, l = node.children.length; i < l; i++) {\r\n            var child = node.children[i];\r\n            markStatic(child);\r\n            if (!child.static) {\r\n                node.static = false;\r\n            }\r\n        }\r\n        if (node.ifConditions) {\r\n            for (var i = 1, l = node.ifConditions.length; i < l; i++) {\r\n                var block = node.ifConditions[i].block;\r\n                markStatic(block);\r\n                if (!block.static) {\r\n                    node.static = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction markStaticRoots(node, isInFor) {\r\n    if (node.type === 1) {\r\n        if (node.static || node.once) {\r\n            node.staticInFor = isInFor;\r\n        }\r\n        // For a node to qualify as a static root, it should have children that\r\n        // are not just static text. Otherwise the cost of hoisting out will\r\n        // outweigh the benefits and it's better off to just always render it fresh.\r\n        if (node.static &&\r\n            node.children.length &&\r\n            !(node.children.length === 1 && node.children[0].type === 3)) {\r\n            node.staticRoot = true;\r\n            return;\r\n        }\r\n        else {\r\n            node.staticRoot = false;\r\n        }\r\n        if (node.children) {\r\n            for (var i = 0, l = node.children.length; i < l; i++) {\r\n                markStaticRoots(node.children[i], isInFor || !!node.for);\r\n            }\r\n        }\r\n        if (node.ifConditions) {\r\n            for (var i = 1, l = node.ifConditions.length; i < l; i++) {\r\n                markStaticRoots(node.ifConditions[i].block, isInFor);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction isStatic(node) {\r\n    if (node.type === 2) {\r\n        // expression\r\n        return false;\r\n    }\r\n    if (node.type === 3) {\r\n        // text\r\n        return true;\r\n    }\r\n    return !!(node.pre ||\r\n        (!node.hasBindings && // no dynamic bindings\r\n            !node.if &&\r\n            !node.for && // not v-if or v-for or v-else\r\n            !isBuiltInTag(node.tag) && // not a built-in\r\n            isPlatformReservedTag(node.tag) && // not a component\r\n            !isDirectChildOfTemplateFor(node) &&\r\n            Object.keys(node).every(isStaticKey)));\r\n}\r\nfunction isDirectChildOfTemplateFor(node) {\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        if (node.tag !== 'template') {\r\n            return false;\r\n        }\r\n        if (node.for) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\r\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\r\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\r\n// KeyboardEvent.keyCode aliases\r\nvar keyCodes = {\r\n    esc: 27,\r\n    tab: 9,\r\n    enter: 13,\r\n    space: 32,\r\n    up: 38,\r\n    left: 37,\r\n    right: 39,\r\n    down: 40,\r\n    delete: [8, 46]\r\n};\r\n// KeyboardEvent.key aliases\r\nvar keyNames = {\r\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\r\n    esc: ['Esc', 'Escape'],\r\n    tab: 'Tab',\r\n    enter: 'Enter',\r\n    // #9112: IE11 uses `Spacebar` for Space key name.\r\n    space: [' ', 'Spacebar'],\r\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\r\n    up: ['Up', 'ArrowUp'],\r\n    left: ['Left', 'ArrowLeft'],\r\n    right: ['Right', 'ArrowRight'],\r\n    down: ['Down', 'ArrowDown'],\r\n    // #9112: IE11 uses `Del` for Delete key name.\r\n    delete: ['Backspace', 'Delete', 'Del']\r\n};\r\n// #4868: modifiers that prevent the execution of the listener\r\n// need to explicitly return null so that we can determine whether to remove\r\n// the listener for .once\r\nvar genGuard = function (condition) { return \"if(\".concat(condition, \")return null;\"); };\r\nvar modifierCode = {\r\n    stop: '$event.stopPropagation();',\r\n    prevent: '$event.preventDefault();',\r\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\r\n    ctrl: genGuard(\"!$event.ctrlKey\"),\r\n    shift: genGuard(\"!$event.shiftKey\"),\r\n    alt: genGuard(\"!$event.altKey\"),\r\n    meta: genGuard(\"!$event.metaKey\"),\r\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\r\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\r\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\r\n};\r\nfunction genHandlers(events, isNative) {\r\n    var prefix = isNative ? 'nativeOn:' : 'on:';\r\n    var staticHandlers = \"\";\r\n    var dynamicHandlers = \"\";\r\n    for (var name_1 in events) {\r\n        var handlerCode = genHandler(events[name_1]);\r\n        //@ts-expect-error\r\n        if (events[name_1] && events[name_1].dynamic) {\r\n            dynamicHandlers += \"\".concat(name_1, \",\").concat(handlerCode, \",\");\r\n        }\r\n        else {\r\n            staticHandlers += \"\\\"\".concat(name_1, \"\\\":\").concat(handlerCode, \",\");\r\n        }\r\n    }\r\n    staticHandlers = \"{\".concat(staticHandlers.slice(0, -1), \"}\");\r\n    if (dynamicHandlers) {\r\n        return prefix + \"_d(\".concat(staticHandlers, \",[\").concat(dynamicHandlers.slice(0, -1), \"])\");\r\n    }\r\n    else {\r\n        return prefix + staticHandlers;\r\n    }\r\n}\r\nfunction genHandler(handler) {\r\n    if (!handler) {\r\n        return 'function(){}';\r\n    }\r\n    if (Array.isArray(handler)) {\r\n        return \"[\".concat(handler.map(function (handler) { return genHandler(handler); }).join(','), \"]\");\r\n    }\r\n    var isMethodPath = simplePathRE.test(handler.value);\r\n    var isFunctionExpression = fnExpRE.test(handler.value);\r\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\r\n    if (!handler.modifiers) {\r\n        if (isMethodPath || isFunctionExpression) {\r\n            return handler.value;\r\n        }\r\n        return \"function($event){\".concat(isFunctionInvocation ? \"return \".concat(handler.value) : handler.value, \"}\"); // inline statement\r\n    }\r\n    else {\r\n        var code = '';\r\n        var genModifierCode = '';\r\n        var keys = [];\r\n        var _loop_1 = function (key) {\r\n            if (modifierCode[key]) {\r\n                genModifierCode += modifierCode[key];\r\n                // left/right\r\n                if (keyCodes[key]) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            else if (key === 'exact') {\r\n                var modifiers_1 = handler.modifiers;\r\n                genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta']\r\n                    .filter(function (keyModifier) { return !modifiers_1[keyModifier]; })\r\n                    .map(function (keyModifier) { return \"$event.\".concat(keyModifier, \"Key\"); })\r\n                    .join('||'));\r\n            }\r\n            else {\r\n                keys.push(key);\r\n            }\r\n        };\r\n        for (var key in handler.modifiers) {\r\n            _loop_1(key);\r\n        }\r\n        if (keys.length) {\r\n            code += genKeyFilter(keys);\r\n        }\r\n        // Make sure modifiers like prevent and stop get executed after key filtering\r\n        if (genModifierCode) {\r\n            code += genModifierCode;\r\n        }\r\n        var handlerCode = isMethodPath\r\n            ? \"return \".concat(handler.value, \".apply(null, arguments)\")\r\n            : isFunctionExpression\r\n                ? \"return (\".concat(handler.value, \").apply(null, arguments)\")\r\n                : isFunctionInvocation\r\n                    ? \"return \".concat(handler.value)\r\n                    : handler.value;\r\n        return \"function($event){\".concat(code).concat(handlerCode, \"}\");\r\n    }\r\n}\r\nfunction genKeyFilter(keys) {\r\n    return (\r\n    // make sure the key filters only apply to KeyboardEvents\r\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\r\n    // key events that do not have keyCode property...\r\n    \"if(!$event.type.indexOf('key')&&\" +\r\n        \"\".concat(keys.map(genFilterCode).join('&&'), \")return null;\"));\r\n}\r\nfunction genFilterCode(key) {\r\n    var keyVal = parseInt(key, 10);\r\n    if (keyVal) {\r\n        return \"$event.keyCode!==\".concat(keyVal);\r\n    }\r\n    var keyCode = keyCodes[key];\r\n    var keyName = keyNames[key];\r\n    return (\"_k($event.keyCode,\" +\r\n        \"\".concat(JSON.stringify(key), \",\") +\r\n        \"\".concat(JSON.stringify(keyCode), \",\") +\r\n        \"$event.key,\" +\r\n        \"\".concat(JSON.stringify(keyName)) +\r\n        \")\");\r\n}\r\n\r\nfunction on(el, dir) {\r\n    if (false) // removed by dead control flow\n{}\r\n    el.wrapListeners = function (code) { return \"_g(\".concat(code, \",\").concat(dir.value, \")\"); };\r\n}\r\n\r\nfunction bind(el, dir) {\r\n    el.wrapData = function (code) {\r\n        return \"_b(\".concat(code, \",'\").concat(el.tag, \"',\").concat(dir.value, \",\").concat(dir.modifiers && dir.modifiers.prop ? 'true' : 'false').concat(dir.modifiers && dir.modifiers.sync ? ',true' : '', \")\");\r\n    };\r\n}\r\n\r\nvar baseDirectives = {\r\n    on: on,\r\n    bind: bind,\r\n    cloak: noop\r\n};\r\n\r\nvar CodegenState = /** @class */ (function () {\r\n    function CodegenState(options) {\r\n        this.options = options;\r\n        this.warn = options.warn || baseWarn;\r\n        this.transforms = pluckModuleFunction(options.modules, 'transformCode');\r\n        this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\r\n        this.directives = extend(extend({}, baseDirectives), options.directives);\r\n        var isReservedTag = options.isReservedTag || no;\r\n        this.maybeComponent = function (el) {\r\n            return !!el.component || !isReservedTag(el.tag);\r\n        };\r\n        this.onceId = 0;\r\n        this.staticRenderFns = [];\r\n        this.pre = false;\r\n    }\r\n    return CodegenState;\r\n}());\r\nfunction generate(ast, options) {\r\n    var state = new CodegenState(options);\r\n    // fix #11483, Root level <script> tags should not be rendered.\r\n    var code = ast\r\n        ? ast.tag === 'script'\r\n            ? 'null'\r\n            : genElement(ast, state)\r\n        : '_c(\"div\")';\r\n    return {\r\n        render: \"with(this){return \".concat(code, \"}\"),\r\n        staticRenderFns: state.staticRenderFns\r\n    };\r\n}\r\nfunction genElement(el, state) {\r\n    if (el.parent) {\r\n        el.pre = el.pre || el.parent.pre;\r\n    }\r\n    if (el.staticRoot && !el.staticProcessed) {\r\n        return genStatic(el, state);\r\n    }\r\n    else if (el.once && !el.onceProcessed) {\r\n        return genOnce(el, state);\r\n    }\r\n    else if (el.for && !el.forProcessed) {\r\n        return genFor(el, state);\r\n    }\r\n    else if (el.if && !el.ifProcessed) {\r\n        return genIf(el, state);\r\n    }\r\n    else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\r\n        return genChildren(el, state) || 'void 0';\r\n    }\r\n    else if (el.tag === 'slot') {\r\n        return genSlot(el, state);\r\n    }\r\n    else {\r\n        // component or element\r\n        var code = void 0;\r\n        if (el.component) {\r\n            code = genComponent(el.component, el, state);\r\n        }\r\n        else {\r\n            var data = void 0;\r\n            var maybeComponent = state.maybeComponent(el);\r\n            if (!el.plain || (el.pre && maybeComponent)) {\r\n                data = genData(el, state);\r\n            }\r\n            var tag \r\n            // check if this is a component in <script setup>\r\n            = void 0;\r\n            // check if this is a component in <script setup>\r\n            var bindings = state.options.bindings;\r\n            if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {\r\n                tag = checkBindingType(bindings, el.tag);\r\n            }\r\n            if (!tag)\r\n                tag = \"'\".concat(el.tag, \"'\");\r\n            var children = el.inlineTemplate ? null : genChildren(el, state, true);\r\n            code = \"_c(\".concat(tag).concat(data ? \",\".concat(data) : '' // data\r\n            ).concat(children ? \",\".concat(children) : '' // children\r\n            , \")\");\r\n        }\r\n        // module transforms\r\n        for (var i = 0; i < state.transforms.length; i++) {\r\n            code = state.transforms[i](el, code);\r\n        }\r\n        return code;\r\n    }\r\n}\r\nfunction checkBindingType(bindings, key) {\r\n    var camelName = camelize(key);\r\n    var PascalName = capitalize(camelName);\r\n    var checkType = function (type) {\r\n        if (bindings[key] === type) {\r\n            return key;\r\n        }\r\n        if (bindings[camelName] === type) {\r\n            return camelName;\r\n        }\r\n        if (bindings[PascalName] === type) {\r\n            return PascalName;\r\n        }\r\n    };\r\n    var fromConst = checkType(\"setup-const\" /* BindingTypes.SETUP_CONST */) ||\r\n        checkType(\"setup-reactive-const\" /* BindingTypes.SETUP_REACTIVE_CONST */);\r\n    if (fromConst) {\r\n        return fromConst;\r\n    }\r\n    var fromMaybeRef = checkType(\"setup-let\" /* BindingTypes.SETUP_LET */) ||\r\n        checkType(\"setup-ref\" /* BindingTypes.SETUP_REF */) ||\r\n        checkType(\"setup-maybe-ref\" /* BindingTypes.SETUP_MAYBE_REF */);\r\n    if (fromMaybeRef) {\r\n        return fromMaybeRef;\r\n    }\r\n}\r\n// hoist static sub-trees out\r\nfunction genStatic(el, state) {\r\n    el.staticProcessed = true;\r\n    // Some elements (templates) need to behave differently inside of a v-pre\r\n    // node.  All pre nodes are static roots, so we can use this as a location to\r\n    // wrap a state change and reset it upon exiting the pre node.\r\n    var originalPreState = state.pre;\r\n    if (el.pre) {\r\n        state.pre = el.pre;\r\n    }\r\n    state.staticRenderFns.push(\"with(this){return \".concat(genElement(el, state), \"}\"));\r\n    state.pre = originalPreState;\r\n    return \"_m(\".concat(state.staticRenderFns.length - 1).concat(el.staticInFor ? ',true' : '', \")\");\r\n}\r\n// v-once\r\nfunction genOnce(el, state) {\r\n    el.onceProcessed = true;\r\n    if (el.if && !el.ifProcessed) {\r\n        return genIf(el, state);\r\n    }\r\n    else if (el.staticInFor) {\r\n        var key = '';\r\n        var parent_1 = el.parent;\r\n        while (parent_1) {\r\n            if (parent_1.for) {\r\n                key = parent_1.key;\r\n                break;\r\n            }\r\n            parent_1 = parent_1.parent;\r\n        }\r\n        if (!key) {\r\n             false &&\r\n                0;\r\n            return genElement(el, state);\r\n        }\r\n        return \"_o(\".concat(genElement(el, state), \",\").concat(state.onceId++, \",\").concat(key, \")\");\r\n    }\r\n    else {\r\n        return genStatic(el, state);\r\n    }\r\n}\r\nfunction genIf(el, state, altGen, altEmpty) {\r\n    el.ifProcessed = true; // avoid recursion\r\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\r\n}\r\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\r\n    if (!conditions.length) {\r\n        return altEmpty || '_e()';\r\n    }\r\n    var condition = conditions.shift();\r\n    if (condition.exp) {\r\n        return \"(\".concat(condition.exp, \")?\").concat(genTernaryExp(condition.block), \":\").concat(genIfConditions(conditions, state, altGen, altEmpty));\r\n    }\r\n    else {\r\n        return \"\".concat(genTernaryExp(condition.block));\r\n    }\r\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\r\n    function genTernaryExp(el) {\r\n        return altGen\r\n            ? altGen(el, state)\r\n            : el.once\r\n                ? genOnce(el, state)\r\n                : genElement(el, state);\r\n    }\r\n}\r\nfunction genFor(el, state, altGen, altHelper) {\r\n    var exp = el.for;\r\n    var alias = el.alias;\r\n    var iterator1 = el.iterator1 ? \",\".concat(el.iterator1) : '';\r\n    var iterator2 = el.iterator2 ? \",\".concat(el.iterator2) : '';\r\n    if (false) // removed by dead control flow\n{}\r\n    el.forProcessed = true; // avoid recursion\r\n    return (\"\".concat(altHelper || '_l', \"((\").concat(exp, \"),\") +\r\n        \"function(\".concat(alias).concat(iterator1).concat(iterator2, \"){\") +\r\n        \"return \".concat((altGen || genElement)(el, state)) +\r\n        '})');\r\n}\r\nfunction genData(el, state) {\r\n    var data = '{';\r\n    // directives first.\r\n    // directives may mutate the el's other properties before they are generated.\r\n    var dirs = genDirectives(el, state);\r\n    if (dirs)\r\n        data += dirs + ',';\r\n    // key\r\n    if (el.key) {\r\n        data += \"key:\".concat(el.key, \",\");\r\n    }\r\n    // ref\r\n    if (el.ref) {\r\n        data += \"ref:\".concat(el.ref, \",\");\r\n    }\r\n    if (el.refInFor) {\r\n        data += \"refInFor:true,\";\r\n    }\r\n    // pre\r\n    if (el.pre) {\r\n        data += \"pre:true,\";\r\n    }\r\n    // record original tag name for components using \"is\" attribute\r\n    if (el.component) {\r\n        data += \"tag:\\\"\".concat(el.tag, \"\\\",\");\r\n    }\r\n    // module data generation functions\r\n    for (var i = 0; i < state.dataGenFns.length; i++) {\r\n        data += state.dataGenFns[i](el);\r\n    }\r\n    // attributes\r\n    if (el.attrs) {\r\n        data += \"attrs:\".concat(genProps(el.attrs), \",\");\r\n    }\r\n    // DOM props\r\n    if (el.props) {\r\n        data += \"domProps:\".concat(genProps(el.props), \",\");\r\n    }\r\n    // event handlers\r\n    if (el.events) {\r\n        data += \"\".concat(genHandlers(el.events, false), \",\");\r\n    }\r\n    if (el.nativeEvents) {\r\n        data += \"\".concat(genHandlers(el.nativeEvents, true), \",\");\r\n    }\r\n    // slot target\r\n    // only for non-scoped slots\r\n    if (el.slotTarget && !el.slotScope) {\r\n        data += \"slot:\".concat(el.slotTarget, \",\");\r\n    }\r\n    // scoped slots\r\n    if (el.scopedSlots) {\r\n        data += \"\".concat(genScopedSlots(el, el.scopedSlots, state), \",\");\r\n    }\r\n    // component v-model\r\n    if (el.model) {\r\n        data += \"model:{value:\".concat(el.model.value, \",callback:\").concat(el.model.callback, \",expression:\").concat(el.model.expression, \"},\");\r\n    }\r\n    // inline-template\r\n    if (el.inlineTemplate) {\r\n        var inlineTemplate = genInlineTemplate(el, state);\r\n        if (inlineTemplate) {\r\n            data += \"\".concat(inlineTemplate, \",\");\r\n        }\r\n    }\r\n    data = data.replace(/,$/, '') + '}';\r\n    // v-bind dynamic argument wrap\r\n    // v-bind with dynamic arguments must be applied using the same v-bind object\r\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\r\n    if (el.dynamicAttrs) {\r\n        data = \"_b(\".concat(data, \",\\\"\").concat(el.tag, \"\\\",\").concat(genProps(el.dynamicAttrs), \")\");\r\n    }\r\n    // v-bind data wrap\r\n    if (el.wrapData) {\r\n        data = el.wrapData(data);\r\n    }\r\n    // v-on data wrap\r\n    if (el.wrapListeners) {\r\n        data = el.wrapListeners(data);\r\n    }\r\n    return data;\r\n}\r\nfunction genDirectives(el, state) {\r\n    var dirs = el.directives;\r\n    if (!dirs)\r\n        return;\r\n    var res = 'directives:[';\r\n    var hasRuntime = false;\r\n    var i, l, dir, needRuntime;\r\n    for (i = 0, l = dirs.length; i < l; i++) {\r\n        dir = dirs[i];\r\n        needRuntime = true;\r\n        var gen = state.directives[dir.name];\r\n        if (gen) {\r\n            // compile-time directive that manipulates AST.\r\n            // returns true if it also needs a runtime counterpart.\r\n            needRuntime = !!gen(el, dir, state.warn);\r\n        }\r\n        if (needRuntime) {\r\n            hasRuntime = true;\r\n            res += \"{name:\\\"\".concat(dir.name, \"\\\",rawName:\\\"\").concat(dir.rawName, \"\\\"\").concat(dir.value\r\n                ? \",value:(\".concat(dir.value, \"),expression:\").concat(JSON.stringify(dir.value))\r\n                : '').concat(dir.arg ? \",arg:\".concat(dir.isDynamicArg ? dir.arg : \"\\\"\".concat(dir.arg, \"\\\"\")) : '').concat(dir.modifiers ? \",modifiers:\".concat(JSON.stringify(dir.modifiers)) : '', \"},\");\r\n        }\r\n    }\r\n    if (hasRuntime) {\r\n        return res.slice(0, -1) + ']';\r\n    }\r\n}\r\nfunction genInlineTemplate(el, state) {\r\n    var ast = el.children[0];\r\n    if (false) // removed by dead control flow\n{}\r\n    if (ast && ast.type === 1) {\r\n        var inlineRenderFns = generate(ast, state.options);\r\n        return \"inlineTemplate:{render:function(){\".concat(inlineRenderFns.render, \"},staticRenderFns:[\").concat(inlineRenderFns.staticRenderFns\r\n            .map(function (code) { return \"function(){\".concat(code, \"}\"); })\r\n            .join(','), \"]}\");\r\n    }\r\n}\r\nfunction genScopedSlots(el, slots, state) {\r\n    // by default scoped slots are considered \"stable\", this allows child\r\n    // components with only scoped slots to skip forced updates from parent.\r\n    // but in some cases we have to bail-out of this optimization\r\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\r\n    var needsForceUpdate = el.for ||\r\n        Object.keys(slots).some(function (key) {\r\n            var slot = slots[key];\r\n            return (slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\r\n            );\r\n        });\r\n    // #9534: if a component with scoped slots is inside a conditional branch,\r\n    // it's possible for the same component to be reused but with different\r\n    // compiled slot content. To avoid that, we generate a unique key based on\r\n    // the generated code of all the slot contents.\r\n    var needsKey = !!el.if;\r\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\r\n    // disconnected due to the intermediate scope variable)\r\n    // #9438, #9506\r\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\r\n    // and skip force updating ones that do not actually use scope variables.\r\n    if (!needsForceUpdate) {\r\n        var parent_2 = el.parent;\r\n        while (parent_2) {\r\n            if ((parent_2.slotScope && parent_2.slotScope !== emptySlotScopeToken) ||\r\n                parent_2.for) {\r\n                needsForceUpdate = true;\r\n                break;\r\n            }\r\n            if (parent_2.if) {\r\n                needsKey = true;\r\n            }\r\n            parent_2 = parent_2.parent;\r\n        }\r\n    }\r\n    var generatedSlots = Object.keys(slots)\r\n        .map(function (key) { return genScopedSlot(slots[key], state); })\r\n        .join(',');\r\n    return \"scopedSlots:_u([\".concat(generatedSlots, \"]\").concat(needsForceUpdate ? \",null,true\" : \"\").concat(!needsForceUpdate && needsKey ? \",null,false,\".concat(hash(generatedSlots)) : \"\", \")\");\r\n}\r\nfunction hash(str) {\r\n    var hash = 5381;\r\n    var i = str.length;\r\n    while (i) {\r\n        hash = (hash * 33) ^ str.charCodeAt(--i);\r\n    }\r\n    return hash >>> 0;\r\n}\r\nfunction containsSlotChild(el) {\r\n    if (el.type === 1) {\r\n        if (el.tag === 'slot') {\r\n            return true;\r\n        }\r\n        return el.children.some(containsSlotChild);\r\n    }\r\n    return false;\r\n}\r\nfunction genScopedSlot(el, state) {\r\n    var isLegacySyntax = el.attrsMap['slot-scope'];\r\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\r\n        return genIf(el, state, genScopedSlot, \"null\");\r\n    }\r\n    if (el.for && !el.forProcessed) {\r\n        return genFor(el, state, genScopedSlot);\r\n    }\r\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\r\n    var fn = \"function(\".concat(slotScope, \"){\") +\r\n        \"return \".concat(el.tag === 'template'\r\n            ? el.if && isLegacySyntax\r\n                ? \"(\".concat(el.if, \")?\").concat(genChildren(el, state) || 'undefined', \":undefined\")\r\n                : genChildren(el, state) || 'undefined'\r\n            : genElement(el, state), \"}\");\r\n    // reverse proxy v-slot without scope on this.$slots\r\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\r\n    return \"{key:\".concat(el.slotTarget || \"\\\"default\\\"\", \",fn:\").concat(fn).concat(reverseProxy, \"}\");\r\n}\r\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\r\n    var children = el.children;\r\n    if (children.length) {\r\n        var el_1 = children[0];\r\n        // optimize single v-for\r\n        if (children.length === 1 &&\r\n            el_1.for &&\r\n            el_1.tag !== 'template' &&\r\n            el_1.tag !== 'slot') {\r\n            var normalizationType_1 = checkSkip\r\n                ? state.maybeComponent(el_1)\r\n                    ? \",1\"\r\n                    : \",0\"\r\n                : \"\";\r\n            return \"\".concat((altGenElement || genElement)(el_1, state)).concat(normalizationType_1);\r\n        }\r\n        var normalizationType = checkSkip\r\n            ? getNormalizationType(children, state.maybeComponent)\r\n            : 0;\r\n        var gen_1 = altGenNode || genNode;\r\n        return \"[\".concat(children.map(function (c) { return gen_1(c, state); }).join(','), \"]\").concat(normalizationType ? \",\".concat(normalizationType) : '');\r\n    }\r\n}\r\n// determine the normalization needed for the children array.\r\n// 0: no normalization needed\r\n// 1: simple normalization needed (possible 1-level deep nested array)\r\n// 2: full normalization needed\r\nfunction getNormalizationType(children, maybeComponent) {\r\n    var res = 0;\r\n    for (var i = 0; i < children.length; i++) {\r\n        var el = children[i];\r\n        if (el.type !== 1) {\r\n            continue;\r\n        }\r\n        if (needsNormalization(el) ||\r\n            (el.ifConditions &&\r\n                el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\r\n            res = 2;\r\n            break;\r\n        }\r\n        if (maybeComponent(el) ||\r\n            (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\r\n            res = 1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction needsNormalization(el) {\r\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\r\n}\r\nfunction genNode(node, state) {\r\n    if (node.type === 1) {\r\n        return genElement(node, state);\r\n    }\r\n    else if (node.type === 3 && node.isComment) {\r\n        return genComment(node);\r\n    }\r\n    else {\r\n        return genText(node);\r\n    }\r\n}\r\nfunction genText(text) {\r\n    return \"_v(\".concat(text.type === 2\r\n        ? text.expression // no need for () because already wrapped in _s()\r\n        : transformSpecialNewlines(JSON.stringify(text.text)), \")\");\r\n}\r\nfunction genComment(comment) {\r\n    return \"_e(\".concat(JSON.stringify(comment.text), \")\");\r\n}\r\nfunction genSlot(el, state) {\r\n    var slotName = el.slotName || '\"default\"';\r\n    var children = genChildren(el, state);\r\n    var res = \"_t(\".concat(slotName).concat(children ? \",function(){return \".concat(children, \"}\") : '');\r\n    var attrs = el.attrs || el.dynamicAttrs\r\n        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\r\n            // slot props are camelized\r\n            name: camelize(attr.name),\r\n            value: attr.value,\r\n            dynamic: attr.dynamic\r\n        }); }))\r\n        : null;\r\n    var bind = el.attrsMap['v-bind'];\r\n    if ((attrs || bind) && !children) {\r\n        res += \",null\";\r\n    }\r\n    if (attrs) {\r\n        res += \",\".concat(attrs);\r\n    }\r\n    if (bind) {\r\n        res += \"\".concat(attrs ? '' : ',null', \",\").concat(bind);\r\n    }\r\n    return res + ')';\r\n}\r\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\r\nfunction genComponent(componentName, el, state) {\r\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\r\n    return \"_c(\".concat(componentName, \",\").concat(genData(el, state)).concat(children ? \",\".concat(children) : '', \")\");\r\n}\r\nfunction genProps(props) {\r\n    var staticProps = \"\";\r\n    var dynamicProps = \"\";\r\n    for (var i = 0; i < props.length; i++) {\r\n        var prop = props[i];\r\n        var value = transformSpecialNewlines(prop.value);\r\n        if (prop.dynamic) {\r\n            dynamicProps += \"\".concat(prop.name, \",\").concat(value, \",\");\r\n        }\r\n        else {\r\n            staticProps += \"\\\"\".concat(prop.name, \"\\\":\").concat(value, \",\");\r\n        }\r\n    }\r\n    staticProps = \"{\".concat(staticProps.slice(0, -1), \"}\");\r\n    if (dynamicProps) {\r\n        return \"_d(\".concat(staticProps, \",[\").concat(dynamicProps.slice(0, -1), \"])\");\r\n    }\r\n    else {\r\n        return staticProps;\r\n    }\r\n}\r\n// #3895, #4268\r\nfunction transformSpecialNewlines(text) {\r\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\r\n}\r\n\r\n// these keywords should not appear inside expressions, but operators like\r\n// typeof, instanceof and in are allowed\r\nvar prohibitedKeywordRE = new RegExp('\\\\b' +\r\n    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\r\n        'super,throw,while,yield,delete,export,import,return,switch,default,' +\r\n        'extends,finally,continue,debugger,function,arguments')\r\n        .split(',')\r\n        .join('\\\\b|\\\\b') +\r\n    '\\\\b');\r\n// these unary operators should not be used as property/method names\r\nvar unaryOperatorsRE = new RegExp('\\\\b' +\r\n    'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') +\r\n    '\\\\s*\\\\([^\\\\)]*\\\\)');\r\n// strip strings in expressions\r\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\r\n// detect problematic expressions in a template\r\nfunction detectErrors(ast, warn) {\r\n    if (ast) {\r\n        checkNode(ast, warn);\r\n    }\r\n}\r\nfunction checkNode(node, warn) {\r\n    if (node.type === 1) {\r\n        for (var name_1 in node.attrsMap) {\r\n            if (dirRE.test(name_1)) {\r\n                var value = node.attrsMap[name_1];\r\n                if (value) {\r\n                    var range = node.rawAttrsMap[name_1];\r\n                    if (name_1 === 'v-for') {\r\n                        checkFor(node, \"v-for=\\\"\".concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                    else if (name_1 === 'v-slot' || name_1[0] === '#') {\r\n                        checkFunctionParameterExpression(value, \"\".concat(name_1, \"=\\\"\").concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                    else if (onRE.test(name_1)) {\r\n                        checkEvent(value, \"\".concat(name_1, \"=\\\"\").concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                    else {\r\n                        checkExpression(value, \"\".concat(name_1, \"=\\\"\").concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (node.children) {\r\n            for (var i = 0; i < node.children.length; i++) {\r\n                checkNode(node.children[i], warn);\r\n            }\r\n        }\r\n    }\r\n    else if (node.type === 2) {\r\n        checkExpression(node.expression, node.text, warn, node);\r\n    }\r\n}\r\nfunction checkEvent(exp, text, warn, range) {\r\n    var stripped = exp.replace(stripStringRE, '');\r\n    var keywordMatch = stripped.match(unaryOperatorsRE);\r\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\r\n        warn(\"avoid using JavaScript unary operator as property name: \" +\r\n            \"\\\"\".concat(keywordMatch[0], \"\\\" in expression \").concat(text.trim()), range);\r\n    }\r\n    checkExpression(exp, text, warn, range);\r\n}\r\nfunction checkFor(node, text, warn, range) {\r\n    checkExpression(node.for || '', text, warn, range);\r\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\r\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\r\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\r\n}\r\nfunction checkIdentifier(ident, type, text, warn, range) {\r\n    if (typeof ident === 'string') {\r\n        try {\r\n            new Function(\"var \".concat(ident, \"=_\"));\r\n        }\r\n        catch (e) {\r\n            warn(\"invalid \".concat(type, \" \\\"\").concat(ident, \"\\\" in expression: \").concat(text.trim()), range);\r\n        }\r\n    }\r\n}\r\nfunction checkExpression(exp, text, warn, range) {\r\n    try {\r\n        new Function(\"return \".concat(exp));\r\n    }\r\n    catch (e) {\r\n        var keywordMatch = exp\r\n            .replace(stripStringRE, '')\r\n            .match(prohibitedKeywordRE);\r\n        if (keywordMatch) {\r\n            warn(\"avoid using JavaScript keyword as property name: \" +\r\n                \"\\\"\".concat(keywordMatch[0], \"\\\"\\n  Raw expression: \").concat(text.trim()), range);\r\n        }\r\n        else {\r\n            warn(\"invalid expression: \".concat(e.message, \" in\\n\\n\") +\r\n                \"    \".concat(exp, \"\\n\\n\") +\r\n                \"  Raw expression: \".concat(text.trim(), \"\\n\"), range);\r\n        }\r\n    }\r\n}\r\nfunction checkFunctionParameterExpression(exp, text, warn, range) {\r\n    try {\r\n        new Function(exp, '');\r\n    }\r\n    catch (e) {\r\n        warn(\"invalid function parameter expression: \".concat(e.message, \" in\\n\\n\") +\r\n            \"    \".concat(exp, \"\\n\\n\") +\r\n            \"  Raw expression: \".concat(text.trim(), \"\\n\"), range);\r\n    }\r\n}\r\n\r\nvar range = 2;\r\nfunction generateCodeFrame(source, start, end) {\r\n    if (start === void 0) { start = 0; }\r\n    if (end === void 0) { end = source.length; }\r\n    var lines = source.split(/\\r?\\n/);\r\n    var count = 0;\r\n    var res = [];\r\n    for (var i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (var j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                res.push(\"\".concat(j + 1).concat(repeat(\" \", 3 - String(j + 1).length), \"|  \").concat(lines[j]));\r\n                var lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    var pad = start - (count - lineLength) + 1;\r\n                    var length_1 = end > count ? lineLength - pad : end - start;\r\n                    res.push(\"   |  \" + repeat(\" \", pad) + repeat(\"^\", length_1));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        var length_2 = Math.min(end - count, lineLength);\r\n                        res.push(\"   |  \" + repeat(\"^\", length_2));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\r\nfunction repeat(str, n) {\r\n    var result = '';\r\n    if (n > 0) {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            // eslint-disable-line\r\n            if (n & 1)\r\n                result += str;\r\n            n >>>= 1;\r\n            if (n <= 0)\r\n                break;\r\n            str += str;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction createFunction(code, errors) {\r\n    try {\r\n        return new Function(code);\r\n    }\r\n    catch (err) {\r\n        errors.push({ err: err, code: code });\r\n        return noop;\r\n    }\r\n}\r\nfunction createCompileToFunctionFn(compile) {\r\n    var cache = Object.create(null);\r\n    return function compileToFunctions(template, options, vm) {\r\n        options = extend({}, options);\r\n        var warn = options.warn || warn$2;\r\n        delete options.warn;\r\n        /* istanbul ignore if */\r\n        if (false) // removed by dead control flow\n{}\r\n        // check cache\r\n        var key = options.delimiters\r\n            ? String(options.delimiters) + template\r\n            : template;\r\n        if (cache[key]) {\r\n            return cache[key];\r\n        }\r\n        // compile\r\n        var compiled = compile(template, options);\r\n        // check compilation errors/tips\r\n        if (false) // removed by dead control flow\n{}\r\n        // turn code into functions\r\n        var res = {};\r\n        var fnGenErrors = [];\r\n        res.render = createFunction(compiled.render, fnGenErrors);\r\n        res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\r\n            return createFunction(code, fnGenErrors);\r\n        });\r\n        // check function generation errors.\r\n        // this should only happen if there is a bug in the compiler itself.\r\n        // mostly for codegen development use\r\n        /* istanbul ignore if */\r\n        if (false) // removed by dead control flow\n{}\r\n        return (cache[key] = res);\r\n    };\r\n}\r\n\r\nfunction createCompilerCreator(baseCompile) {\r\n    return function createCompiler(baseOptions) {\r\n        function compile(template, options) {\r\n            var finalOptions = Object.create(baseOptions);\r\n            var errors = [];\r\n            var tips = [];\r\n            var warn = function (msg, range, tip) {\r\n                (tip ? tips : errors).push(msg);\r\n            };\r\n            if (options) {\r\n                if (false) // removed by dead control flow\n{ var leadingSpaceLength_1; }\r\n                // merge custom modules\r\n                if (options.modules) {\r\n                    finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\r\n                }\r\n                // merge custom directives\r\n                if (options.directives) {\r\n                    finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\r\n                }\r\n                // copy other options\r\n                for (var key in options) {\r\n                    if (key !== 'modules' && key !== 'directives') {\r\n                        finalOptions[key] = options[key];\r\n                    }\r\n                }\r\n            }\r\n            finalOptions.warn = warn;\r\n            var compiled = baseCompile(template.trim(), finalOptions);\r\n            if (false) // removed by dead control flow\n{}\r\n            compiled.errors = errors;\r\n            compiled.tips = tips;\r\n            return compiled;\r\n        }\r\n        return {\r\n            compile: compile,\r\n            compileToFunctions: createCompileToFunctionFn(compile)\r\n        };\r\n    };\r\n}\r\n\r\n// `createCompilerCreator` allows creating compilers that use alternative\r\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\r\n// Here we just export a default compiler using the default parts.\r\nvar createCompiler = createCompilerCreator(function baseCompile(template, options) {\r\n    var ast = parse(template.trim(), options);\r\n    if (options.optimize !== false) {\r\n        optimize(ast, options);\r\n    }\r\n    var code = generate(ast, options);\r\n    return {\r\n        ast: ast,\r\n        render: code.render,\r\n        staticRenderFns: code.staticRenderFns\r\n    };\r\n});\r\n\r\nvar _a = createCompiler(baseOptions), compileToFunctions = _a.compileToFunctions;\r\n\r\n// check whether current browser encodes a char inside attribute values\r\nvar div;\r\nfunction getShouldDecode(href) {\r\n    div = div || document.createElement('div');\r\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\r\n    return div.innerHTML.indexOf('&#10;') > 0;\r\n}\r\n// #3663: IE encodes newlines inside attribute values while other browsers don't\r\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\r\n// #6828: chrome encodes content in a[href]\r\nvar shouldDecodeNewlinesForHref = inBrowser\r\n    ? getShouldDecode(true)\r\n    : false;\r\n\r\nvar idToTemplate = cached(function (id) {\r\n    var el = query(id);\r\n    return el && el.innerHTML;\r\n});\r\nvar mount = Vue.prototype.$mount;\r\nVue.prototype.$mount = function (el, hydrating) {\r\n    el = el && query(el);\r\n    /* istanbul ignore if */\r\n    if (el === document.body || el === document.documentElement) {\r\n         false &&\r\n            0;\r\n        return this;\r\n    }\r\n    var options = this.$options;\r\n    // resolve template/el and convert to render function\r\n    if (!options.render) {\r\n        var template = options.template;\r\n        if (template) {\r\n            if (typeof template === 'string') {\r\n                if (template.charAt(0) === '#') {\r\n                    template = idToTemplate(template);\r\n                    /* istanbul ignore if */\r\n                    if (false) // removed by dead control flow\n{}\r\n                }\r\n            }\r\n            else if (template.nodeType) {\r\n                template = template.innerHTML;\r\n            }\r\n            else {\r\n                if (false) // removed by dead control flow\n{}\r\n                return this;\r\n            }\r\n        }\r\n        else if (el) {\r\n            // @ts-expect-error\r\n            template = getOuterHTML(el);\r\n        }\r\n        if (template) {\r\n            /* istanbul ignore if */\r\n            if (false) // removed by dead control flow\n{}\r\n            var _a = compileToFunctions(template, {\r\n                outputSourceRange: \"production\" !== 'production',\r\n                shouldDecodeNewlines: shouldDecodeNewlines,\r\n                shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\r\n                delimiters: options.delimiters,\r\n                comments: options.comments\r\n            }, this), render = _a.render, staticRenderFns = _a.staticRenderFns;\r\n            options.render = render;\r\n            options.staticRenderFns = staticRenderFns;\r\n            /* istanbul ignore if */\r\n            if (false) // removed by dead control flow\n{}\r\n        }\r\n    }\r\n    return mount.call(this, el, hydrating);\r\n};\r\n/**\r\n * Get outerHTML of elements, taking care\r\n * of SVG elements in IE as well.\r\n */\r\nfunction getOuterHTML(el) {\r\n    if (el.outerHTML) {\r\n        return el.outerHTML;\r\n    }\r\n    else {\r\n        var container = document.createElement('div');\r\n        container.appendChild(el.cloneNode(true));\r\n        return container.innerHTML;\r\n    }\r\n}\r\nVue.compile = compileToFunctions;\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBMEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQW9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc2NpbGxvc2NvcGUtc2ltdWxhdG9yL0Q6XFxVc2Vyc1xcYXN1c1xcRGVza3RvcFxcd2Vi6aG555uuXFxkZW1vMVxcbm9kZV9tb2R1bGVzXFx2dWVcXGRpc3RcXHZ1ZS5lc20uanM/MDYxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogVnVlLmpzIHYyLjcuMTZcclxuICogKGMpIDIwMTQtMjAyMyBFdmFuIFlvdVxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG4vLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cclxuZnVuY3Rpb24gaXNVbmRlZih2KSB7XHJcbiAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNEZWYodikge1xyXG4gICAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGlzVHJ1ZSh2KSB7XHJcbiAgICByZXR1cm4gdiA9PT0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc0ZhbHNlKHYpIHtcclxuICAgIHJldHVybiB2ID09PSBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuLyoqXHJcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxyXG4gKiBvYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXHJcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcclxufVxyXG4vKipcclxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxyXG4gKi9cclxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbmZ1bmN0aW9uIHRvUmF3VHlwZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XHJcbn1cclxuLyoqXHJcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcclxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWdFeHAodikge1xyXG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJztcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCh2YWwpIHtcclxuICAgIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XHJcbiAgICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XHJcbiAgICByZXR1cm4gKGlzRGVmKHZhbCkgJiZcclxuICAgICAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nKTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1N0cmluZyh2YWwpIHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbFxyXG4gICAgICAgID8gJydcclxuICAgICAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxyXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXHJcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XHJcbn1cclxuZnVuY3Rpb24gcmVwbGFjZXIoX2tleSwgdmFsKSB7XHJcbiAgICAvLyBhdm9pZCBjaXJjdWxhciBkZXBzIGZyb20gdjNcclxuICAgIGlmICh2YWwgJiYgdmFsLl9fdl9pc1JlZikge1xyXG4gICAgICAgIHJldHVybiB2YWwudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cclxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b051bWJlcih2YWwpIHtcclxuICAgIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufVxyXG4vKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcclxuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH0gOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXHJcbiAqL1xyXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cclxuICovXHJcbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcclxuLyoqXHJcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmUkMihhcnIsIGl0ZW0pIHtcclxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgaWYgKGxlbikge1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdGhlIG9ubHkgLyBsYXN0IGl0ZW1cclxuICAgICAgICBpZiAoaXRlbSA9PT0gYXJyW2xlbiAtIDFdKSB7XHJcbiAgICAgICAgICAgIGFyci5sZW5ndGggPSBsZW4gLSAxO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXHJcbiAqL1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5mdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FjaGVkKGZuKSB7XHJcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZEZuKHN0cikge1xyXG4gICAgICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXHJcbiAqL1xyXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJyk7IH0pO1xyXG59KTtcclxuLyoqXHJcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXHJcbiAqL1xyXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG59KTtcclxuLyoqXHJcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXHJcbiAqL1xyXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xyXG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XHJcbn0pO1xyXG4vKipcclxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxyXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcclxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXHJcbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cclxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQoZm4sIGN0eCkge1xyXG4gICAgZnVuY3Rpb24gYm91bmRGbihhKSB7XHJcbiAgICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBsXHJcbiAgICAgICAgICAgID8gbCA+IDFcclxuICAgICAgICAgICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXHJcbiAgICAgICAgICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxyXG4gICAgICAgICAgICA6IGZuLmNhbGwoY3R4KTtcclxuICAgIH1cclxuICAgIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcclxuICAgIHJldHVybiBib3VuZEZuO1xyXG59XHJcbmZ1bmN0aW9uIG5hdGl2ZUJpbmQoZm4sIGN0eCkge1xyXG4gICAgcmV0dXJuIGZuLmJpbmQoY3R4KTtcclxufVxyXG4vLyBAdHMtZXhwZWN0LWVycm9yIGJpbmQgY2Fubm90IGJlIGB1bmRlZmluZWRgXHJcbnZhciBiaW5kJDEgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA/IG5hdGl2ZUJpbmQgOiBwb2x5ZmlsbEJpbmQ7XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcclxuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcclxuICAgIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcclxuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG4vKipcclxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0ZW5kKHRvLCBfZnJvbSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XHJcbiAgICAgICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG87XHJcbn1cclxuLyoqXHJcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b09iamVjdChhcnIpIHtcclxuICAgIHZhciByZXMgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFycltpXSkge1xyXG4gICAgICAgICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuLyoqXHJcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxyXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcclxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxyXG4gKi9cclxuZnVuY3Rpb24gbm9vcChhLCBiLCBjKSB7IH1cclxuLyoqXHJcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XHJcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cclxuICovXHJcbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xyXG4vKipcclxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEobW9kdWxlcykge1xyXG4gICAgcmV0dXJuIG1vZHVsZXNcclxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7IHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pOyB9LCBbXSlcclxuICAgICAgICAuam9pbignLCcpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcclxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xyXG4gKi9cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcclxuICAgIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcclxuICAgIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcclxuICAgICAgICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcclxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cclxuICovXHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpXHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gb25jZShmbikge1xyXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzI3BvbHlmaWxsXHJcbmZ1bmN0aW9uIGhhc0NoYW5nZWQoeCwgeSkge1xyXG4gICAgaWYgKHggPT09IHkpIHtcclxuICAgICAgICByZXR1cm4geCA9PT0gMCAmJiAxIC8geCAhPT0gMSAvIHk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geCA9PT0geCB8fCB5ID09PSB5O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xyXG52YXIgQVNTRVRfVFlQRVMgPSBbJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZmlsdGVyJ107XHJcbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXHJcbiAgICAnYmVmb3JlQ3JlYXRlJyxcclxuICAgICdjcmVhdGVkJyxcclxuICAgICdiZWZvcmVNb3VudCcsXHJcbiAgICAnbW91bnRlZCcsXHJcbiAgICAnYmVmb3JlVXBkYXRlJyxcclxuICAgICd1cGRhdGVkJyxcclxuICAgICdiZWZvcmVEZXN0cm95JyxcclxuICAgICdkZXN0cm95ZWQnLFxyXG4gICAgJ2FjdGl2YXRlZCcsXHJcbiAgICAnZGVhY3RpdmF0ZWQnLFxyXG4gICAgJ2Vycm9yQ2FwdHVyZWQnLFxyXG4gICAgJ3NlcnZlclByZWZldGNoJyxcclxuICAgICdyZW5kZXJUcmFja2VkJyxcclxuICAgICdyZW5kZXJUcmlnZ2VyZWQnXHJcbl07XHJcblxyXG52YXIgY29uZmlnID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcclxuICAgICAqL1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXHJcbiAgICAgKi9cclxuICAgIHNpbGVudDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XHJcbiAgICAgKi9cclxuICAgIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXHJcbiAgICAgKi9cclxuICAgIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXHJcbiAgICAgKi9cclxuICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcclxuICAgICAqL1xyXG4gICAgZXJyb3JIYW5kbGVyOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcclxuICAgICAqL1xyXG4gICAgd2FybkhhbmRsZXI6IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBpZ25vcmVkRWxlbWVudHM6IFtdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxyXG4gICAgICovXHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcclxuICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgaXNSZXNlcnZlZFRhZzogbm8sXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XHJcbiAgICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBpc1Jlc2VydmVkQXR0cjogbm8sXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cclxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cclxuICAgICAqL1xyXG4gICAgaXNVbmtub3duRWxlbWVudDogbm8sXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxyXG4gICAgICovXHJcbiAgICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXHJcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXHJcbiAgICAgKi9cclxuICAgIG11c3RVc2VQcm9wOiBubyxcclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXHJcbiAgICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYzogdHJ1ZSxcclxuICAgIC8qKlxyXG4gICAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcclxuICAgICAqL1xyXG4gICAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1NcclxufTtcclxuXHJcbi8qKlxyXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXHJcbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXHJcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcclxuICovXHJcbnZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xyXG4vKipcclxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xyXG4gICAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XHJcbiAgICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVmO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICB2YWx1ZTogdmFsLFxyXG4gICAgICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cclxuICovXHJcbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKFwiW15cIi5jb25jYXQodW5pY29kZVJlZ0V4cC5zb3VyY2UsIFwiLiRfXFxcXGRdXCIpKTtcclxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcclxuICAgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIW9iailcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xyXG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcclxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xyXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XHJcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xyXG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcclxudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xyXG5VQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xyXG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xyXG5VQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcclxuVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XHJcbnZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcclxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxyXG4vLyBAdHMtZXhwZWN0LWVycm9yIGZpcmVib3ggc3VwcG9ydFxyXG52YXIgbmF0aXZlV2F0Y2ggPSB7fS53YXRjaDtcclxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG5pZiAoaW5Ccm93c2VyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge307XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbn1cclxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXHJcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXHJcbnZhciBfaXNTZXJ2ZXI7XHJcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxyXG4gICAgICAgICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXHJcbiAgICAgICAgICAgIF9pc1NlcnZlciA9XHJcbiAgICAgICAgICAgICAgICBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2lzU2VydmVyO1xyXG59O1xyXG4vLyBkZXRlY3QgZGV2dG9vbHNcclxudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBpc05hdGl2ZShDdG9yKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSk7XHJcbn1cclxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICBpc05hdGl2ZShTeW1ib2wpICYmXHJcbiAgICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XHJcbnZhciBfU2V0OyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuLyogaXN0YW5idWwgaWdub3JlIGlmICovIGlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XHJcbiAgICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cclxuICAgIF9TZXQgPSBTZXQ7XHJcbn1cclxuZWxzZSB7XHJcbiAgICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXHJcbiAgICBfU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2V0O1xyXG4gICAgfSgpKTtcclxufVxyXG5cclxudmFyIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbi8qKlxyXG4gKiBUaGlzIGlzIGV4cG9zZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB2MyAoZS5nLiBzb21lIGZ1bmN0aW9ucyBpbiBWdWVVc2VcclxuICogcmVsaWVzIG9uIGl0KS4gRG8gbm90IHVzZSB0aGlzIGludGVybmFsbHksIGp1c3QgdXNlIGBjdXJyZW50SW5zdGFuY2VgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgdHlwZSBkZWNsYXJhdGlvbiBiZWNhdXNlIGl0IHJlbGllc1xyXG4gKiBvbiBwcmV2aW91c2x5IG1hbnVhbGx5IGF1dGhvcmVkIHR5cGVzIGZyb20gVnVlIDJcclxuICovXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRJbnN0YW5jZSgpIHtcclxuICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UgJiYgeyBwcm94eTogY3VycmVudEluc3RhbmNlIH07XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3VycmVudEluc3RhbmNlKHZtKSB7XHJcbiAgICBpZiAodm0gPT09IHZvaWQgMCkgeyB2bSA9IG51bGw7IH1cclxuICAgIGlmICghdm0pXHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5fc2NvcGUub2ZmKCk7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSB2bTtcclxuICAgIHZtICYmIHZtLl9zY29wZS5vbigpO1xyXG59XHJcblxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgVk5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWTm9kZSh0YWcsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCBlbG0sIGNvbnRleHQsIGNvbXBvbmVudE9wdGlvbnMsIGFzeW5jRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5lbG0gPSBlbG07XHJcbiAgICAgICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yYXcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWTm9kZS5wcm90b3R5cGUsIFwiY2hpbGRcIiwge1xyXG4gICAgICAgIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gVk5vZGU7XHJcbn0oKSk7XHJcbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgIGlmICh0ZXh0ID09PSB2b2lkIDApIHsgdGV4dCA9ICcnOyB9XHJcbiAgICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xyXG4gICAgbm9kZS50ZXh0ID0gdGV4dDtcclxuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcclxuICAgIHJldHVybiBub2RlO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodmFsKSB7XHJcbiAgICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKTtcclxufVxyXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxyXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXHJcbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxyXG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxyXG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlKSB7XHJcbiAgICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKHZub2RlLnRhZywgdm5vZGUuZGF0YSwgXHJcbiAgICAvLyAjNzk3NVxyXG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXHJcbiAgICAvLyBhIGNoaWxkLlxyXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSwgdm5vZGUudGV4dCwgdm5vZGUuZWxtLCB2bm9kZS5jb250ZXh0LCB2bm9kZS5jb21wb25lbnRPcHRpb25zLCB2bm9kZS5hc3luY0ZhY3RvcnkpO1xyXG4gICAgY2xvbmVkLm5zID0gdm5vZGUubnM7XHJcbiAgICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcclxuICAgIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XHJcbiAgICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xyXG4gICAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcclxuICAgIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XHJcbiAgICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xyXG4gICAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcclxuICAgIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcblxyXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cclxudmFyIGluaXRQcm94eTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhciBhbGxvd2VkR2xvYmFsc18xID0gbWFrZU1hcCgnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcclxuICAgICAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXHJcbiAgICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXHJcbiAgICAgICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcclxuICAgICk7XHJcbiAgICB2YXIgd2Fybk5vblByZXNlbnRfMSA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIHdhcm4kMihcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIpICtcclxuICAgICAgICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXHJcbiAgICAgICAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXHJcbiAgICAgICAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcclxuICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly92Mi52dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsIHRhcmdldCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHdhcm5SZXNlcnZlZFByZWZpeF8xID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgd2FybiQyKFwiUHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiKS5jb25jYXQoa2V5LCBcIlxcXCIgYmVjYXVzZSBcIikgK1xyXG4gICAgICAgICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xyXG4gICAgICAgICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcclxuICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly92Mi52dWVqcy5vcmcvdjIvYXBpLyNkYXRhJywgdGFyZ2V0KTtcclxuICAgIH07XHJcbiAgICB2YXIgaGFzUHJveHlfMSA9IHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xyXG4gICAgaWYgKGhhc1Byb3h5XzEpIHtcclxuICAgICAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXJfMSA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcclxuICAgICAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyXzEoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiLmNvbmNhdChrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaGFzSGFuZGxlcl8xID0ge1xyXG4gICAgICAgIGhhczogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHNfMShrZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBrZXkuY2hhckF0KDApID09PSAnXycgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcclxuICAgICAgICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgd2FyblJlc2VydmVkUHJlZml4XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Ob25QcmVzZW50XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldEhhbmRsZXJfMSA9IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgd2FyblJlc2VydmVkUHJlZml4XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Ob25QcmVzZW50XzEodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5KHZtKSB7XHJcbiAgICAgICAgaWYgKGhhc1Byb3h5XzEpIHtcclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWQgPyBnZXRIYW5kbGVyXzEgOiBoYXNIYW5kbGVyXzE7XHJcbiAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XHJcblxyXG52YXIgdWlkJDIgPSAwO1xyXG52YXIgcGVuZGluZ0NsZWFudXBEZXBzID0gW107XHJcbnZhciBjbGVhbnVwRGVwcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVuZGluZ0NsZWFudXBEZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGRlcCA9IHBlbmRpbmdDbGVhbnVwRGVwc1tpXTtcclxuICAgICAgICBkZXAuc3VicyA9IGRlcC5zdWJzLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gczsgfSk7XHJcbiAgICAgICAgZGVwLl9wZW5kaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBwZW5kaW5nQ2xlYW51cERlcHMubGVuZ3RoID0gMDtcclxufTtcclxuLyoqXHJcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxyXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBEZXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZXAoKSB7XHJcbiAgICAgICAgLy8gcGVuZGluZyBzdWJzIGNsZWFudXBcclxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pZCA9IHVpZCQyKys7XHJcbiAgICAgICAgdGhpcy5zdWJzID0gW107XHJcbiAgICB9XHJcbiAgICBEZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xyXG4gICAgfTtcclxuICAgIERlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xyXG4gICAgICAgIC8vICMxMjY5NiBkZXBzIHdpdGggbWFzc2l2ZSBhbW91bnQgb2Ygc3Vic2NyaWJlcnMgYXJlIGV4dHJlbWVseSBzbG93IHRvXHJcbiAgICAgICAgLy8gY2xlYW4gdXAgaW4gQ2hyb21pdW1cclxuICAgICAgICAvLyB0byB3b3JrYXJvdW5kIHRoaXMsIHdlIHVuc2V0IHRoZSBzdWIgZm9yIG5vdywgYW5kIGNsZWFyIHRoZW0gb25cclxuICAgICAgICAvLyBuZXh0IHNjaGVkdWxlciBmbHVzaC5cclxuICAgICAgICB0aGlzLnN1YnNbdGhpcy5zdWJzLmluZGV4T2Yoc3ViKV0gPSBudWxsO1xyXG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgcGVuZGluZ0NsZWFudXBEZXBzLnB1c2godGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xyXG4gICAgICAgICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5mbyAmJiBEZXAudGFyZ2V0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayhfX2Fzc2lnbih7IGVmZmVjdDogRGVwLnRhcmdldCB9LCBpbmZvKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XHJcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzOyB9KTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxyXG4gICAgICAgICAgICAvLyBvcmRlclxyXG4gICAgICAgICAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3ViID0gc3Vic1tpXTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5mbykge1xyXG4gICAgICAgICAgICAgICAgc3ViLm9uVHJpZ2dlciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHN1Yi5vblRyaWdnZXIoX19hc3NpZ24oeyBlZmZlY3Q6IHN1YnNbaV0gfSwgaW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1Yi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlcDtcclxufSgpKTtcclxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxyXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXHJcbkRlcC50YXJnZXQgPSBudWxsO1xyXG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFRhcmdldCh0YXJnZXQpIHtcclxuICAgIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcclxuICAgIERlcC50YXJnZXQgPSB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gcG9wVGFyZ2V0KCkge1xyXG4gICAgdGFyZ2V0U3RhY2sucG9wKCk7XHJcbiAgICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XHJcbn1cclxuXHJcbi8qXHJcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxyXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcclxuICovXHJcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xyXG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcclxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xyXG4gICAgJ3B1c2gnLFxyXG4gICAgJ3BvcCcsXHJcbiAgICAnc2hpZnQnLFxyXG4gICAgJ3Vuc2hpZnQnLFxyXG4gICAgJ3NwbGljZScsXHJcbiAgICAnc29ydCcsXHJcbiAgICAncmV2ZXJzZSdcclxuXTtcclxuLyoqXHJcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xyXG4gKi9cclxubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcclxuICAgIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcclxuICAgIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvcigpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xyXG4gICAgICAgIHZhciBpbnNlcnRlZDtcclxuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlICdwdXNoJzpcclxuICAgICAgICAgICAgY2FzZSAndW5zaGlmdCc6XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnc3BsaWNlJzpcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zZXJ0ZWQpXHJcbiAgICAgICAgICAgIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7XHJcbiAgICAgICAgLy8gbm90aWZ5IGNoYW5nZVxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9iLmRlcC5ub3RpZnkoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheSBtdXRhdGlvblwiIC8qIFRyaWdnZXJPcFR5cGVzLkFSUkFZX01VVEFUSU9OICovLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAga2V5OiBtZXRob2RcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvYi5kZXAubm90aWZ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KTtcclxufSk7XHJcblxyXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcclxudmFyIE5PX0lOSVRJQUxfVkFMVUUgPSB7fTtcclxuLyoqXHJcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xyXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXHJcbiAqL1xyXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XHJcbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyh2YWx1ZSkge1xyXG4gICAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xyXG59XHJcbi8vIHNzciBtb2NrIGRlcFxyXG52YXIgbW9ja0RlcCA9IHtcclxuICAgIG5vdGlmeTogbm9vcCxcclxuICAgIGRlcGVuZDogbm9vcCxcclxuICAgIGFkZFN1Yjogbm9vcCxcclxuICAgIHJlbW92ZVN1Yjogbm9vcFxyXG59O1xyXG4vKipcclxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXHJcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcclxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcclxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXHJcbiAqL1xyXG52YXIgT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZlcih2YWx1ZSwgc2hhbGxvdywgbW9jaykge1xyXG4gICAgICAgIGlmIChzaGFsbG93ID09PSB2b2lkIDApIHsgc2hhbGxvdyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKG1vY2sgPT09IHZvaWQgMCkgeyBtb2NrID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zaGFsbG93ID0gc2hhbGxvdztcclxuICAgICAgICB0aGlzLm1vY2sgPSBtb2NrO1xyXG4gICAgICAgIC8vIHRoaXMudmFsdWUgPSB2YWx1ZVxyXG4gICAgICAgIHRoaXMuZGVwID0gbW9jayA/IG1vY2tEZXAgOiBuZXcgRGVwKCk7XHJcbiAgICAgICAgdGhpcy52bUNvdW50ID0gMDtcclxuICAgICAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcclxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKCFtb2NrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fX3Byb3RvX18gPSBhcnJheU1ldGhvZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBhcnJheUtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZih2YWx1ZSwga2V5LCBhcnJheU1ldGhvZHNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc2hhbGxvdykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xyXG4gICAgICAgICAgICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cclxuICAgICAgICAgICAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZhbHVlLCBrZXksIE5PX0lOSVRJQUxfVkFMVUUsIHVuZGVmaW5lZCwgc2hhbGxvdywgbW9jayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxyXG4gICAgICovXHJcbiAgICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZSh2YWx1ZVtpXSwgZmFsc2UsIHRoaXMubW9jayk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBPYnNlcnZlcjtcclxufSgpKTtcclxuLy8gaGVscGVyc1xyXG4vKipcclxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXHJcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXHJcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZSwgc2hhbGxvdywgc3NyTW9ja1JlYWN0aXZpdHkpIHtcclxuICAgIGlmICh2YWx1ZSAmJiBoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5fX29iX187XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkT2JzZXJ2ZSAmJlxyXG4gICAgICAgIChzc3JNb2NrUmVhY3Rpdml0eSB8fCAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkgJiZcclxuICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXHJcbiAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcclxuICAgICAgICAhdmFsdWUuX192X3NraXAgLyogUmVhY3RpdmVGbGFncy5TS0lQICovICYmXHJcbiAgICAgICAgIWlzUmVmKHZhbHVlKSAmJlxyXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmVyKHZhbHVlLCBzaGFsbG93LCBzc3JNb2NrUmVhY3Rpdml0eSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5LCB2YWwsIGN1c3RvbVNldHRlciwgc2hhbGxvdywgbW9jaywgb2JzZXJ2ZUV2ZW5JZlNoYWxsb3cpIHtcclxuICAgIGlmIChvYnNlcnZlRXZlbklmU2hhbGxvdyA9PT0gdm9pZCAwKSB7IG9ic2VydmVFdmVuSWZTaGFsbG93ID0gZmFsc2U7IH1cclxuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XHJcbiAgICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcclxuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXHJcbiAgICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xyXG4gICAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcclxuICAgIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmXHJcbiAgICAgICAgKHZhbCA9PT0gTk9fSU5JVElBTF9WQUxVRSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSkge1xyXG4gICAgICAgIHZhbCA9IG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoaWxkT2IgPSBzaGFsbG93ID8gdmFsICYmIHZhbC5fX29iX18gOiBvYnNlcnZlKHZhbCwgZmFsc2UsIG1vY2spO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwLmRlcGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogb2JqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRPYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlZih2YWx1ZSkgJiYgIXNoYWxsb3cgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKHZhbHVlLCBuZXdWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21TZXR0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZ2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghc2hhbGxvdyAmJiBpc1JlZih2YWx1ZSkgJiYgIWlzUmVmKG5ld1ZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gbmV3VmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkT2IgPSBzaGFsbG93ID8gbmV3VmFsICYmIG5ld1ZhbC5fX29iX18gOiBvYnNlcnZlKG5ld1ZhbCwgZmFsc2UsIG1vY2spO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZGVwLm5vdGlmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBvYmosXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbCxcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVwLm5vdGlmeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVwO1xyXG59XHJcbmZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpKSB7XHJcbiAgICAgICAgd2FybiQyKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIuY29uY2F0KHRhcmdldCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFwiU2V0IG9wZXJhdGlvbiBvbiBrZXkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5cIikpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBvYiA9IHRhcmdldC5fX29iX187XHJcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgICAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcclxuICAgICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcclxuICAgICAgICAvLyB3aGVuIG1vY2tpbmcgZm9yIFNTUiwgYXJyYXkgbWV0aG9kcyBhcmUgbm90IGhpamFja2VkXHJcbiAgICAgICAgaWYgKG9iICYmICFvYi5zaGFsbG93ICYmIG9iLm1vY2spIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZSh2YWwsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybiQyKCdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcclxuICAgICAgICAgICAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nKTtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvYikge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwsIHVuZGVmaW5lZCwgb2Iuc2hhbGxvdywgb2IubW9jayk7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIG9iLmRlcC5ub3RpZnkoe1xyXG4gICAgICAgICAgICB0eXBlOiBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICBuZXdWYWx1ZTogdmFsLFxyXG4gICAgICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvYi5kZXAubm90aWZ5KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIGRlbCh0YXJnZXQsIGtleSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKSkge1xyXG4gICAgICAgIHdhcm4kMihcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiLmNvbmNhdCh0YXJnZXQpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xyXG4gICAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgb2IgPSB0YXJnZXQuX19vYl9fO1xyXG4gICAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICB3YXJuJDIoJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXHJcbiAgICAgICAgICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLicpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcIkRlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuXCIpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBkZWxldGUgdGFyZ2V0W2tleV07XHJcbiAgICBpZiAoIW9iKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBvYi5kZXAubm90aWZ5KHtcclxuICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8sXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICBrZXk6IGtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb2IuZGVwLm5vdGlmeSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxyXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGRlcGVuZEFycmF5KHZhbHVlKSB7XHJcbiAgICBmb3IgKHZhciBlID0gdm9pZCAwLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGUgPSB2YWx1ZVtpXTtcclxuICAgICAgICBpZiAoZSAmJiBlLl9fb2JfXykge1xyXG4gICAgICAgICAgICBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KGUpKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICBtYWtlUmVhY3RpdmUodGFyZ2V0LCBmYWxzZSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XHJcbiAqIGxldmVsIHByb3BlcnRpZXMgYXJlIHJlYWN0aXZlLiBJdCBhbHNvIGRvZXMgbm90IGF1dG8tdW53cmFwIHJlZnMgKGV2ZW4gYXQgdGhlXHJcbiAqIHJvb3QgbGV2ZWwpLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgbWFrZVJlYWN0aXZlKHRhcmdldCwgdHJ1ZSk7XHJcbiAgICBkZWYodGFyZ2V0LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBtYWtlUmVhY3RpdmUodGFyZ2V0LCBzaGFsbG93KSB7XHJcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXHJcbiAgICBpZiAoIWlzUmVhZG9ubHkodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIkF2b2lkIHVzaW5nIEFycmF5IGFzIHJvb3QgdmFsdWUgZm9yIFwiLmNvbmNhdChzaGFsbG93ID8gXCJzaGFsbG93UmVhY3RpdmUoKVwiIDogXCJyZWFjdGl2ZSgpXCIsIFwiIGFzIGl0IGNhbm5vdCBiZSB0cmFja2VkIGluIHdhdGNoKCkgb3Igd2F0Y2hFZmZlY3QoKS4gVXNlIFwiKS5jb25jYXQoc2hhbGxvdyA/IFwic2hhbGxvd1JlZigpXCIgOiBcInJlZigpXCIsIFwiIGluc3RlYWQuIFRoaXMgaXMgYSBWdWUtMi1vbmx5IGxpbWl0YXRpb24uXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdPYiA9IHRhcmdldCAmJiB0YXJnZXQuX19vYl9fO1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdPYiAmJiBleGlzdGluZ09iLnNoYWxsb3cgIT09IHNoYWxsb3cpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlRhcmdldCBpcyBhbHJlYWR5IGEgXCIuY29uY2F0KGV4aXN0aW5nT2Iuc2hhbGxvdyA/IFwiXCIgOiBcIm5vbi1cIiwgXCJzaGFsbG93IHJlYWN0aXZlIG9iamVjdCwgYW5kIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIpLmNvbmNhdChzaGFsbG93ID8gXCJcIiA6IFwibm9uLVwiLCBcInNoYWxsb3cuXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2IgPSBvYnNlcnZlKHRhcmdldCwgc2hhbGxvdywgaXNTZXJ2ZXJSZW5kZXJpbmcoKSAvKiBzc3IgbW9jayByZWFjdGl2aXR5ICovKTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhb2IpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcInZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiBcIi5jb25jYXQoU3RyaW5nKHRhcmdldCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uVHlwZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IHJlYWN0aXZlIGNvbGxlY3Rpb24gdHlwZXMgc3VjaCBhcyBNYXAgb3IgU2V0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fb2JfXyk7XHJcbn1cclxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX192X2lzU2hhbGxvdyk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fdl9pc1JlYWRvbmx5KTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcclxuICAgIHZhciByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XHJcbiAgICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcclxuICAgIC8vIG5vbi1leHRlbnNpYmxlIG9iamVjdHMgd29uJ3QgYmUgb2JzZXJ2ZWQgYW55d2F5XHJcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcclxuICAgICAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGlzQ29sbGVjdGlvblR5cGUodmFsdWUpIHtcclxuICAgIHZhciB0eXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIHJldHVybiAodHlwZSA9PT0gJ01hcCcgfHwgdHlwZSA9PT0gJ1dlYWtNYXAnIHx8IHR5cGUgPT09ICdTZXQnIHx8IHR5cGUgPT09ICdXZWFrU2V0Jyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBSZWZGbGFnID0gXCJfX3ZfaXNSZWZcIjtcclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gICAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZiQxKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XHJcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlZiA9IHt9O1xyXG4gICAgZGVmKHJlZiwgUmVmRmxhZywgdHJ1ZSk7XHJcbiAgICBkZWYocmVmLCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHNoYWxsb3cpO1xyXG4gICAgZGVmKHJlZiwgJ2RlcCcsIGRlZmluZVJlYWN0aXZlKHJlZiwgJ3ZhbHVlJywgcmF3VmFsdWUsIG51bGwsIHNoYWxsb3csIGlzU2VydmVyUmVuZGVyaW5nKCkpKTtcclxuICAgIHJldHVybiByZWY7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFyZWYuZGVwKSB7XHJcbiAgICAgICAgd2FybiQyKFwicmVjZWl2ZWQgb2JqZWN0IGlzIG5vdCBhIHRyaWdnZXJhYmxlIHJlZi5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHJlZi5kZXAgJiZcclxuICAgICAgICAgICAgcmVmLmRlcC5ub3RpZnkoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlZi5kZXAgJiYgcmVmLmRlcC5ub3RpZnkoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcclxuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgaWYgKGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdFdpdGhSZWZzO1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3h5ID0ge307XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdFdpdGhSZWZzKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgb2JqZWN0V2l0aFJlZnMsIGtleXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5V2l0aFJlZlVud3JhcCh0YXJnZXQsIHNvdXJjZSwga2V5KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYiA9IHZhbCAmJiB2YWwuX19vYl9fO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iLmRlcC5kZXBlbmQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XHJcbiAgICB2YXIgX2EgPSBmYWN0b3J5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBkZXAuZGVwZW5kKHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBkZXAubm90aWZ5KHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZXAubm90aWZ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIGdldCA9IF9hLmdldCwgc2V0ID0gX2Euc2V0O1xyXG4gICAgdmFyIHJlZiA9IHtcclxuICAgICAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICAgICAgc2V0KG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xyXG4gICAgcmV0dXJuIHJlZjtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNSZWFjdGl2ZShvYmplY3QpKSB7XHJcbiAgICAgICAgd2FybiQyKFwidG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICB2YXIgdmFsID0gb2JqZWN0W2tleV07XHJcbiAgICBpZiAoaXNSZWYodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVmID0ge1xyXG4gICAgICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcclxuICAgIHJldHVybiByZWY7XHJcbn1cclxuXHJcbnZhciByYXdUb1JlYWRvbmx5RmxhZyA9IFwiX192X3Jhd1RvUmVhZG9ubHlcIjtcclxudmFyIHJhd1RvU2hhbGxvd1JlYWRvbmx5RmxhZyA9IFwiX192X3Jhd1RvU2hhbGxvd1JlYWRvbmx5XCI7XHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgc2hhbGxvdykge1xyXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IHJlYWRvbmx5IGFycmF5cy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uVHlwZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IHJlYWRvbmx5IGNvbGxlY3Rpb24gdHlwZXMgc3VjaCBhcyBNYXAgb3IgU2V0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcInZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWRvbmx5OiBcIi5jb25jYXQodHlwZW9mIHRhcmdldCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgd2FybiQyKFwiVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCBjcmVhdGluZyByZWFkb25seSBwcm94eSBmb3Igbm9uLWV4dGVuc2libGUgb2JqZWN0LlwiKTtcclxuICAgIH1cclxuICAgIC8vIGFscmVhZHkgYSByZWFkb25seSBvYmplY3RcclxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gYWxyZWFkeSBoYXMgYSByZWFkb25seSBwcm94eVxyXG4gICAgdmFyIGV4aXN0aW5nRmxhZyA9IHNoYWxsb3cgPyByYXdUb1NoYWxsb3dSZWFkb25seUZsYWcgOiByYXdUb1JlYWRvbmx5RmxhZztcclxuICAgIHZhciBleGlzdGluZ1Byb3h5ID0gdGFyZ2V0W2V4aXN0aW5nRmxhZ107XHJcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3h5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSk7XHJcbiAgICBkZWYodGFyZ2V0LCBleGlzdGluZ0ZsYWcsIHByb3h5KTtcclxuICAgIGRlZihwcm94eSwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIHRydWUpO1xyXG4gICAgZGVmKHByb3h5LCBcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqLywgdGFyZ2V0KTtcclxuICAgIGlmIChpc1JlZih0YXJnZXQpKSB7XHJcbiAgICAgICAgZGVmKHByb3h5LCBSZWZGbGFnLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGlmIChzaGFsbG93IHx8IGlzU2hhbGxvdyh0YXJnZXQpKSB7XHJcbiAgICAgICAgZGVmKHByb3h5LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGVmaW5lUmVhZG9ubHlQcm9wZXJ0eShwcm94eSwgdGFyZ2V0LCBrZXlzW2ldLCBzaGFsbG93KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVSZWFkb25seVByb3BlcnR5KHByb3h5LCB0YXJnZXQsIGtleSwgc2hhbGxvdykge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhbGxvdyB8fCAhaXNQbGFpbk9iamVjdCh2YWwpID8gdmFsIDogcmVhZG9ubHkodmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJTZXQgb3BlcmF0aW9uIG9uIGtleSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcclxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxyXG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpIHtcclxuICAgIHZhciBnZXR0ZXI7XHJcbiAgICB2YXIgc2V0dGVyO1xyXG4gICAgdmFyIG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XHJcbiAgICBpZiAob25seUdldHRlcikge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcclxuICAgICAgICBzZXR0ZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogbm9vcDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XHJcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICAgIH1cclxuICAgIHZhciB3YXRjaGVyID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKVxyXG4gICAgICAgID8gbnVsbFxyXG4gICAgICAgIDogbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBnZXR0ZXIsIG5vb3AsIHsgbGF6eTogdHJ1ZSB9KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhdGNoZXIgJiYgZGVidWdPcHRpb25zKSB7XHJcbiAgICAgICAgd2F0Y2hlci5vblRyYWNrID0gZGVidWdPcHRpb25zLm9uVHJhY2s7XHJcbiAgICAgICAgd2F0Y2hlci5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlZiA9IHtcclxuICAgICAgICAvLyBzb21lIGxpYnMgcmVseSBvbiB0aGUgcHJlc2VuY2UgZWZmZWN0IGZvciBjaGVja2luZyBjb21wdXRlZCByZWZzXHJcbiAgICAgICAgLy8gZnJvbSBub3JtYWwgcmVmcywgYnV0IHRoZSBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IG1hdHRlclxyXG4gICAgICAgIGVmZmVjdDogd2F0Y2hlcixcclxuICAgICAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgRGVwLnRhcmdldC5vblRyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3Q6IERlcC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgICAgIHNldHRlcihuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcclxuICAgIGRlZihyZWYsIFwiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovLCBvbmx5R2V0dGVyKTtcclxuICAgIHJldHVybiByZWY7XHJcbn1cclxuXHJcbnZhciBtYXJrO1xyXG52YXIgbWVhc3VyZTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhciBwZXJmXzEgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAocGVyZl8xICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHBlcmZfMS5tYXJrICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHBlcmZfMS5tZWFzdXJlICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHBlcmZfMS5jbGVhck1hcmtzICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHBlcmZfMS5jbGVhck1lYXN1cmVzKSB7XHJcbiAgICAgICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmZfMS5tYXJrKHRhZyk7IH07XHJcbiAgICAgICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XHJcbiAgICAgICAgICAgIHBlcmZfMS5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICAgICAgICBwZXJmXzEuY2xlYXJNYXJrcyhzdGFydFRhZyk7XHJcbiAgICAgICAgICAgIHBlcmZfMS5jbGVhck1hcmtzKGVuZFRhZyk7XHJcbiAgICAgICAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xyXG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcclxuICAgIHZhciBvbmNlID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxyXG4gICAgbmFtZSA9IG9uY2UgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcclxuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcclxuICAgIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgb25jZTogb25jZSxcclxuICAgICAgICBjYXB0dXJlOiBjYXB0dXJlLFxyXG4gICAgICAgIHBhc3NpdmU6IHBhc3NpdmVcclxuICAgIH07XHJcbn0pO1xyXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIoZm5zLCB2bSkge1xyXG4gICAgZnVuY3Rpb24gaW52b2tlcigpIHtcclxuICAgICAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZm5zKSkge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xyXG4gICAgICAgICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnZva2VyLmZucyA9IGZucztcclxuICAgIHJldHVybiBpbnZva2VyO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pIHtcclxuICAgIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XHJcbiAgICBmb3IgKG5hbWUgaW4gb24pIHtcclxuICAgICAgICBjdXIgPSBvbltuYW1lXTtcclxuICAgICAgICBvbGQgPSBvbGRPbltuYW1lXTtcclxuICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKGN1cikpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIuY29uY2F0KGV2ZW50Lm5hbWUsIFwiXFxcIjogZ290IFwiKSArIFN0cmluZyhjdXIpLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xyXG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XHJcbiAgICAgICAgICAgIG9sZC5mbnMgPSBjdXI7XHJcbiAgICAgICAgICAgIG9uW25hbWVdID0gb2xkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xyXG4gICAgICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xyXG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xyXG4gICAgICAgICAgICByZW1vdmUoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2soZGVmLCBob29rS2V5LCBob29rKSB7XHJcbiAgICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xyXG4gICAgfVxyXG4gICAgdmFyIGludm9rZXI7XHJcbiAgICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcclxuICAgIGZ1bmN0aW9uIHdyYXBwZWRIb29rKCkge1xyXG4gICAgICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXHJcbiAgICAgICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcclxuICAgICAgICByZW1vdmUkMihpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcclxuICAgICAgICAvLyBubyBleGlzdGluZyBob29rXHJcbiAgICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xyXG4gICAgICAgICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcclxuICAgICAgICAgICAgaW52b2tlciA9IG9sZEhvb2s7XHJcbiAgICAgICAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xyXG4gICAgICAgICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcclxuICAgIGRlZltob29rS2V5XSA9IGludm9rZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKSB7XHJcbiAgICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cclxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxyXG4gICAgLy8gY29tcG9uZW50IGl0c2VsZi5cclxuICAgIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcclxuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciByZXMgPSB7fTtcclxuICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnMsIHByb3BzID0gZGF0YS5wcm9wcztcclxuICAgIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiYgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aXAoXCJQcm9wIFxcXCJcIi5jb25jYXQoa2V5SW5Mb3dlckNhc2UsIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIuY29uY2F0KGZvcm1hdENvbXBvbmVudE5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGFnIGlzIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgfHwgQ3RvciksIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIuIFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIuY29uY2F0KGFsdEtleSwgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiKS5jb25jYXQoa2V5LCBcIlxcXCIuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XHJcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUHJvcChyZXMsIGhhc2gsIGtleSwgYWx0S2V5LCBwcmVzZXJ2ZSkge1xyXG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XHJcbiAgICAgICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xyXG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcclxuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxyXG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxyXG4vL1xyXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxyXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXHJcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcclxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXHJcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxyXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcclxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxyXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxyXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxyXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcclxuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcclxuICAgICAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxyXG4gICAgICAgIDogaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYyA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcclxuICAgICAgICAvLyAgbmVzdGVkXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoYykpIHtcclxuICAgICAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgXCJcIi5jb25jYXQobmVzdGVkSW5kZXggfHwgJycsIFwiX1wiKS5jb25jYXQoaSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGNbMF0udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcclxuICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIuY29uY2F0KG5lc3RlZEluZGV4LCBcIl9cIikuY29uY2F0KGksIFwiX19cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcclxudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xyXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxyXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemUpIHtcclxuICAgIGlmIChpc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XHJcbiAgICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcclxuICAgICAgICBjaGlsZHJlbiA9IGRhdGE7XHJcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xyXG4gICAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcclxuICAgIH1cclxuICAgIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSk7XHJcbn1cclxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpIHtcclxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLl9fb2JfXykpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShkYXRhKSwgXCJcXG5cIikgKyAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJywgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICAgIH1cclxuICAgIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXHJcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcclxuICAgICAgICB0YWcgPSBkYXRhLmlzO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0YWcpIHtcclxuICAgICAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICAgIH1cclxuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSkpIHtcclxuICAgICAgICB3YXJuJDIoJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcclxuICAgICAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJywgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XHJcbiAgICBpZiAoaXNBcnJheShjaGlsZHJlbikgJiYgaXNGdW5jdGlvbihjaGlsZHJlblswXSkpIHtcclxuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcclxuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xyXG4gICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICB2YXIgdm5vZGUsIG5zO1xyXG4gICAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIEN0b3IgPSB2b2lkIDA7XHJcbiAgICAgICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcclxuICAgICAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgaXNEZWYoZGF0YSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKGRhdGEubmF0aXZlT24pICYmXHJcbiAgICAgICAgICAgICAgICBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPFwiLmNvbmNhdCh0YWcsIFwiPi5cIiksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZub2RlID0gbmV3IFZOb2RlKGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJlxyXG4gICAgICAgICAgICBpc0RlZigoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSkge1xyXG4gICAgICAgICAgICAvLyBjb21wb25lbnRcclxuICAgICAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcclxuICAgICAgICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcclxuICAgICAgICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cclxuICAgICAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUodGFnLCBkYXRhLCBjaGlsZHJlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheSh2bm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcclxuICAgICAgICBpZiAoaXNEZWYobnMpKVxyXG4gICAgICAgICAgICBhcHBseU5TKHZub2RlLCBucyk7XHJcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKVxyXG4gICAgICAgICAgICByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5TlModm5vZGUsIG5zLCBmb3JjZSkge1xyXG4gICAgdm5vZGUubnMgPSBucztcclxuICAgIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xyXG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxyXG4gICAgICAgIG5zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiZcclxuICAgICAgICAgICAgICAgIChpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gcmVmICM1MzE4XHJcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXHJcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpIHtcclxuICAgIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xyXG4gICAgICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XHJcbiAgICAgICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTGlzdCh2YWwsIHJlbmRlcikge1xyXG4gICAgdmFyIHJldCA9IG51bGwsIGksIGwsIGtleXMsIGtleTtcclxuICAgIGlmIChpc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xyXG4gICAgICAgICAgICByZXQgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcclxuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc0RlZihyZXQpKSB7XHJcbiAgICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcbiAgICByZXQuX2lzVkxpc3QgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KG5hbWUsIGZhbGxiYWNrUmVuZGVyLCBwcm9wcywgYmluZE9iamVjdCkge1xyXG4gICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xyXG4gICAgdmFyIG5vZGVzO1xyXG4gICAgaWYgKHNjb3BlZFNsb3RGbikge1xyXG4gICAgICAgIC8vIHNjb3BlZCBzbG90XHJcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcclxuICAgICAgICBpZiAoYmluZE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMignc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZXMgPVxyXG4gICAgICAgICAgICBzY29wZWRTbG90Rm4ocHJvcHMpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihmYWxsYmFja1JlbmRlcikgPyBmYWxsYmFja1JlbmRlcigpIDogZmFsbGJhY2tSZW5kZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbm9kZXMgPVxyXG4gICAgICAgICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZmFsbGJhY2tSZW5kZXIpID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcclxuICAgIH1cclxuICAgIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihpZCkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaChleHBlY3QsIGFjdHVhbCkge1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxyXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcclxuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzKGV2ZW50S2V5Q29kZSwga2V5LCBidWlsdEluS2V5Q29kZSwgZXZlbnRLZXlOYW1lLCBidWlsdEluS2V5TmFtZSkge1xyXG4gICAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcclxuICAgIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50S2V5Q29kZSA9PT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyhkYXRhLCB0YWcsIHZhbHVlLCBhc1Byb3AsIGlzU3luYykge1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKCd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJyB8fCBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25bXCJ1cGRhdGU6XCIuY29uY2F0KGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX2xvb3BfMShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyhpbmRleCwgaXNJbkZvcikge1xyXG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcclxuICAgIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcclxuICAgIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxyXG4gICAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXHJcbiAgICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfVxyXG4gICAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxyXG4gICAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSwgdGhpcy5fYywgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xyXG4gICAgKTtcclxuICAgIG1hcmtTdGF0aWMkMSh0cmVlLCBcIl9fc3RhdGljX19cIi5jb25jYXQoaW5kZXgpLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gdHJlZTtcclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cclxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXJrT25jZSh0cmVlLCBpbmRleCwga2V5KSB7XHJcbiAgICBtYXJrU3RhdGljJDEodHJlZSwgXCJfX29uY2VfX1wiLmNvbmNhdChpbmRleCkuY29uY2F0KGtleSA/IFwiX1wiLmNvbmNhdChrZXkpIDogXCJcIiksIHRydWUpO1xyXG4gICAgcmV0dXJuIHRyZWU7XHJcbn1cclxuZnVuY3Rpb24gbWFya1N0YXRpYyQxKHRyZWUsIGtleSwgaXNPbmNlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh0cmVlKSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIFwiXCIuY29uY2F0KGtleSwgXCJfXCIpLmNvbmNhdChpKSwgaXNPbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZShub2RlLCBrZXksIGlzT25jZSkge1xyXG4gICAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XHJcbiAgICBub2RlLmtleSA9IGtleTtcclxuICAgIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzKGRhdGEsIHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKCd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvbiA9IChkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcclxuICAgICAgICAgICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcclxuICAgICAgICAgICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyhmbnMsIHJlcywgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxyXG5oYXNEeW5hbWljS2V5cywgY29udGVudEhhc2hLZXkpIHtcclxuICAgIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgc2xvdCA9IGZuc1tpXTtcclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgaWYgKHNsb3QucHJveHkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjb250ZW50SGFzaEtleSkge1xyXG4gICAgICAgIHJlcy4ka2V5ID0gY29udGVudEhhc2hLZXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vLyBoZWxwZXIgdG8gcHJvY2VzcyBkeW5hbWljIGtleXMgZm9yIGR5bmFtaWMgYXJndW1lbnRzIGluIHYtYmluZCBhbmQgdi1vbi5cclxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzKGJhc2VPYmosIHZhbHVlcykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcclxuICAgICAgICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcclxuICAgICAgICAgICAgd2FybiQyKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIuY29uY2F0KGtleSksIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlT2JqO1xyXG59XHJcbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxyXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxyXG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXHJcbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllcih2YWx1ZSwgc3ltYm9sKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzKHRhcmdldCkge1xyXG4gICAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XHJcbiAgICB0YXJnZXQuX24gPSB0b051bWJlcjtcclxuICAgIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xyXG4gICAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcclxuICAgIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XHJcbiAgICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xyXG4gICAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xyXG4gICAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xyXG4gICAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcclxuICAgIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XHJcbiAgICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XHJcbiAgICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XHJcbiAgICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xyXG4gICAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xyXG4gICAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcclxuICAgIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcclxuICAgIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpIHtcclxuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIHZhciBzbG90cyA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxyXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgY29udGV4dC5cclxuICAgICAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxyXG4gICAgICAgICAgICBkYXRhICYmXHJcbiAgICAgICAgICAgIGRhdGEuc2xvdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBkYXRhLnNsb3Q7XHJcbiAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbbmFtZV8xXSB8fCAoc2xvdHNbbmFtZV8xXSA9IFtdKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNsb3QucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcclxuICAgIGZvciAodmFyIG5hbWVfMiBpbiBzbG90cykge1xyXG4gICAgICAgIGlmIChzbG90c1tuYW1lXzJdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHNsb3RzW25hbWVfMl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XHJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShub2RlKSB7XHJcbiAgICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlcihub2RlKSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vdCByZWFsbHkgYm9vbGVhbiB0eXBlXHJcbiAgICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKG93bmVyVm0sIHNjb3BlZFNsb3RzLCBub3JtYWxTbG90cywgcHJldlNjb3BlZFNsb3RzKSB7XHJcbiAgICB2YXIgcmVzO1xyXG4gICAgdmFyIGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XHJcbiAgICB2YXIgaXNTdGFibGUgPSBzY29wZWRTbG90cyA/ICEhc2NvcGVkU2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcclxuICAgIHZhciBrZXkgPSBzY29wZWRTbG90cyAmJiBzY29wZWRTbG90cy4ka2V5O1xyXG4gICAgaWYgKCFzY29wZWRTbG90cykge1xyXG4gICAgICAgIHJlcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NvcGVkU2xvdHMuX25vcm1hbGl6ZWQpIHtcclxuICAgICAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcclxuICAgICAgICByZXR1cm4gc2NvcGVkU2xvdHMuX25vcm1hbGl6ZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0YWJsZSAmJlxyXG4gICAgICAgIHByZXZTY29wZWRTbG90cyAmJlxyXG4gICAgICAgIHByZXZTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcclxuICAgICAgICBrZXkgPT09IHByZXZTY29wZWRTbG90cy4ka2V5ICYmXHJcbiAgICAgICAgIWhhc05vcm1hbFNsb3RzICYmXHJcbiAgICAgICAgIXByZXZTY29wZWRTbG90cy4kaGFzTm9ybWFsKSB7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxyXG4gICAgICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxyXG4gICAgICAgIHJldHVybiBwcmV2U2NvcGVkU2xvdHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXlfMSBpbiBzY29wZWRTbG90cykge1xyXG4gICAgICAgICAgICBpZiAoc2NvcGVkU2xvdHNba2V5XzFdICYmIGtleV8xWzBdICE9PSAnJCcpIHtcclxuICAgICAgICAgICAgICAgIHJlc1trZXlfMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG93bmVyVm0sIG5vcm1hbFNsb3RzLCBrZXlfMSwgc2NvcGVkU2xvdHNba2V5XzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcclxuICAgIGZvciAodmFyIGtleV8yIGluIG5vcm1hbFNsb3RzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5XzIgaW4gcmVzKSkge1xyXG4gICAgICAgICAgICByZXNba2V5XzJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXlfMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxyXG4gICAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXHJcbiAgICBpZiAoc2NvcGVkU2xvdHMgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShzY29wZWRTbG90cykpIHtcclxuICAgICAgICBzY29wZWRTbG90cy5fbm9ybWFsaXplZCA9IHJlcztcclxuICAgIH1cclxuICAgIGRlZihyZXMsICckc3RhYmxlJywgaXNTdGFibGUpO1xyXG4gICAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xyXG4gICAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qodm0sIG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VyID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh2bSk7XHJcbiAgICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xyXG4gICAgICAgIHJlcyA9XHJcbiAgICAgICAgICAgIHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShyZXMpXHJcbiAgICAgICAgICAgICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xyXG4gICAgICAgIHZhciB2bm9kZSA9IHJlcyAmJiByZXNbMF07XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN1cik7XHJcbiAgICAgICAgcmV0dXJuIHJlcyAmJlxyXG4gICAgICAgICAgICAoIXZub2RlIHx8XHJcbiAgICAgICAgICAgICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiB2bm9kZS5pc0NvbW1lbnQgJiYgIWlzQXN5bmNQbGFjZWhvbGRlcih2bm9kZSkpKSAvLyAjOTY1OCwgIzEwMzkxXHJcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIDogcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xyXG4gICAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XHJcbiAgICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cclxuICAgIGlmIChmbi5wcm94eSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XHJcbiAgICAgICAgICAgIGdldDogbm9ybWFsaXplZCxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNsb3RzW2tleV07IH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRTZXR1cCh2bSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgIHZhciBzZXR1cCA9IG9wdGlvbnMuc2V0dXA7XHJcbiAgICBpZiAoc2V0dXApIHtcclxuICAgICAgICB2YXIgY3R4ID0gKHZtLl9zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQodm0pKTtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xyXG4gICAgICAgIHB1c2hUYXJnZXQoKTtcclxuICAgICAgICB2YXIgc2V0dXBSZXN1bHQgPSBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhzZXR1cCwgbnVsbCwgW3ZtLl9wcm9wcyB8fCBzaGFsbG93UmVhY3RpdmUoe30pLCBjdHhdLCB2bSwgXCJzZXR1cFwiKTtcclxuICAgICAgICBwb3BUYXJnZXQoKTtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgLy8gcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIC8vIGJpbmRpbmdzXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNldHVwUmVzdWx0IGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcInNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwicmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZtLl9zZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vIF9fc2ZjIGluZGljYXRlcyBjb21waWxlZCBiaW5kaW5ncyBmcm9tIDxzY3JpcHQgc2V0dXA+XHJcbiAgICAgICAgICAgIGlmICghc2V0dXBSZXN1bHQuX19zZmMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzZXR1cFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2l0aFJlZlVud3JhcCh2bSwgc2V0dXBSZXN1bHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKFwiQXZvaWQgdXNpbmcgdmFyaWFibGVzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQgaW4gc2V0dXAoKS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlZCBmb3IgY29tcGlsZWQgcmVuZGVyIGZuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSAodm0uX3NldHVwUHJveHkgPSB7fSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2V0dXBSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnX19zZmMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgc2V0dXBSZXN1bHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogXCIuY29uY2F0KHNldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dCh2bSkge1xyXG4gICAgdmFyIGV4cG9zZUNhbGxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgIGlmICghdm0uX2F0dHJzUHJveHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9ICh2bS5fYXR0cnNQcm94eSA9IHt9KTtcclxuICAgICAgICAgICAgICAgIGRlZihwcm94eSwgJ192X2F0dHJfcHJveHknLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFByb3h5KHByb3h5LCB2bS4kYXR0cnMsIGVtcHR5T2JqZWN0LCB2bSwgJyRhdHRycycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2bS5fYXR0cnNQcm94eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBsaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgICAgIGlmICghdm0uX2xpc3RlbmVyc1Byb3h5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSAodm0uX2xpc3RlbmVyc1Byb3h5ID0ge30pO1xyXG4gICAgICAgICAgICAgICAgc3luY1NldHVwUHJveHkocHJveHksIHZtLiRsaXN0ZW5lcnMsIGVtcHR5T2JqZWN0LCB2bSwgJyRsaXN0ZW5lcnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdm0uX2xpc3RlbmVyc1Byb3h5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNsb3RzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5pdFNsb3RzUHJveHkodm0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW1pdDogYmluZCQxKHZtLiRlbWl0LCB2bSksXHJcbiAgICAgICAgZXhwb3NlOiBmdW5jdGlvbiAoZXhwb3NlZCkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cG9zZUNhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcImV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLlwiLCB2bSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBvc2VDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChleHBvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhleHBvc2VkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlXaXRoUmVmVW53cmFwKHZtLCBleHBvc2VkLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNTZXR1cFByb3h5KHRvLCBmcm9tLCBwcmV2LCBpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHRvKSkge1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZGVmaW5lUHJveHlBdHRyKHRvLCBrZXksIGluc3RhbmNlLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJvbVtrZXldICE9PSBwcmV2W2tleV0pIHtcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIHRvKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBkZWxldGUgdG9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVQcm94eUF0dHIocHJveHksIGtleSwgaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwga2V5LCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVt0eXBlXVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTbG90c1Byb3h5KHZtKSB7XHJcbiAgICBpZiAoIXZtLl9zbG90c1Byb3h5KSB7XHJcbiAgICAgICAgc3luY1NldHVwU2xvdHMoKHZtLl9zbG90c1Byb3h5ID0ge30pLCB2bS4kc2NvcGVkU2xvdHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZtLl9zbG90c1Byb3h5O1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNTZXR1cFNsb3RzKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdG8pIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRvW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXHJcbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXHJcbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xyXG59XHJcbi8qKlxyXG4gKiBWdWUgMiBvbmx5XHJcbiAqIEBpbnRlcm5hbCB1c2UgbWFudWFsIHR5cGUgZGVmIGJlY2F1c2UgcHVibGljIHNldHVwIGNvbnRleHQgdHlwZSByZWxpZXMgb25cclxuICogbGVnYWN5IFZOb2RlIHR5cGVzXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VMaXN0ZW5lcnMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmxpc3RlbmVycztcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHdhcm4kMihcInVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHZtID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgcmV0dXJuIHZtLl9zZXR1cENvbnRleHQgfHwgKHZtLl9zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQodm0pKTtcclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcclxuICogb25seS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcclxuICAgIHZhciBwcm9wcyA9IGlzQXJyYXkocmF3KVxyXG4gICAgICAgID8gcmF3LnJlZHVjZShmdW5jdGlvbiAobm9ybWFsaXplZCwgcCkgeyByZXR1cm4gKChub3JtYWxpemVkW3BdID0ge30pLCBub3JtYWxpemVkKTsgfSwge30pXHJcbiAgICAgICAgOiByYXc7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgICB2YXIgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgICAgICBpZiAob3B0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcInByb3BzIGRlZmF1bHQga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRSZW5kZXIodm0pIHtcclxuICAgIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXHJcbiAgICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXHJcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xyXG4gICAgdmFyIHBhcmVudFZub2RlID0gKHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlKTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcclxuICAgIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcclxuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XHJcbiAgICB2bS4kc2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZVxyXG4gICAgICAgID8gbm9ybWFsaXplU2NvcGVkU2xvdHModm0uJHBhcmVudCwgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cywgdm0uJHNsb3RzKVxyXG4gICAgICAgIDogZW1wdHlPYmplY3Q7XHJcbiAgICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcclxuICAgIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXHJcbiAgICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXHJcbiAgICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCQxKHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XHJcbiAgICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cclxuICAgIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCQxKHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcclxuICAgIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXHJcbiAgICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXHJcbiAgICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIChwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybiQyKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybiQyKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCAocGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcclxuICAgIH1cclxufVxyXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxuZnVuY3Rpb24gcmVuZGVyTWl4aW4oVnVlKSB7XHJcbiAgICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xyXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XHJcbiAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hID0gdm0uJG9wdGlvbnMsIHJlbmRlciA9IF9hLnJlbmRlciwgX3BhcmVudFZub2RlID0gX2EuX3BhcmVudFZub2RlO1xyXG4gICAgICAgIGlmIChfcGFyZW50Vm5vZGUgJiYgdm0uX2lzTW91bnRlZCkge1xyXG4gICAgICAgICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyh2bS4kcGFyZW50LCBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cywgdm0uJHNsb3RzLCB2bS4kc2NvcGVkU2xvdHMpO1xyXG4gICAgICAgICAgICBpZiAodm0uX3Nsb3RzUHJveHkpIHtcclxuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFNsb3RzKHZtLl9zbG90c1Byb3h5LCB2bS4kc2NvcGVkU2xvdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcclxuICAgICAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cclxuICAgICAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XHJcbiAgICAgICAgLy8gcmVuZGVyIHNlbGZcclxuICAgICAgICB2YXIgcHJldkluc3QgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICAgICAgdmFyIHByZXZSZW5kZXJJbnN0ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgICAgIHZhciB2bm9kZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcclxuICAgICAgICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcclxuICAgICAgICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBwcmV2UmVuZGVySW5zdDtcclxuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHByZXZJbnN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcclxuICAgICAgICBpZiAoaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHZub2RlID0gdm5vZGVbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcclxuICAgICAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHBhcmVudFxyXG4gICAgICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnN1cmVDdG9yKGNvbXAsIGJhc2UpIHtcclxuICAgIGlmIChjb21wLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xyXG4gICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNPYmplY3QoY29tcCkgPyBiYXNlLmV4dGVuZChjb21wKSA6IGNvbXA7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihmYWN0b3J5LCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKSB7XHJcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICAgIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcclxuICAgIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQoZmFjdG9yeSwgYmFzZUN0b3IpIHtcclxuICAgIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWQ7XHJcbiAgICB9XHJcbiAgICB2YXIgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xyXG4gICAgICAgIC8vIGFscmVhZHkgcGVuZGluZ1xyXG4gICAgICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXA7XHJcbiAgICB9XHJcbiAgICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xyXG4gICAgICAgIHZhciBvd25lcnNfMSA9IChmYWN0b3J5Lm93bmVycyA9IFtvd25lcl0pO1xyXG4gICAgICAgIHZhciBzeW5jXzEgPSB0cnVlO1xyXG4gICAgICAgIHZhciB0aW1lckxvYWRpbmdfMSA9IG51bGw7XHJcbiAgICAgICAgdmFyIHRpbWVyVGltZW91dF8xID0gbnVsbDtcclxuICAgICAgICBvd25lci4kb24oJ2hvb2s6ZGVzdHJveWVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlJDIob3duZXJzXzEsIG93bmVyKTsgfSk7XHJcbiAgICAgICAgdmFyIGZvcmNlUmVuZGVyXzEgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3duZXJzXzEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBvd25lcnNfMVtpXS4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvd25lcnNfMS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyTG9hZGluZ18xICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZ18xKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmdfMSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXJUaW1lb3V0XzEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0XzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dF8xID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcclxuICAgICAgICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcclxuICAgICAgICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXHJcbiAgICAgICAgICAgIGlmICghc3luY18xKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcl8xKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3duZXJzXzEubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByZWplY3RfMSA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiLmNvbmNhdChTdHJpbmcoZmFjdG9yeSkpICtcclxuICAgICAgICAgICAgICAgICAgICAocmVhc29uID8gXCJcXG5SZWFzb246IFwiLmNvbmNhdChyZWFzb24pIDogJycpKTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcl8xKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJlc18xID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3RfMSk7XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlc18xKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHJlc18xKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNfMS50aGVuKHJlc29sdmUsIHJlamVjdF8xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1Byb21pc2UocmVzXzEuY29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzXzEuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0XzEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlc18xLmVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXNfMS5lcnJvciwgYmFzZUN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlc18xLmxvYWRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzXzEubG9hZGluZywgYmFzZUN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNfMS5kZWxheSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOb2RlSlMgdGltZW91dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZ18xID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmdfMSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcl8xKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzXzEuZGVsYXkgfHwgMjAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocmVzXzEudGltZW91dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vZGVKUyB0aW1lb3V0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICB0aW1lclRpbWVvdXRfMSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lclRpbWVvdXRfMSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RfMShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gXCJ0aW1lb3V0IChcIi5jb25jYXQocmVzXzEudGltZW91dCwgXCJtcylcIikgOiBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc18xLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN5bmNfMSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcclxuICAgICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nID8gZmFjdG9yeS5sb2FkaW5nQ29tcCA6IGZhY3RvcnkucmVzb2x2ZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY2hpbGRyZW4pIHtcclxuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0RXZlbnRzKHZtKSB7XHJcbiAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcclxuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xyXG4gICAgfVxyXG59XHJcbnZhciB0YXJnZXQkMTtcclxuZnVuY3Rpb24gYWRkJDEoZXZlbnQsIGZuKSB7XHJcbiAgICB0YXJnZXQkMS4kb24oZXZlbnQsIGZuKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmUkMShldmVudCwgZm4pIHtcclxuICAgIHRhcmdldCQxLiRvZmYoZXZlbnQsIGZuKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxKGV2ZW50LCBmbikge1xyXG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcclxuICAgICAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycykge1xyXG4gICAgdGFyZ2V0JDEgPSB2bTtcclxuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkJDEsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bSk7XHJcbiAgICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBldmVudHNNaXhpbihWdWUpIHtcclxuICAgIHZhciBob29rUkUgPSAvXmhvb2s6LztcclxuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XHJcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxyXG4gICAgICAgICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvbi5mbiA9IGZuO1xyXG4gICAgICAgIHZtLiRvbihldmVudCwgb24pO1xyXG4gICAgICAgIHJldHVybiB2bTtcclxuICAgIH07XHJcbiAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICAvLyBhbGxcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXJyYXkgb2YgZXZlbnRzXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGlfMSA8IGw7IGlfMSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2bS4kb2ZmKGV2ZW50W2lfMV0sIGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdm07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xyXG4gICAgICAgIGlmICghY2JzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmbikge1xyXG4gICAgICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxyXG4gICAgICAgIHZhciBjYjtcclxuICAgICAgICB2YXIgaSA9IGNicy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBjYiA9IGNic1tpXTtcclxuICAgICAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xyXG4gICAgICAgICAgICAgICAgdGlwKFwiRXZlbnQgXFxcIlwiLmNvbmNhdChsb3dlckNhc2VFdmVudCwgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJcIi5jb25jYXQoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSksIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIpLmNvbmNhdChldmVudCwgXCJcXFwiLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIi5jb25jYXQoaHlwaGVuYXRlKGV2ZW50KSwgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiKS5jb25jYXQoZXZlbnQsIFwiXFxcIi5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcclxuICAgICAgICBpZiAoY2JzKSB7XHJcbiAgICAgICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIi5jb25jYXQoZXZlbnQsIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZtO1xyXG4gICAgfTtcclxufVxyXG5cclxudmFyIGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG52YXIgRWZmZWN0U2NvcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFZmZlY3RTY29wZShkZXRhY2hlZCkge1xyXG4gICAgICAgIGlmIChkZXRhY2hlZCA9PT0gdm9pZCAwKSB7IGRldGFjaGVkID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG4gICAgICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9XHJcbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEVmZmVjdFNjb3BlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcImNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRWZmZWN0U2NvcGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBFZmZlY3RTY29wZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XHJcbiAgICB9O1xyXG4gICAgRWZmZWN0U2NvcGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoZnJvbVBhcmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IHZvaWQgMCwgbCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS50ZWFyZG93bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbmVzdGVkIHNjb3BlLCBkZXJlZmVyZW5jZSBmcm9tIHBhcmVudCB0byBhdm9pZCBtZW1vcnkgbGVha3NcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgTygxKSByZW1vdmFsXHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRWZmZWN0U2NvcGU7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlKSB7XHJcbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlOyB9XHJcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XHJcbiAgICAgICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xyXG4gICAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG59XHJcbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XHJcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuJDIoXCJvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGVcIiArXHJcbiAgICAgICAgICAgIFwiIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5cIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XHJcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcclxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcclxuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcclxuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHZtKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xyXG4gICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcclxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcclxuICAgIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgICAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xyXG4gICAgfVxyXG4gICAgdm0uJHBhcmVudCA9IHBhcmVudDtcclxuICAgIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XHJcbiAgICB2bS4kY2hpbGRyZW4gPSBbXTtcclxuICAgIHZtLiRyZWZzID0ge307XHJcbiAgICB2bS5fcHJvdmlkZWQgPSBwYXJlbnQgPyBwYXJlbnQuX3Byb3ZpZGVkIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZtLl93YXRjaGVyID0gbnVsbDtcclxuICAgIHZtLl9pbmFjdGl2ZSA9IG51bGw7XHJcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcclxuICAgIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcclxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbihWdWUpIHtcclxuICAgIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xyXG4gICAgICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XHJcbiAgICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcclxuICAgICAgICB2bS5fdm5vZGUgPSB2bm9kZTtcclxuICAgICAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcclxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cclxuICAgICAgICBpZiAoIXByZXZWbm9kZSkge1xyXG4gICAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZXNcclxuICAgICAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcclxuICAgICAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcclxuICAgICAgICBpZiAocHJldkVsKSB7XHJcbiAgICAgICAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICAgICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXHJcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB2bTtcclxuICAgICAgICB3aGlsZSAod3JhcHBlciAmJlxyXG4gICAgICAgICAgICB3cmFwcGVyLiR2bm9kZSAmJlxyXG4gICAgICAgICAgICB3cmFwcGVyLiRwYXJlbnQgJiZcclxuICAgICAgICAgICAgd3JhcHBlci4kdm5vZGUgPT09IHdyYXBwZXIuJHBhcmVudC5fdm5vZGUpIHtcclxuICAgICAgICAgICAgd3JhcHBlci4kcGFyZW50LiRlbCA9IHdyYXBwZXIuJGVsO1xyXG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlci4kcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXHJcbiAgICAgICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cclxuICAgIH07XHJcbiAgICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xyXG4gICAgICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVEZXN0cm95Jyk7XHJcbiAgICAgICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xyXG4gICAgICAgICAgICByZW1vdmUkMihwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRlYXJkb3duIHNjb3BlLiB0aGlzIGluY2x1ZGVzIGJvdGggdGhlIHJlbmRlciB3YXRjaGVyIGFuZCBvdGhlclxyXG4gICAgICAgIC8vIHdhdGNoZXJzIGNyZWF0ZWRcclxuICAgICAgICB2bS5fc2NvcGUuc3RvcCgpO1xyXG4gICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXHJcbiAgICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXHJcbiAgICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xyXG4gICAgICAgICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cclxuICAgICAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxyXG4gICAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xyXG4gICAgICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnZGVzdHJveWVkJyk7XHJcbiAgICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cclxuICAgICAgICB2bS4kb2ZmKCk7XHJcbiAgICAgICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXHJcbiAgICAgICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICAgICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcclxuICAgICAgICBpZiAodm0uJHZub2RlKSB7XHJcbiAgICAgICAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQodm0sIGVsLCBoeWRyYXRpbmcpIHtcclxuICAgIHZtLiRlbCA9IGVsO1xyXG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGludmFsaWQgdHlwZVxyXG4gICAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XHJcbiAgICAgICAgICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fFxyXG4gICAgICAgICAgICAgICAgZWwpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMignWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJywgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJywgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICB2YXIgdXBkYXRlQ29tcG9uZW50O1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcclxuICAgICAgICAgICAgdmFyIGlkID0gdm0uX3VpZDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIi5jb25jYXQoaWQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIuY29uY2F0KGlkKTtcclxuICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XHJcbiAgICAgICAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcclxuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdChuYW1lLCBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcclxuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdChuYW1lLCBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHZhciB3YXRjaGVyT3B0aW9ucyA9IHtcclxuICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2F0Y2hlck9wdGlvbnMub25UcmFjayA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBjYWxsSG9vayQxKHZtLCAncmVuZGVyVHJhY2tlZCcsIFtlXSk7IH07XHJcbiAgICAgICAgd2F0Y2hlck9wdGlvbnMub25UcmlnZ2VyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNhbGxIb29rJDEodm0sICdyZW5kZXJUcmlnZ2VyZWQnLCBbZV0pOyB9O1xyXG4gICAgfVxyXG4gICAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcclxuICAgIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXHJcbiAgICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXHJcbiAgICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB3YXRjaGVyT3B0aW9ucywgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xyXG4gICAgaHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAvLyBmbHVzaCBidWZmZXIgZm9yIGZsdXNoOiBcInByZVwiIHdhdGNoZXJzIHF1ZXVlZCBpbiBzZXR1cCgpXHJcbiAgICB2YXIgcHJlV2F0Y2hlcnMgPSB2bS5fcHJlV2F0Y2hlcnM7XHJcbiAgICBpZiAocHJlV2F0Y2hlcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVdhdGNoZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByZVdhdGNoZXJzW2ldLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXHJcbiAgICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xyXG4gICAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ21vdW50ZWQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCh2bSwgcHJvcHNEYXRhLCBsaXN0ZW5lcnMsIHBhcmVudFZub2RlLCByZW5kZXJDaGlsZHJlbikge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXHJcbiAgICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cclxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcclxuICAgIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXHJcbiAgICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXHJcbiAgICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xyXG4gICAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xyXG4gICAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxyXG4gICAgICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XHJcbiAgICAgICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KSB8fFxyXG4gICAgICAgICghbmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkpKTtcclxuICAgIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcclxuICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxyXG4gICAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXHJcbiAgICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKHJlbmRlckNoaWxkcmVuIHx8IC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXHJcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXHJcbiAgICAgICAgaGFzRHluYW1pY1Njb3BlZFNsb3QpO1xyXG4gICAgdmFyIHByZXZWTm9kZSA9IHZtLiR2bm9kZTtcclxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xyXG4gICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcclxuICAgIGlmICh2bS5fdm5vZGUpIHtcclxuICAgICAgICAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxyXG4gICAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcclxuICAgIH1cclxuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xyXG4gICAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXHJcbiAgICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcclxuICAgIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXHJcbiAgICB2YXIgYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xyXG4gICAgaWYgKHZtLl9hdHRyc1Byb3h5KSB7XHJcbiAgICAgICAgLy8gZm9yY2UgdXBkYXRlIGlmIGF0dHJzIGFyZSBhY2Nlc3NlZCBhbmQgaGFzIGNoYW5nZWQgc2luY2UgaXQgbWF5IGJlXHJcbiAgICAgICAgLy8gcGFzc2VkIHRvIGEgY2hpbGQgY29tcG9uZW50LlxyXG4gICAgICAgIGlmIChzeW5jU2V0dXBQcm94eSh2bS5fYXR0cnNQcm94eSwgYXR0cnMsIChwcmV2Vk5vZGUuZGF0YSAmJiBwcmV2Vk5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3QsIHZtLCAnJGF0dHJzJykpIHtcclxuICAgICAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm0uJGF0dHJzID0gYXR0cnM7XHJcbiAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXHJcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XHJcbiAgICB2YXIgcHJldkxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICBpZiAodm0uX2xpc3RlbmVyc1Byb3h5KSB7XHJcbiAgICAgICAgc3luY1NldHVwUHJveHkodm0uX2xpc3RlbmVyc1Byb3h5LCBsaXN0ZW5lcnMsIHByZXZMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIHZtLCAnJGxpc3RlbmVycycpO1xyXG4gICAgfVxyXG4gICAgdm0uJGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XHJcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgcHJldkxpc3RlbmVycyk7XHJcbiAgICAvLyB1cGRhdGUgcHJvcHNcclxuICAgIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcclxuICAgICAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XHJcbiAgICAgICAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG4gICAgICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcclxuICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XHJcbiAgICB9XHJcbiAgICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxyXG4gICAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcclxuICAgICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xyXG4gICAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlKHZtKSB7XHJcbiAgICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcclxuICAgICAgICBpZiAodm0uX2luYWN0aXZlKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLCBkaXJlY3QpIHtcclxuICAgIGlmIChkaXJlY3QpIHtcclxuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XHJcbiAgICAgICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnYWN0aXZhdGVkJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLCBkaXJlY3QpIHtcclxuICAgIGlmIChkaXJlY3QpIHtcclxuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF2bS5faW5hY3RpdmUpIHtcclxuICAgICAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnZGVhY3RpdmF0ZWQnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSG9vayQxKHZtLCBob29rLCBhcmdzLCBzZXRDb250ZXh0KSB7XHJcbiAgICBpZiAoc2V0Q29udGV4dCA9PT0gdm9pZCAwKSB7IHNldENvbnRleHQgPSB0cnVlOyB9XHJcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICBwdXNoVGFyZ2V0KCk7XHJcbiAgICB2YXIgcHJldkluc3QgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICB2YXIgcHJldlNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XHJcbiAgICBzZXRDb250ZXh0ICYmIHNldEN1cnJlbnRJbnN0YW5jZSh2bSk7XHJcbiAgICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcclxuICAgIHZhciBpbmZvID0gXCJcIi5jb25jYXQoaG9vaywgXCIgaG9va1wiKTtcclxuICAgIGlmIChoYW5kbGVycykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGhhbmRsZXJzW2ldLCB2bSwgYXJncyB8fCBudWxsLCB2bSwgaW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcclxuICAgICAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0Q29udGV4dCkge1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShwcmV2SW5zdCk7XHJcbiAgICAgICAgcHJldlNjb3BlICYmIHByZXZTY29wZS5vbigpO1xyXG4gICAgfVxyXG4gICAgcG9wVGFyZ2V0KCk7XHJcbn1cclxuXHJcbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xyXG52YXIgcXVldWUgPSBbXTtcclxudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XHJcbnZhciBoYXMgPSB7fTtcclxudmFyIGNpcmN1bGFyID0ge307XHJcbnZhciB3YWl0aW5nID0gZmFsc2U7XHJcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xyXG52YXIgaW5kZXgkMSA9IDA7XHJcbi8qKlxyXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlKCkge1xyXG4gICAgaW5kZXgkMSA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICBoYXMgPSB7fTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgY2lyY3VsYXIgPSB7fTtcclxuICAgIH1cclxuICAgIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xyXG59XHJcbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcclxuLy8gYXR0YWNoZWQuIEhvd2V2ZXIsIGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgaGFzIGEgcGVyZiBvdmVyaGVhZCBlc3BlY2lhbGx5XHJcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXHJcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xyXG4vLyBhdHRhY2hlZCBkdXJpbmcgdGhhdCBmbHVzaC5cclxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XHJcbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXHJcbnZhciBnZXROb3cgPSBEYXRlLm5vdztcclxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXHJcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuLy8gQWxsIElFIHZlcnNpb25zIHVzZSBsb3ctcmVzIGV2ZW50IHRpbWVzdGFtcHMsIGFuZCBoYXZlIHByb2JsZW1hdGljIGNsb2NrXHJcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXHJcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcclxuICAgIHZhciBwZXJmb3JtYW5jZV8xID0gd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gICAgaWYgKHBlcmZvcm1hbmNlXzEgJiZcclxuICAgICAgICB0eXBlb2YgcGVyZm9ybWFuY2VfMS5ub3cgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXHJcbiAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xyXG4gICAgICAgIC8vIHdlbGwuXHJcbiAgICAgICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2VfMS5ub3coKTsgfTtcclxuICAgIH1cclxufVxyXG52YXIgc29ydENvbXBhcmVGbiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYS5wb3N0KSB7XHJcbiAgICAgICAgaWYgKCFiLnBvc3QpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYi5wb3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xyXG59O1xyXG4vKipcclxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlKCkge1xyXG4gICAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XHJcbiAgICBmbHVzaGluZyA9IHRydWU7XHJcbiAgICB2YXIgd2F0Y2hlciwgaWQ7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxyXG4gICAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxyXG4gICAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxyXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcclxuICAgIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cclxuICAgIHF1ZXVlLnNvcnQoc29ydENvbXBhcmVGbik7XHJcbiAgICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcclxuICAgIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xyXG4gICAgZm9yIChpbmRleCQxID0gMDsgaW5kZXgkMSA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgkMSsrKSB7XHJcbiAgICAgICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4JDFdO1xyXG4gICAgICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xyXG4gICAgICAgICAgICB3YXRjaGVyLmJlZm9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZCA9IHdhdGNoZXIuaWQ7XHJcbiAgICAgICAgaGFzW2lkXSA9IG51bGw7XHJcbiAgICAgICAgd2F0Y2hlci5ydW4oKTtcclxuICAgICAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xyXG4gICAgICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHdhdGNoZXIudXNlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiLmNvbmNhdCh3YXRjaGVyLmV4cHJlc3Npb24sIFwiXFxcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiKSwgd2F0Y2hlci52bSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcclxuICAgIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XHJcbiAgICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcclxuICAgIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcclxuICAgIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xyXG4gICAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcclxuICAgIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcclxuICAgIGNsZWFudXBEZXBzKCk7XHJcbiAgICAvLyBkZXZ0b29sIGhvb2tcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xyXG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyhxdWV1ZSkge1xyXG4gICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcclxuICAgICAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xyXG4gICAgICAgIGlmICh2bSAmJiB2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2skMSh2bSwgJ3VwZGF0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cclxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQodm0pIHtcclxuICAgIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cclxuICAgIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXHJcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcclxuICAgIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyhxdWV1ZSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cclxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXHJcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVldWVXYXRjaGVyKHdhdGNoZXIpIHtcclxuICAgIHZhciBpZCA9IHdhdGNoZXIuaWQ7XHJcbiAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHdhdGNoZXIgPT09IERlcC50YXJnZXQgJiYgd2F0Y2hlci5ub1JlY3Vyc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBoYXNbaWRdID0gdHJ1ZTtcclxuICAgIGlmICghZmx1c2hpbmcpIHtcclxuICAgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxyXG4gICAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xyXG4gICAgICAgIHdoaWxlIChpID4gaW5kZXgkMSAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcclxuICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXHJcbiAgICBpZiAoIXdhaXRpbmcpIHtcclxuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIFdBVENIRVIgPSBcIndhdGNoZXJcIjtcclxudmFyIFdBVENIRVJfQ0IgPSBcIlwiLmNvbmNhdChXQVRDSEVSLCBcIiBjYWxsYmFja1wiKTtcclxudmFyIFdBVENIRVJfR0VUVEVSID0gXCJcIi5jb25jYXQoV0FUQ0hFUiwgXCIgZ2V0dGVyXCIpO1xyXG52YXIgV0FUQ0hFUl9DTEVBTlVQID0gXCJcIi5jb25jYXQoV0FUQ0hFUiwgXCIgY2xlYW51cFwiKTtcclxuLy8gU2ltcGxlIGVmZmVjdC5cclxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcclxuICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3Bvc3QnIH0pIDogeyBmbHVzaDogJ3Bvc3QnIH0pKTtcclxufVxyXG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXHJcbiAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSA6IHsgZmx1c2g6ICdzeW5jJyB9KSk7XHJcbn1cclxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcclxudmFyIElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB3YXJuJDIoXCJgd2F0Y2goZm4sIG9wdGlvbnM/KWAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBcIiArXHJcbiAgICAgICAgICAgIFwiVXNlIGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pYCBpbnN0ZWFkLiBgd2F0Y2hgIG5vdyBvbmx5IFwiICtcclxuICAgICAgICAgICAgXCJzdXBwb3J0cyBgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIF9hKSB7XHJcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8gZW1wdHlPYmplY3QgOiBfYSwgaW1tZWRpYXRlID0gX2IuaW1tZWRpYXRlLCBkZWVwID0gX2IuZGVlcCwgX2MgPSBfYi5mbHVzaCwgZmx1c2ggPSBfYyA9PT0gdm9pZCAwID8gJ3ByZScgOiBfYywgb25UcmFjayA9IF9iLm9uVHJhY2ssIG9uVHJpZ2dlciA9IF9iLm9uVHJpZ2dlcjtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJ3YXRjaCgpIFxcXCJpbW1lZGlhdGVcXFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBcIiArXHJcbiAgICAgICAgICAgICAgICBcIndhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcIndhdGNoKCkgXFxcImRlZXBcXFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBcIiArXHJcbiAgICAgICAgICAgICAgICBcIndhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciB3YXJuSW52YWxpZFNvdXJjZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgd2FybiQyKFwiSW52YWxpZCB3YXRjaCBzb3VyY2U6IFwiLmNvbmNhdChzLCBcIi4gQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IFwiKSArXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuXCIpO1xyXG4gICAgfTtcclxuICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHZhciBjYWxsID0gZnVuY3Rpb24gKGZuLCB0eXBlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciByZXMgPSBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbiwgbnVsbCwgYXJncywgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgICAgIGlmIChkZWVwICYmIHJlcyAmJiByZXMuX19vYl9fKVxyXG4gICAgICAgICAgICByZXMuX19vYl9fLmRlcC5kZXBlbmQoKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXR0ZXI7XHJcbiAgICB2YXIgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICB2YXIgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2UudmFsdWU7IH07XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5fX29iX18uZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZShmdW5jdGlvbiAocykgeyByZXR1cm4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocyk7IH0pO1xyXG4gICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5tYXAoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1JlZihzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMuX19vYl9fLmRlcC5kZXBlbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGwocywgV0FUQ0hFUl9HRVRURVIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyBnZXR0ZXIgd2l0aCBjYlxyXG4gICAgICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsKHNvdXJjZSwgV0FUQ0hFUl9HRVRURVIpOyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxyXG4gICAgICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbChzb3VyY2UsIFdBVENIRVIsIFtvbkNsZWFudXBdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnZXR0ZXIgPSBub29wO1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcclxuICAgIH1cclxuICAgIGlmIChjYiAmJiBkZWVwKSB7XHJcbiAgICAgICAgdmFyIGJhc2VHZXR0ZXJfMSA9IGdldHRlcjtcclxuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmF2ZXJzZShiYXNlR2V0dGVyXzEoKSk7IH07XHJcbiAgICB9XHJcbiAgICB2YXIgY2xlYW51cDtcclxuICAgIHZhciBvbkNsZWFudXAgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBjbGVhbnVwID0gd2F0Y2hlci5vblN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNhbGwoZm4sIFdBVENIRVJfQ0xFQU5VUCk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBpbiBTU1IgdGhlcmUgaXMgbm8gbmVlZCB0byBzZXR1cCBhbiBhY3R1YWwgZWZmZWN0LCBhbmQgaXQgc2hvdWxkIGJlIG5vb3BcclxuICAgIC8vIHVubGVzcyBpdCdzIGVhZ2VyXHJcbiAgICBpZiAoaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xyXG4gICAgICAgIC8vIHdlIHdpbGwgYWxzbyBub3QgY2FsbCB0aGUgaW52YWxpZGF0ZSBjYWxsYmFjayAoKyBydW5uZXIgaXMgbm90IHNldCB1cClcclxuICAgICAgICBvbkNsZWFudXAgPSBub29wO1xyXG4gICAgICAgIGlmICghY2IpIHtcclxuICAgICAgICAgICAgZ2V0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICBjYWxsKGNiLCBXQVRDSEVSX0NCLCBbXHJcbiAgICAgICAgICAgICAgICBnZXR0ZXIoKSxcclxuICAgICAgICAgICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICB9XHJcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKGN1cnJlbnRJbnN0YW5jZSwgZ2V0dGVyLCBub29wLCB7XHJcbiAgICAgICAgbGF6eTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB3YXRjaGVyLm5vUmVjdXJzZSA9ICFjYjtcclxuICAgIHZhciBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBbXSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcclxuICAgIC8vIG92ZXJ3cml0ZSBkZWZhdWx0IHJ1blxyXG4gICAgd2F0Y2hlci5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF3YXRjaGVyLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxyXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB3YXRjaGVyLmdldCgpO1xyXG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxyXG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNNdWx0aVNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZShmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbChjYiwgV0FUQ0hFUl9DQiwgW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxyXG4gICAgICAgICAgICB3YXRjaGVyLmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xyXG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gd2F0Y2hlci5ydW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgd2F0Y2hlci5wb3N0ID0gdHJ1ZTtcclxuICAgICAgICB3YXRjaGVyLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHByZVxyXG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UgPT09IGN1cnJlbnRJbnN0YW5jZSAmJiAhaW5zdGFuY2UuX2lzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlLXdhdGNoZXIgdHJpZ2dlcmVkIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGluc3RhbmNlLl9wcmVXYXRjaGVycyB8fCAoaW5zdGFuY2UuX3ByZVdhdGNoZXJzID0gW10pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5pbmRleE9mKHdhdGNoZXIpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh3YXRjaGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhdGNoZXIub25UcmFjayA9IG9uVHJhY2s7XHJcbiAgICAgICAgd2F0Y2hlci5vblRyaWdnZXIgPSBvblRyaWdnZXI7XHJcbiAgICB9XHJcbiAgICAvLyBpbml0aWFsIHJ1blxyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICB3YXRjaGVyLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSB3YXRjaGVyLmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcgJiYgaW5zdGFuY2UpIHtcclxuICAgICAgICBpbnN0YW5jZS4kb25jZSgnaG9vazptb3VudGVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gd2F0Y2hlci5nZXQoKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3YXRjaGVyLmdldCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgd2FybiQyKFwicHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICByZXNvbHZlUHJvdmlkZWQoY3VycmVudEluc3RhbmNlKVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3ZpZGVkKHZtKSB7XHJcbiAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcclxuICAgIC8vIGJ1dCB3aGVuIGl0IG5lZWRzIHRvIHByb3ZpZGUgdmFsdWVzIG9mIGl0cyBvd24sIGl0IGNyZWF0ZXMgaXRzXHJcbiAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxyXG4gICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcclxuICAgIC8vIHBhcmVudCBhbmQgbGV0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG8gdGhlIHdvcmsuXHJcbiAgICB2YXIgZXhpc3RpbmcgPSB2bS5fcHJvdmlkZWQ7XHJcbiAgICB2YXIgcGFyZW50UHJvdmlkZXMgPSB2bS4kcGFyZW50ICYmIHZtLiRwYXJlbnQuX3Byb3ZpZGVkO1xyXG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBleGlzdGluZykge1xyXG4gICAgICAgIHJldHVybiAodm0uX3Byb3ZpZGVkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5KSB7XHJcbiAgICBpZiAodHJlYXREZWZhdWx0QXNGYWN0b3J5ID09PSB2b2lkIDApIHsgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2U7IH1cclxuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXHJcbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyAjMjQwMFxyXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXHJcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcclxuICAgICAgICB2YXIgcHJvdmlkZXMgPSBpbnN0YW5jZS4kcGFyZW50ICYmIGluc3RhbmNlLiRwYXJlbnQuX3Byb3ZpZGVkO1xyXG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UpXHJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJpbmplY3Rpb24gXFxcIlwiLmNvbmNhdChTdHJpbmcoa2V5KSwgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuJDIoXCJpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5cIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgcHVibGljIHR5cGUgZGVjbGFyYXRpb24gYmVjYXVzZSBpdCByZWxpZXNcclxuICogb24gcHJldmlvdXNseSBtYW51YWxseSBhdXRob3JlZCB0eXBlcyBmcm9tIFZ1ZSAyXHJcbiAqL1xyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcImdsb2JhbGx5IGltcG9ydGVkIGgoKSBjYW4gb25seSBiZSBpbnZva2VkIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlIFwiICtcclxuICAgICAgICAgICAgICAgIFwiY29tcG9uZW50IGluc3RhbmNlLCBlLmcuIHN5bmNocm9ub3VzbHkgaW4gYSBjb21wb25lbnQncyByZW5kZXIgb3Igc2V0dXAgZnVuY3Rpb24uXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMShjdXJyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgMiwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pIHtcclxuICAgIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxyXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxyXG4gICAgcHVzaFRhcmdldCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodm0pIHtcclxuICAgICAgICAgICAgdmFyIGN1ciA9IHZtO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgcG9wVGFyZ2V0KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlciwgY29udGV4dCwgYXJncywgdm0sIGluZm8pIHtcclxuICAgIHZhciByZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xyXG4gICAgICAgICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcclxuICAgICAgICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbykge1xyXG4gICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcclxuICAgICAgICAgICAgaWYgKGUgIT09IGVycikge1xyXG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybiQyKFwiRXJyb3IgaW4gXCIuY29uY2F0KGluZm8sIFwiOiBcXFwiXCIpLmNvbmNhdChlcnIudG9TdHJpbmcoKSwgXCJcXFwiXCIpLCB2bSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xyXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xyXG52YXIgY2FsbGJhY2tzID0gW107XHJcbnZhciBwZW5kaW5nID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzKCkge1xyXG4gICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3BpZXNbaV0oKTtcclxuICAgIH1cclxufVxyXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXHJcbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXHJcbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XHJcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxyXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcclxuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXHJcbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cclxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXHJcbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxyXG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXHJcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxyXG52YXIgdGltZXJGdW5jO1xyXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxyXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cclxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXHJcbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XHJcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcclxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXHJcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcclxuICAgIHZhciBwXzEgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwXzEudGhlbihmbHVzaENhbGxiYWNrcyk7XHJcbiAgICAgICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XHJcbiAgICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXHJcbiAgICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcclxuICAgICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cclxuICAgICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cclxuICAgICAgICBpZiAoaXNJT1MpXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQobm9vcCk7XHJcbiAgICB9O1xyXG4gICAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XHJcbn1cclxuZWxzZSBpZiAoIWlzSUUgJiZcclxuICAgIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgKGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XHJcbiAgICAgICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XHJcbiAgICAgICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJykpIHtcclxuICAgIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXHJcbiAgICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcclxuICAgIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcclxuICAgIHZhciBjb3VudGVyXzEgPSAxO1xyXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xyXG4gICAgdmFyIHRleHROb2RlXzEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcl8xKSk7XHJcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlXzEsIHtcclxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb3VudGVyXzEgPSAoY291bnRlcl8xICsgMSkgJSAyO1xyXG4gICAgICAgIHRleHROb2RlXzEuZGF0YSA9IFN0cmluZyhjb3VudGVyXzEpO1xyXG4gICAgfTtcclxuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xyXG59XHJcbmVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcclxuICAgIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cclxuICAgIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxyXG4gICAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXHJcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcclxuICAgIH07XHJcbn1cclxuZWxzZSB7XHJcbiAgICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxyXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXh0VGljayhjYiwgY3R4KSB7XHJcbiAgICB2YXIgX3Jlc29sdmU7XHJcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoX3Jlc29sdmUpIHtcclxuICAgICAgICAgICAgX3Jlc29sdmUoY3R4KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmICghcGVuZGluZykge1xyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRpbWVyRnVuYygpO1xyXG4gICAgfVxyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lKSB7XHJcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJHN0eWxlJzsgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcInVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kID0gY3VycmVudEluc3RhbmNlW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIkN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiLlwiKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xyXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWZhbHNlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcInVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLlwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB3YXRjaFBvc3RFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IGluc3RhbmNlLiRlbDtcclxuICAgICAgICB2YXIgdmFycyA9IGdldHRlcihpbnN0YW5jZSwgaW5zdGFuY2UuX3NldHVwUHJveHkpO1xyXG4gICAgICAgIGlmIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhcnMpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFwiLS1cIi5jb25jYXQoa2V5KSwgdmFyc1trZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogdjMtY29tcGF0aWJsZSBhc3luYyBjb21wb25lbnQgQVBJLlxyXG4gKiBAaW50ZXJuYWwgdGhlIHR5cGUgaXMgbWFudWFsbHkgZGVjbGFyZWQgaW4gPHJvb3Q+L3R5cGVzL3YzLWRlZmluZS1hc3luYy1jb21wb25lbnQuZC50c1xyXG4gKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBleGlzdGluZyBtYW51YWwgdHlwZXNcclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcclxuICAgIH1cclxuICAgIHZhciBsb2FkZXIgPSBzb3VyY2UubG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50ID0gc291cmNlLmxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50ID0gc291cmNlLmVycm9yQ29tcG9uZW50LCBfYSA9IHNvdXJjZS5kZWxheSwgZGVsYXkgPSBfYSA9PT0gdm9pZCAwID8gMjAwIDogX2EsIHRpbWVvdXQgPSBzb3VyY2UudGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBfYiA9IHNvdXJjZS5zdXNwZW5zaWJsZSwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCAvLyBpbiBWdWUgMyBkZWZhdWx0IGlzIHRydWVcclxuICAgIHVzZXJPbkVycm9yID0gc291cmNlLm9uRXJyb3I7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdXNwZW5zaWJsZSkge1xyXG4gICAgICAgIHdhcm4kMihcIlRoZSBzdXNwZW5zaWJsZSBvcHRpb24gZm9yIGFzeW5jIGNvbXBvbmVudHMgaXMgbm90IHN1cHBvcnRlZCBpbiBWdWUyLiBJdCBpcyBpZ25vcmVkLlwiKTtcclxuICAgIH1cclxuICAgIHZhciBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICB2YXIgcmV0cmllcyA9IDA7XHJcbiAgICB2YXIgcmV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0cmllcysrO1xyXG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gbG9hZCgpO1xyXG4gICAgfTtcclxuICAgIHZhciBsb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGlzUmVxdWVzdDtcclxuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XHJcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID1cclxuICAgICAgICAgICAgICAgIGxvYWRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclJldHJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShyZXRyeSgpKTsgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyRmFpbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKFwiQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogXCIuY29uY2F0KGNvbXApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGxvYWQoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcclxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxyXG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JDb21wb25lbnQsXHJcbiAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmdDb21wb25lbnRcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlmZUN5Y2xlKGhvb2tOYW1lKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlOyB9XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiXCIuY29uY2F0KGZvcm1hdE5hbWUoaG9va05hbWUpLCBcIiBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhc3NvY2lhdGVkIHdpdGguIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIkxpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluamVjdEhvb2sodGFyZ2V0LCBob29rTmFtZSwgZm4pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmb3JtYXROYW1lKG5hbWUpIHtcclxuICAgIGlmIChuYW1lID09PSAnYmVmb3JlRGVzdHJveScpIHtcclxuICAgICAgICBuYW1lID0gJ2JlZm9yZVVubW91bnQnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2Rlc3Ryb3llZCcpIHtcclxuICAgICAgICBuYW1lID0gJ3VubW91bnRlZCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJvblwiLmNvbmNhdChuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcclxufVxyXG5mdW5jdGlvbiBpbmplY3RIb29rKGluc3RhbmNlLCBob29rTmFtZSwgZm4pIHtcclxuICAgIHZhciBvcHRpb25zID0gaW5zdGFuY2UuJG9wdGlvbnM7XHJcbiAgICBvcHRpb25zW2hvb2tOYW1lXSA9IG1lcmdlTGlmZWN5Y2xlSG9vayhvcHRpb25zW2hvb2tOYW1lXSwgZm4pO1xyXG59XHJcbnZhciBvbkJlZm9yZU1vdW50ID0gY3JlYXRlTGlmZUN5Y2xlKCdiZWZvcmVNb3VudCcpO1xyXG52YXIgb25Nb3VudGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdtb3VudGVkJyk7XHJcbnZhciBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUxpZmVDeWNsZSgnYmVmb3JlVXBkYXRlJyk7XHJcbnZhciBvblVwZGF0ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ3VwZGF0ZWQnKTtcclxudmFyIG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUxpZmVDeWNsZSgnYmVmb3JlRGVzdHJveScpO1xyXG52YXIgb25Vbm1vdW50ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2Rlc3Ryb3llZCcpO1xyXG52YXIgb25BY3RpdmF0ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2FjdGl2YXRlZCcpO1xyXG52YXIgb25EZWFjdGl2YXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnZGVhY3RpdmF0ZWQnKTtcclxudmFyIG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVMaWZlQ3ljbGUoJ3NlcnZlclByZWZldGNoJyk7XHJcbnZhciBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ3JlbmRlclRyYWNrZWQnKTtcclxudmFyIG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlTGlmZUN5Y2xlKCdyZW5kZXJUcmlnZ2VyZWQnKTtcclxudmFyIGluamVjdEVycm9yQ2FwdHVyZWRIb29rID0gY3JlYXRlTGlmZUN5Y2xlKCdlcnJvckNhcHR1cmVkJyk7XHJcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2U7IH1cclxuICAgIGluamVjdEVycm9yQ2FwdHVyZWRIb29rKGhvb2ssIHRhcmdldCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3RlOiBhbHNvIHVwZGF0ZSBkaXN0L3Z1ZS5ydW50aW1lLm1qcyB3aGVuIGFkZGluZyBuZXcgZXhwb3J0cyB0byB0aGlzIGZpbGUuXHJcbiAqL1xyXG52YXIgdmVyc2lvbiA9ICcyLjcuMTYnO1xyXG4vKipcclxuICogQGludGVybmFsIHR5cGUgaXMgbWFudWFsbHkgZGVjbGFyZWQgaW4gPHJvb3Q+L3R5cGVzL3YzLWRlZmluZS1jb21wb25lbnQuZC50c1xyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBvcHRpb25zO1xyXG59XHJcblxyXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcclxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcclxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCkge1xyXG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xyXG4gICAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gX3RyYXZlcnNlKHZhbCwgc2Vlbikge1xyXG4gICAgdmFyIGksIGtleXM7XHJcbiAgICB2YXIgaXNBID0gaXNBcnJheSh2YWwpO1xyXG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fFxyXG4gICAgICAgIHZhbC5fX3Zfc2tpcCAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8gfHxcclxuICAgICAgICBPYmplY3QuaXNGcm96ZW4odmFsKSB8fFxyXG4gICAgICAgIHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbC5fX29iX18pIHtcclxuICAgICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcclxuICAgICAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Vlbi5hZGQoZGVwSWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQSkge1xyXG4gICAgICAgIGkgPSB2YWwubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYodmFsKSkge1xyXG4gICAgICAgIF90cmF2ZXJzZSh2YWwudmFsdWUsIHNlZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XHJcbiAgICAgICAgaSA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgdWlkJDEgPSAwO1xyXG4vKipcclxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXHJcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBXYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMsIGlzUmVuZGVyV2F0Y2hlcikge1xyXG4gICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKHRoaXMsIFxyXG4gICAgICAgIC8vIGlmIHRoZSBhY3RpdmUgZWZmZWN0IHNjb3BlIGlzIG1hbnVhbGx5IGNyZWF0ZWQgKG5vdCBhIGNvbXBvbmVudCBzY29wZSksXHJcbiAgICAgICAgLy8gcHJpb3JpdGl6ZSBpdFxyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlICYmICFhY3RpdmVFZmZlY3RTY29wZS5fdm1cclxuICAgICAgICAgICAgPyBhY3RpdmVFZmZlY3RTY29wZVxyXG4gICAgICAgICAgICA6IHZtXHJcbiAgICAgICAgICAgICAgICA/IHZtLl9zY29wZVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmICgodGhpcy52bSA9IHZtKSAmJiBpc1JlbmRlcldhdGNoZXIpIHtcclxuICAgICAgICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XHJcbiAgICAgICAgICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xyXG4gICAgICAgICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcclxuICAgICAgICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XHJcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhY2sgPSBvcHRpb25zLm9uVHJhY2s7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJpZ2dlciA9IG9wdGlvbnMub25UcmlnZ2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYiA9IGNiO1xyXG4gICAgICAgIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucG9zdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXHJcbiAgICAgICAgdGhpcy5kZXBzID0gW107XHJcbiAgICAgICAgdGhpcy5uZXdEZXBzID0gW107XHJcbiAgICAgICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xyXG4gICAgICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gZXhwT3JGbi50b1N0cmluZygpIDogJyc7XHJcbiAgICAgICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZXhwT3JGbikpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiLmNvbmNhdChleHBPckZuLCBcIlxcXCIgXCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJywgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenkgPyB1bmRlZmluZWQgOiB0aGlzLmdldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwdXNoVGFyZ2V0KHRoaXMpO1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzLnZtO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51c2VyKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiLmNvbmNhdCh0aGlzLmV4cHJlc3Npb24sIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcclxuICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZXApIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3BUYXJnZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhbnVwRGVwcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XHJcbiAgICAgICAgdmFyIGlkID0gZGVwLmlkO1xyXG4gICAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xyXG4gICAgICAgICAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgICAgIGRlcC5hZGRTdWIodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmRlcElkcztcclxuICAgICAgICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xyXG4gICAgICAgIHRoaXMubmV3RGVwSWRzID0gdG1wO1xyXG4gICAgICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XHJcbiAgICAgICAgdG1wID0gdGhpcy5kZXBzO1xyXG4gICAgICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcclxuICAgICAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XHJcbiAgICAgICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cclxuICAgICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgIGlmICh0aGlzLmxhenkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3luYykge1xyXG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxyXG4gICAgICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUgfHxcclxuICAgICAgICAgICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxyXG4gICAgICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZXApIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldCBuZXcgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIi5jb25jYXQodGhpcy5leHByZXNzaW9uLCBcIlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXHJcbiAgICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52bSAmJiAhdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZW1vdmUkMih0aGlzLnZtLl9zY29wZS5lZmZlY3RzLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25TdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdhdGNoZXI7XHJcbn0oKSk7XHJcblxyXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogbm9vcCxcclxuICAgIHNldDogbm9vcFxyXG59O1xyXG5mdW5jdGlvbiBwcm94eSh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldO1xyXG4gICAgfTtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlcih2YWwpIHtcclxuICAgICAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0YXRlKHZtKSB7XHJcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xyXG4gICAgaWYgKG9wdHMucHJvcHMpXHJcbiAgICAgICAgaW5pdFByb3BzJDEodm0sIG9wdHMucHJvcHMpO1xyXG4gICAgLy8gQ29tcG9zaXRpb24gQVBJXHJcbiAgICBpbml0U2V0dXAodm0pO1xyXG4gICAgaWYgKG9wdHMubWV0aG9kcylcclxuICAgICAgICBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTtcclxuICAgIGlmIChvcHRzLmRhdGEpIHtcclxuICAgICAgICBpbml0RGF0YSh2bSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgb2IgPSBvYnNlcnZlKCh2bS5fZGF0YSA9IHt9KSk7XHJcbiAgICAgICAgb2IgJiYgb2Iudm1Db3VudCsrO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMuY29tcHV0ZWQpXHJcbiAgICAgICAgaW5pdENvbXB1dGVkJDEodm0sIG9wdHMuY29tcHV0ZWQpO1xyXG4gICAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcclxuICAgICAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluaXRQcm9wcyQxKHZtLCBwcm9wc09wdGlvbnMpIHtcclxuICAgIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XHJcbiAgICB2YXIgcHJvcHMgPSAodm0uX3Byb3BzID0gc2hhbGxvd1JlYWN0aXZlKHt9KSk7XHJcbiAgICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxyXG4gICAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXHJcbiAgICB2YXIga2V5cyA9ICh2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXSk7XHJcbiAgICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XHJcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICAgIGlmICghaXNSb290KSB7XHJcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcclxuICAgIH1cclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJcXFwiXCIuY29uY2F0KGh5cGhlbmF0ZWRLZXksIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCJcIiksIHZtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdHJ1ZSAvKiBzaGFsbG93ICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCB1bmRlZmluZWQsIHRydWUgLyogc2hhbGxvdyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcclxuICAgICAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxyXG4gICAgICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cclxuICAgICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XHJcbiAgICAgICAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgX2xvb3BfMShrZXkpO1xyXG4gICAgfVxyXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGluaXREYXRhKHZtKSB7XHJcbiAgICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XHJcbiAgICBkYXRhID0gdm0uX2RhdGEgPSBpc0Z1bmN0aW9uKGRhdGEpID8gZ2V0RGF0YShkYXRhLCB2bSkgOiBkYXRhIHx8IHt9O1xyXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgZGF0YSA9IHt9O1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybiQyKCdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcclxuICAgICAgICAgICAgICAgICdodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLCB2bSk7XHJcbiAgICB9XHJcbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xyXG4gICAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XHJcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJNZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIpICtcclxuICAgICAgICAgICAgICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIiwgdm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XHJcbiAgICAgICAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb2JzZXJ2ZSBkYXRhXHJcbiAgICB2YXIgb2IgPSBvYnNlcnZlKGRhdGEpO1xyXG4gICAgb2IgJiYgb2Iudm1Db3VudCsrO1xyXG59XHJcbmZ1bmN0aW9uIGdldERhdGEoZGF0YSwgdm0pIHtcclxuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcclxuICAgIHB1c2hUYXJnZXQoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgcG9wVGFyZ2V0KCk7XHJcbiAgICB9XHJcbn1cclxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcclxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEodm0sIGNvbXB1dGVkKSB7XHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIHZhciB3YXRjaGVycyA9ICh2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcclxuICAgIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcclxuICAgICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XHJcbiAgICAgICAgdmFyIGdldHRlciA9IGlzRnVuY3Rpb24odXNlckRlZikgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgd2FybiQyKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIuXCIpLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNTU1IpIHtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIgfHwgbm9vcCwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcclxuICAgICAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxyXG4gICAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cclxuICAgICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XHJcbiAgICAgICAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2bS4kb3B0aW9ucy5tZXRob2RzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5tZXRob2RzKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBtZXRob2QuXCIpLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcclxuICAgIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odXNlckRlZikpIHtcclxuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcclxuICAgICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXHJcbiAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcclxuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxyXG4gICAgICAgICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcclxuICAgICAgICAgICAgOiBub29wO1xyXG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xyXG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xyXG4gICAgICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIERlcC50YXJnZXQub25UcmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogRGVwLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xyXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0TWV0aG9kcyh2bSwgbWV0aG9kcykge1xyXG4gICAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJNZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIpLmNvbmNhdCh0eXBlb2YgbWV0aG9kc1trZXldLCBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIiwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIk1ldGhvZCBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleSBpbiB2bSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIk1ldGhvZCBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kJDEobWV0aG9kc1trZXldLCB2bSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5pdFdhdGNoKHZtLCB3YXRjaCkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xyXG4gICAgICAgIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcclxuICAgICAgICBvcHRpb25zID0gaGFuZGxlcjtcclxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gc3RhdGVNaXhpbihWdWUpIHtcclxuICAgIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxyXG4gICAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXHJcbiAgICAvLyB0aGUgb2JqZWN0IGhlcmUuXHJcbiAgICB2YXIgZGF0YURlZiA9IHt9O1xyXG4gICAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9O1xyXG4gICAgdmFyIHByb3BzRGVmID0ge307XHJcbiAgICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xyXG4gICAgfTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMignQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xyXG4gICAgICAgICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJywgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xyXG4gICAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xyXG4gICAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xyXG4gICAgICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGluZm8gPSBcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIuY29uY2F0KHdhdGNoZXIuZXhwcmVzc2lvbiwgXCJcXFwiXCIpO1xyXG4gICAgICAgICAgICBwdXNoVGFyZ2V0KCk7XHJcbiAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNiLCB2bSwgW3dhdGNoZXIudmFsdWVdLCB2bSwgaW5mbyk7XHJcbiAgICAgICAgICAgIHBvcFRhcmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuKCkge1xyXG4gICAgICAgICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRQcm92aWRlKHZtKSB7XHJcbiAgICB2YXIgcHJvdmlkZU9wdGlvbiA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbikge1xyXG4gICAgICAgIHZhciBwcm92aWRlZCA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbilcclxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9uLmNhbGwodm0pXHJcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbjtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3ZpZGVkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSByZXNvbHZlUHJvdmlkZWQodm0pO1xyXG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgc28gd2UgaGF2ZSB0b1xyXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIGtleXMgb3Vyc2VsdmVzLlxyXG4gICAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVkKSA6IE9iamVjdC5rZXlzKHByb3ZpZGVkKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm92aWRlZCwga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zKHZtKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcclxuICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiXCIpLCB2bSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0KGluamVjdCwgdm0pIHtcclxuICAgIGlmIChpbmplY3QpIHtcclxuICAgICAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxyXG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgLy8gIzY1NzQgaW4gY2FzZSB0aGUgaW5qZWN0IG9iamVjdCBpcyBvYnNlcnZlZC4uLlxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XHJcbiAgICAgICAgICAgIGlmIChwcm92aWRlS2V5IGluIHZtLl9wcm92aWRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2bS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpc0Z1bmN0aW9uKHByb3ZpZGVEZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcclxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIkluamVjdGlvbiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB1aWQgPSAwO1xyXG5mdW5jdGlvbiBpbml0TWl4aW4kMShWdWUpIHtcclxuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgLy8gYSB1aWRcclxuICAgICAgICB2bS5fdWlkID0gdWlkKys7XHJcbiAgICAgICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiLmNvbmNhdCh2bS5fdWlkKTtcclxuICAgICAgICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIuY29uY2F0KHZtLl91aWQpO1xyXG4gICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYSBmbGFnIHRvIG1hcmsgdGhpcyBhcyBhIFZ1ZSBpbnN0YW5jZSB3aXRob3V0IGhhdmluZyB0byBkbyBpbnN0YW5jZW9mXHJcbiAgICAgICAgLy8gY2hlY2tcclxuICAgICAgICB2bS5faXNWdWUgPSB0cnVlO1xyXG4gICAgICAgIC8vIGF2b2lkIGluc3RhbmNlcyBmcm9tIGJlaW5nIG9ic2VydmVkXHJcbiAgICAgICAgdm0uX192X3NraXAgPSB0cnVlO1xyXG4gICAgICAgIC8vIGVmZmVjdCBzY29wZVxyXG4gICAgICAgIHZtLl9zY29wZSA9IG5ldyBFZmZlY3RTY29wZSh0cnVlIC8qIGRldGFjaGVkICovKTtcclxuICAgICAgICAvLyAjMTMxMzQgZWRnZSBjYXNlIHdoZXJlIGEgY2hpbGQgY29tcG9uZW50IGlzIG1hbnVhbGx5IGNyZWF0ZWQgZHVyaW5nIHRoZVxyXG4gICAgICAgIC8vIHJlbmRlciBvZiBhIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICB2bS5fc2NvcGUucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZtLl9zY29wZS5fdm0gPSB0cnVlO1xyXG4gICAgICAgIC8vIG1lcmdlIG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxyXG4gICAgICAgICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXHJcbiAgICAgICAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxyXG4gICAgICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMocmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksIG9wdGlvbnMgfHwge30sIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpbml0UHJveHkodm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcclxuICAgICAgICB2bS5fc2VsZiA9IHZtO1xyXG4gICAgICAgIGluaXRMaWZlY3ljbGUodm0pO1xyXG4gICAgICAgIGluaXRFdmVudHModm0pO1xyXG4gICAgICAgIGluaXRSZW5kZXIodm0pO1xyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVDcmVhdGUnLCB1bmRlZmluZWQsIGZhbHNlIC8qIHNldENvbnRleHQgKi8pO1xyXG4gICAgICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXHJcbiAgICAgICAgaW5pdFN0YXRlKHZtKTtcclxuICAgICAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXHJcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcclxuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdCh2bS5fbmFtZSwgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xyXG4gICAgICAgICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgb3B0cyA9ICh2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucykpO1xyXG4gICAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cclxuICAgIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xyXG4gICAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcclxuICAgIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XHJcbiAgICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcclxuICAgIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XHJcbiAgICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcclxuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XHJcbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcclxuICAgICAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xyXG4gICAgICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcclxuICAgIGlmIChDdG9yLnN1cGVyKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XHJcbiAgICAgICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xyXG4gICAgICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xyXG4gICAgICAgICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxyXG4gICAgICAgICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKSB7XHJcbiAgICB2YXIgbW9kaWZpZWQ7XHJcbiAgICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xyXG4gICAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcclxuICAgIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcclxuICAgICAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XHJcbiAgICAgICAgICAgIGlmICghbW9kaWZpZWQpXHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHt9O1xyXG4gICAgICAgICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vZGlmaWVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChkYXRhLCBwcm9wcywgY2hpbGRyZW4sIHBhcmVudCwgQ3Rvcikge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gICAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xyXG4gICAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xyXG4gICAgdmFyIGNvbnRleHRWbTtcclxuICAgIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XHJcbiAgICAgICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xyXG4gICAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cclxuICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcclxuICAgICAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXHJcbiAgICAgICAgY29udGV4dFZtID0gcGFyZW50O1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xyXG4gICAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XHJcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xyXG4gICAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIV90aGlzLiRzbG90cykge1xyXG4gICAgICAgICAgICBub3JtYWxpemVTY29wZWRTbG90cyhwYXJlbnQsIGRhdGEuc2NvcGVkU2xvdHMsIChfdGhpcy4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLiRzbG90cztcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhwYXJlbnQsIGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXHJcbiAgICBpZiAoaXNDb21waWxlZCkge1xyXG4gICAgICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxyXG4gICAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcclxuICAgICAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcclxuICAgICAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcclxuICAgICAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudCQxKGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAodm5vZGUgJiYgIWlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50JDEoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dFZtLCBjaGlsZHJlbikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XHJcbiAgICB2YXIgcHJvcHMgPSB7fTtcclxuICAgIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XHJcbiAgICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpXHJcbiAgICAgICAgICAgIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSlcclxuICAgICAgICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChkYXRhLCBwcm9wcywgY2hpbGRyZW4sIGNvbnRleHRWbSwgQ3Rvcik7XHJcbiAgICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xyXG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2bm9kZSkpIHtcclxuICAgICAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xyXG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcclxuICAgIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXHJcbiAgICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcclxuICAgIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxyXG4gICAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XHJcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID1cclxuICAgICAgICAgICAgcmVuZGVyQ29udGV4dDtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLnNsb3QpIHtcclxuICAgICAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fX25hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xyXG59XHJcbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXHJcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xyXG4gICAgaW5pdDogZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcclxuICAgICAgICBpZiAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcclxuICAgICAgICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxyXG4gICAgICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xyXG4gICAgICAgICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcclxuICAgICAgICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcclxuICAgICAgICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gKHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSh2bm9kZSwgYWN0aXZlSW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcHJlcGF0Y2g6IGZ1bmN0aW9uIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gKHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2UpO1xyXG4gICAgICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KGNoaWxkLCBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xyXG4gICAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xyXG4gICAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXHJcbiAgICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cclxuICAgICAgICApO1xyXG4gICAgfSxcclxuICAgIGluc2VydDogZnVuY3Rpb24gKHZub2RlKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0LCBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2FsbEhvb2skMShjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxyXG4gICAgICAgICAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxyXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXHJcbiAgICAgICAgICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXHJcbiAgICAgICAgICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKHZub2RlKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKSB7XHJcbiAgICBpZiAoaXNVbmRlZihDdG9yKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XHJcbiAgICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcclxuICAgIGlmIChpc09iamVjdChDdG9yKSkge1xyXG4gICAgICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XHJcbiAgICB9XHJcbiAgICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXHJcbiAgICAvLyByZWplY3QuXHJcbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIi5jb25jYXQoU3RyaW5nKEN0b3IpKSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGFzeW5jIGNvbXBvbmVudFxyXG4gICAgdmFyIGFzeW5jRmFjdG9yeTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xyXG4gICAgICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XHJcbiAgICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcclxuICAgICAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcclxuICAgICAgICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXHJcbiAgICAgICAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoYXN5bmNGYWN0b3J5LCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcclxuICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcclxuICAgIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxyXG4gICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcclxuICAgIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcclxuICAgIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gZXh0cmFjdCBwcm9wc1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcclxuICAgIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcclxuICAgIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcclxuICAgIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXHJcbiAgICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cclxuICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XHJcbiAgICAgICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xyXG4gICAgICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XHJcbiAgICAgICAgLy8gd29yayBhcm91bmQgZmxvd1xyXG4gICAgICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xyXG4gICAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgICBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICBkYXRhLnNsb3QgPSBzbG90O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxyXG4gICAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xyXG4gICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDdG9yLm9wdGlvbnMpIHx8IHRhZztcclxuICAgIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIFwidnVlLWNvbXBvbmVudC1cIi5jb25jYXQoQ3Rvci5jaWQpLmNvbmNhdChuYW1lID8gXCItXCIuY29uY2F0KG5hbWUpIDogJycpLCBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LCBcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sIGFzeW5jRmFjdG9yeSk7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcclxuLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XHJcbnZub2RlLCBcclxuLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXHJcbnBhcmVudCkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxyXG4gICAgICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXHJcbiAgICAgICAgcGFyZW50OiBwYXJlbnRcclxuICAgIH07XHJcbiAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcclxuICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcclxuICAgICAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcclxuICAgICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKSB7XHJcbiAgICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcclxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xyXG4gICAgICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xyXG4gICAgICAgICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2sodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VIb29rKGYxLCBmMikge1xyXG4gICAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxyXG4gICAgICAgIGYxKGEsIGIpO1xyXG4gICAgICAgIGYyKGEsIGIpO1xyXG4gICAgfTtcclxuICAgIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcclxuICAgIHJldHVybiBtZXJnZWQ7XHJcbn1cclxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xyXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwob3B0aW9ucywgZGF0YSkge1xyXG4gICAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XHJcbiAgICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnO1xyXG4gICAgKGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcclxuICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XHJcbiAgICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XHJcbiAgICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xyXG4gICAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGV4aXN0aW5nKVxyXG4gICAgICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxyXG4gICAgICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB3YXJuJDIgPSBub29wO1xyXG52YXIgdGlwID0gbm9vcDtcclxudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2U7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcclxudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgaGFzQ29uc29sZV8xID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgdmFyIGNsYXNzaWZ5UkVfMSA9IC8oPzpefFstX10pKFxcdykvZztcclxuICAgIHZhciBjbGFzc2lmeV8xID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFXzEsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG4gICAgfTtcclxuICAgIHdhcm4kMiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XHJcbiAgICAgICAgaWYgKHZtID09PSB2b2lkIDApIHsgdm0gPSBjdXJyZW50SW5zdGFuY2U7IH1cclxuICAgICAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XHJcbiAgICAgICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xyXG4gICAgICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc0NvbnNvbGVfMSAmJiAhY29uZmlnLnNpbGVudCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1Z1ZSB3YXJuXTogXCIuY29uY2F0KG1zZykuY29uY2F0KHRyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XHJcbiAgICAgICAgaWYgKGhhc0NvbnNvbGVfMSAmJiAhY29uZmlnLnNpbGVudCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiLmNvbmNhdChtc2cpICsgKHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xyXG4gICAgICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8Um9vdD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGlzRnVuY3Rpb24odm0pICYmIHZtLmNpZCAhPSBudWxsXHJcbiAgICAgICAgICAgID8gdm0ub3B0aW9uc1xyXG4gICAgICAgICAgICA6IHZtLl9pc1Z1ZVxyXG4gICAgICAgICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXHJcbiAgICAgICAgICAgICAgICA6IHZtO1xyXG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShvcHRpb25zKTtcclxuICAgICAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xyXG4gICAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xyXG4gICAgICAgICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKG5hbWUgPyBcIjxcIi5jb25jYXQoY2xhc3NpZnlfMShuYW1lKSwgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXHJcbiAgICAgICAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IFwiIGF0IFwiLmNvbmNhdChmaWxlKSA6ICcnKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlcGVhdF8xID0gZnVuY3Rpb24gKHN0ciwgbikge1xyXG4gICAgICAgIHZhciByZXMgPSAnJztcclxuICAgICAgICB3aGlsZSAobikge1xyXG4gICAgICAgICAgICBpZiAobiAlIDIgPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXMgKz0gc3RyO1xyXG4gICAgICAgICAgICBpZiAobiA+IDEpXHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gc3RyO1xyXG4gICAgICAgICAgICBuID4+PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcclxuICAgICAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHRyZWUgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICh2bSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmVlLnB1c2godm0pO1xyXG4gICAgICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArXHJcbiAgICAgICAgICAgICAgICB0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXRfMSgnICcsIDUgKyBpICogMikpLmNvbmNhdChpc0FycmF5KHZtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiXCIuY29uY2F0KGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pLCBcIi4uLiAoXCIpLmNvbmNhdCh2bVsxXSwgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcblxcbihmb3VuZCBpbiBcIi5jb25jYXQoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSksIFwiKVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxyXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxyXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cclxuICovXHJcbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG4vKipcclxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xyXG4gKi9cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xyXG4gICAgICAgIGlmICghdm0pIHtcclxuICAgICAgICAgICAgd2FybiQyKFwib3B0aW9uIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIpICtcclxuICAgICAgICAgICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURhdGEodG8sIGZyb20sIHJlY3Vyc2l2ZSkge1xyXG4gICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2l2ZSA9IHRydWU7IH1cclxuICAgIGlmICghZnJvbSlcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcclxuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXHJcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcclxuICAgICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxyXG4gICAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB0b1ZhbCA9IHRvW2tleV07XHJcbiAgICAgICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcclxuICAgICAgICBpZiAoIXJlY3Vyc2l2ZSB8fCAhaGFzT3duKHRvLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG9WYWwgIT09IGZyb21WYWwgJiZcclxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcclxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xyXG4gICAgICAgICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0bztcclxufVxyXG4vKipcclxuICogRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xyXG4gICAgaWYgKCF2bSkge1xyXG4gICAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXHJcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcmVudFZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcclxuICAgICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cclxuICAgICAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcclxuICAgICAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGlzRnVuY3Rpb24oY2hpbGRWYWwpID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLCBpc0Z1bmN0aW9uKHBhcmVudFZhbCkgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcclxuICAgICAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IGlzRnVuY3Rpb24oY2hpbGRWYWwpXHJcbiAgICAgICAgICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxyXG4gICAgICAgICAgICAgICAgOiBjaGlsZFZhbDtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gaXNGdW5jdGlvbihwYXJlbnRWYWwpXHJcbiAgICAgICAgICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcclxuICAgICAgICAgICAgICAgIDogcGFyZW50VmFsO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xyXG4gICAgaWYgKCF2bSkge1xyXG4gICAgICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbml0aW9ucy4nLCB2bSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xyXG59O1xyXG4vKipcclxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VMaWZlY3ljbGVIb29rKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcclxuICAgIHZhciByZXMgPSBjaGlsZFZhbFxyXG4gICAgICAgID8gcGFyZW50VmFsXHJcbiAgICAgICAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcclxuICAgICAgICAgICAgOiBpc0FycmF5KGNoaWxkVmFsKVxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZFZhbFxyXG4gICAgICAgICAgICAgICAgOiBbY2hpbGRWYWxdXHJcbiAgICAgICAgOiBwYXJlbnRWYWw7XHJcbiAgICByZXR1cm4gcmVzID8gZGVkdXBlSG9va3MocmVzKSA6IHJlcztcclxufVxyXG5mdW5jdGlvbiBkZWR1cGVIb29rcyhob29rcykge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUxpZmVjeWNsZUhvb2s7XHJcbn0pO1xyXG4vKipcclxuICogQXNzZXRzXHJcbiAqXHJcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cclxuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxyXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcclxuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICAgIGlmIChjaGlsZFZhbCkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cclxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XHJcbn0pO1xyXG4vKipcclxuICogV2F0Y2hlcnMuXHJcbiAqXHJcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcclxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXHJcbiAqL1xyXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xyXG4gICAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cclxuICAgIC8vQHRzLWV4cGVjdC1lcnJvciB3b3JrIGFyb3VuZFxyXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpXHJcbiAgICAgICAgcGFyZW50VmFsID0gdW5kZWZpbmVkO1xyXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yIHdvcmsgYXJvdW5kXHJcbiAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKVxyXG4gICAgICAgIGNoaWxkVmFsID0gdW5kZWZpbmVkO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNoaWxkVmFsKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmVudFZhbClcclxuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XHJcbiAgICB2YXIgcmV0ID0ge307XHJcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gICAgZm9yICh2YXIga2V5XzEgaW4gY2hpbGRWYWwpIHtcclxuICAgICAgICB2YXIgcGFyZW50XzEgPSByZXRba2V5XzFdO1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV8xXTtcclxuICAgICAgICBpZiAocGFyZW50XzEgJiYgIWlzQXJyYXkocGFyZW50XzEpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudF8xID0gW3BhcmVudF8xXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0W2tleV8xXSA9IHBhcmVudF8xID8gcGFyZW50XzEuY29uY2F0KGNoaWxkKSA6IGlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufTtcclxuLyoqXHJcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXHJcbiAqL1xyXG5zdHJhdHMucHJvcHMgPVxyXG4gICAgc3RyYXRzLm1ldGhvZHMgPVxyXG4gICAgICAgIHN0cmF0cy5pbmplY3QgPVxyXG4gICAgICAgICAgICBzdHJhdHMuY29tcHV0ZWQgPVxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5zdHJhdHMucHJvdmlkZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgICBpZiAoIXBhcmVudFZhbClcclxuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIG1lcmdlRGF0YShyZXQsIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsKTtcclxuICAgICAgICBpZiAoY2hpbGRWYWwpIHtcclxuICAgICAgICAgICAgbWVyZ2VEYXRhKHJldCwgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsIGZhbHNlIC8vIG5vbi1yZWN1cnNpdmVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcbn07XHJcbi8qKlxyXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxyXG4gKi9cclxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZCA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMob3B0aW9ucykge1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xyXG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKSB7XHJcbiAgICBpZiAoIW5ldyBSZWdFeHAoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIi5jb25jYXQodW5pY29kZVJlZ0V4cC5zb3VyY2UsIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgd2FybiQyKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgK1xyXG4gICAgICAgICAgICBuYW1lICtcclxuICAgICAgICAgICAgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXHJcbiAgICAgICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybiQyKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xyXG4gICAgICAgICAgICAnaWQ6ICcgK1xyXG4gICAgICAgICAgICBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXHJcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhvcHRpb25zLCB2bSkge1xyXG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcclxuICAgIGlmICghcHJvcHMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgdmFyIGksIHZhbCwgbmFtZTtcclxuICAgIGlmIChpc0FycmF5KHByb3BzKSkge1xyXG4gICAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB2YWwgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcclxuICAgICAgICAgICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgdmFsID0gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHsgdHlwZTogdmFsIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4kMihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcclxuICAgICAgICAgICAgXCJidXQgZ290IFwiLmNvbmNhdCh0b1Jhd1R5cGUocHJvcHMpLCBcIi5cIiksIHZtKTtcclxuICAgIH1cclxuICAgIG9wdGlvbnMucHJvcHMgPSByZXM7XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChvcHRpb25zLCB2bSkge1xyXG4gICAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xyXG4gICAgaWYgKCFpbmplY3QpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIG5vcm1hbGl6ZWQgPSAob3B0aW9ucy5pbmplY3QgPSB7fSk7XHJcbiAgICBpZiAoaXNBcnJheShpbmplY3QpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXHJcbiAgICAgICAgICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXHJcbiAgICAgICAgICAgICAgICA6IHsgZnJvbTogdmFsIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4kMihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXHJcbiAgICAgICAgICAgIFwiYnV0IGdvdCBcIi5jb25jYXQodG9SYXdUeXBlKGluamVjdCksIFwiLlwiKSwgdm0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9wdGlvbnMpIHtcclxuICAgIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xyXG4gICAgaWYgKGRpcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xyXG4gICAgICAgICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlKG5hbWUsIHZhbHVlLCB2bSkge1xyXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHdhcm4kMihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIikgK1xyXG4gICAgICAgICAgICBcImJ1dCBnb3QgXCIuY29uY2F0KHRvUmF3VHlwZSh2YWx1ZSksIFwiLlwiKSwgdm0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXHJcbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xyXG4gICAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XHJcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzJDEoY2hpbGQpO1xyXG4gICAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxyXG4gICAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxyXG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxyXG4gICAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxyXG4gICAgaWYgKCFjaGlsZC5fYmFzZSkge1xyXG4gICAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkLm1peGlucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgIHZhciBrZXk7XHJcbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcclxuICAgICAgICBtZXJnZUZpZWxkKGtleSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xyXG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xyXG4gICAgICAgICAgICBtZXJnZUZpZWxkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcclxuICAgICAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XHJcbiAgICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmUgYW4gYXNzZXQuXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xyXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XHJcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxyXG4gICAgaWYgKGhhc093bihhc3NldHMsIGlkKSlcclxuICAgICAgICByZXR1cm4gYXNzZXRzW2lkXTtcclxuICAgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcclxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpXHJcbiAgICAgICAgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF07XHJcbiAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XHJcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSlcclxuICAgICAgICByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF07XHJcbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cclxuICAgIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgd2FybiQyKCdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pIHtcclxuICAgIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcclxuICAgIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcclxuICAgIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xyXG4gICAgLy8gYm9vbGVhbiBjYXN0aW5nXHJcbiAgICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XHJcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcclxuICAgICAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxyXG4gICAgICAgICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcclxuICAgICAgICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XHJcbiAgICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxyXG4gICAgICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XHJcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG4gICAgICAgIG9ic2VydmUodmFsdWUpO1xyXG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpIHtcclxuICAgIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcclxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcclxuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcclxuICAgICAgICB3YXJuJDIoJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgK1xyXG4gICAgICAgICAgICBrZXkgK1xyXG4gICAgICAgICAgICAnXCI6ICcgK1xyXG4gICAgICAgICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXHJcbiAgICAgICAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJywgdm0pO1xyXG4gICAgfVxyXG4gICAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcclxuICAgIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxyXG4gICAgaWYgKHZtICYmXHJcbiAgICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXHJcbiAgICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdm0uX3Byb3BzW2tleV07XHJcbiAgICB9XHJcbiAgICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xyXG4gICAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oZGVmKSAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcclxuICAgICAgICA/IGRlZi5jYWxsKHZtKVxyXG4gICAgICAgIDogZGVmO1xyXG59XHJcbi8qKlxyXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIG5hbWUsIHZhbHVlLCB2bSwgYWJzZW50KSB7XHJcbiAgICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcclxuICAgICAgICB3YXJuJDIoJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsIHZtKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xyXG4gICAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcclxuICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XHJcbiAgICBpZiAodHlwZSkge1xyXG4gICAgICAgIGlmICghaXNBcnJheSh0eXBlKSkge1xyXG4gICAgICAgICAgICB0eXBlID0gW3R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldLCB2bSk7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGhhdmVFeHBlY3RlZFR5cGVzID0gZXhwZWN0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9KTtcclxuICAgIGlmICghdmFsaWQgJiYgaGF2ZUV4cGVjdGVkVHlwZXMpIHtcclxuICAgICAgICB3YXJuJDIoZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSwgdm0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcclxuICAgIGlmICh2YWxpZGF0b3IpIHtcclxuICAgICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgd2FybiQyKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJywgdm0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2x8QmlnSW50KSQvO1xyXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlLCB2bSkge1xyXG4gICAgdmFyIHZhbGlkO1xyXG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcclxuICAgICAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcclxuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXHJcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgd2FybiQyKCdJbnZhbGlkIHByb3AgdHlwZTogXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yJywgdm0pO1xyXG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQ6IHZhbGlkLFxyXG4gICAgICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXHJcbiAgICB9O1xyXG59XHJcbnZhciBmdW5jdGlvblR5cGVDaGVja1JFID0gL15cXHMqZnVuY3Rpb24gKFxcdyspLztcclxuLyoqXHJcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcclxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXHJcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cclxuICovXHJcbmZ1bmN0aW9uIGdldFR5cGUoZm4pIHtcclxuICAgIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goZnVuY3Rpb25UeXBlQ2hlY2tSRSk7XHJcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xyXG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGlmICghaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIi5cIikgK1xyXG4gICAgICAgIFwiIEV4cGVjdGVkIFwiLmNvbmNhdChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKTtcclxuICAgIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xyXG4gICAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXHJcbiAgICAgICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcclxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIi5jb25jYXQoc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKSk7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlICs9IFwiLCBnb3QgXCIuY29uY2F0KHJlY2VpdmVkVHlwZSwgXCIgXCIpO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXHJcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIi5jb25jYXQoc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKSwgXCIuXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbn1cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoTnVtYmVyKHZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbnZhciBFWFBMSUNBQkxFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcclxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gRVhQTElDQUJMRV9UWVBFUy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KTtcclxufVxyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFZ1ZShvcHRpb25zKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpKSB7XHJcbiAgICAgICAgd2FybiQyKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xyXG59XHJcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcclxuaW5pdE1peGluJDEoVnVlKTtcclxuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxyXG5zdGF0ZU1peGluKFZ1ZSk7XHJcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcclxuZXZlbnRzTWl4aW4oVnVlKTtcclxuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxyXG5saWZlY3ljbGVNaXhpbihWdWUpO1xyXG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXHJcbnJlbmRlck1peGluKFZ1ZSk7XHJcblxyXG5mdW5jdGlvbiBpbml0VXNlKFZ1ZSkge1xyXG4gICAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcclxuICAgICAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9IHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSk7XHJcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xyXG4gICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcclxuICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0TWl4aW4oVnVlKSB7XHJcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0RXh0ZW5kKFZ1ZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcclxuICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcclxuICAgICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxyXG4gICAgICovXHJcbiAgICBWdWUuY2lkID0gMDtcclxuICAgIHZhciBjaWQgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyBpbmhlcml0YW5jZVxyXG4gICAgICovXHJcbiAgICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgU3VwZXIgPSB0aGlzO1xyXG4gICAgICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xyXG4gICAgICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XHJcbiAgICAgICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGV4dGVuZE9wdGlvbnMpIHx8IGdldENvbXBvbmVudE5hbWUoU3VwZXIub3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcclxuICAgICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xyXG4gICAgICAgIFN1Yi5jaWQgPSBjaWQrKztcclxuICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcclxuICAgICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcclxuICAgICAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxyXG4gICAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXHJcbiAgICAgICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxyXG4gICAgICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xyXG4gICAgICAgICAgICBpbml0UHJvcHMoU3ViKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIGluaXRDb21wdXRlZChTdWIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcclxuICAgICAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xyXG4gICAgICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xyXG4gICAgICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XHJcbiAgICAgICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xyXG4gICAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cclxuICAgICAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcclxuICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxyXG4gICAgICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXHJcbiAgICAgICAgLy8gYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xyXG4gICAgICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcclxuICAgICAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xyXG4gICAgICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XHJcbiAgICAgICAgcmV0dXJuIFN1YjtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdFByb3BzKENvbXApIHtcclxuICAgIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluaXRDb21wdXRlZChDb21wKSB7XHJcbiAgICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcclxuICAgICAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXHJcbiAgICAgKi9cclxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIG5vdCBleGFjdCBzYW1lIHR5cGVcclxuICAgICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIGlzRnVuY3Rpb24oZGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRDb21wb25lbnROYW1lKG9wdHMpIHtcclxuICAgIHJldHVybiBvcHRzICYmIChnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyk7XHJcbn1cclxuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBwcnVuZUNhY2hlKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcclxuICAgIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlLCBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cywgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlLCAkdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS4kdm5vZGU7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xyXG4gICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gZW50cnkubmFtZTtcclxuICAgICAgICAgICAgaWYgKG5hbWVfMSAmJiAhZmlsdGVyKG5hbWVfMSkpIHtcclxuICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgJHZub2RlLmNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4gPSB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIGN1cnJlbnQpIHtcclxuICAgIHZhciBlbnRyeSA9IGNhY2hlW2tleV07XHJcbiAgICBpZiAoZW50cnkgJiYgKCFjdXJyZW50IHx8IGVudHJ5LnRhZyAhPT0gY3VycmVudC50YWcpKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYW4gYmUgdW5kZWZpbmVkXHJcbiAgICAgICAgZW50cnkuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIGNhY2hlW2tleV0gPSBudWxsO1xyXG4gICAgcmVtb3ZlJDIoa2V5cywga2V5KTtcclxufVxyXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XHJcbi8vIFRPRE8gZGVmaW5lQ29tcG9uZW50XHJcbnZhciBLZWVwQWxpdmUgPSB7XHJcbiAgICBuYW1lOiAna2VlcC1hbGl2ZScsXHJcbiAgICBhYnN0cmFjdDogdHJ1ZSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxyXG4gICAgICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcclxuICAgICAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgY2FjaGVWTm9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBjYWNoZSA9IF9hLmNhY2hlLCBrZXlzID0gX2Eua2V5cywgdm5vZGVUb0NhY2hlID0gX2Eudm5vZGVUb0NhY2hlLCBrZXlUb0NhY2hlID0gX2Eua2V5VG9DYWNoZTtcclxuICAgICAgICAgICAgaWYgKHZub2RlVG9DYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHZub2RlVG9DYWNoZS50YWcsIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudEluc3RhbmNlLCBjb21wb25lbnRPcHRpb25zID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBjYWNoZVtrZXlUb0NhY2hlXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBfZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKSxcclxuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZTogY29tcG9uZW50SW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5VG9DYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBbXTtcclxuICAgIH0sXHJcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xyXG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNhY2hlVk5vZGUoKTtcclxuICAgICAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgcHJ1bmVDYWNoZShfdGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHBydW5lQ2FjaGUoX3RoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZVZOb2RlKCk7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xyXG4gICAgICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhdHRlcm5cclxuICAgICAgICAgICAgdmFyIG5hbWVfMiA9IF9nZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBpbmNsdWRlID0gX2EuaW5jbHVkZSwgZXhjbHVkZSA9IF9hLmV4Y2x1ZGU7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gbm90IGluY2x1ZGVkXHJcbiAgICAgICAgICAgIChpbmNsdWRlICYmICghbmFtZV8yIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWVfMikpKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gZXhjbHVkZWRcclxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWVfMiAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWVfMikpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF9iID0gdGhpcywgY2FjaGUgPSBfYi5jYWNoZSwga2V5cyA9IF9iLmtleXM7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gXCI6OlwiLmNvbmNhdChjb21wb25lbnRPcHRpb25zLnRhZykgOiAnJylcclxuICAgICAgICAgICAgICAgIDogdm5vZGUua2V5O1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlJDIoa2V5cywga2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsYXkgc2V0dGluZyB0aGUgY2FjaGUgdW50aWwgdXBkYXRlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlUb0NhY2hlID0ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2FuIHZub2RlLmRhdGEgY2FuIGJlIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcclxuICAgIEtlZXBBbGl2ZTogS2VlcEFsaXZlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJKFZ1ZSkge1xyXG4gICAgLy8gY29uZmlnXHJcbiAgICB2YXIgY29uZmlnRGVmID0ge307XHJcbiAgICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xyXG4gICAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXHJcbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cclxuICAgIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXHJcbiAgICBWdWUudXRpbCA9IHtcclxuICAgICAgICB3YXJuOiB3YXJuJDIsXHJcbiAgICAgICAgZXh0ZW5kOiBleHRlbmQsXHJcbiAgICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXHJcbiAgICB9O1xyXG4gICAgVnVlLnNldCA9IHNldDtcclxuICAgIFZ1ZS5kZWxldGUgPSBkZWw7XHJcbiAgICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcclxuICAgIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxyXG4gICAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgb2JzZXJ2ZShvYmopO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIH0pO1xyXG4gICAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxyXG4gICAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXHJcbiAgICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcclxuICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XHJcbiAgICBpbml0VXNlKFZ1ZSk7XHJcbiAgICBpbml0TWl4aW4oVnVlKTtcclxuICAgIGluaXRFeHRlbmQoVnVlKTtcclxuICAgIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xyXG59XHJcblxyXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xyXG4gICAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQ7XHJcbiAgICB9XHJcbn0pO1xyXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xyXG4gICAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XHJcbn0pO1xyXG5WdWUudmVyc2lvbiA9IHZlcnNpb247XHJcblxyXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcclxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXHJcbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XHJcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcclxudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xyXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XHJcbiAgICByZXR1cm4gKChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykgJiYgdHlwZSAhPT0gJ2J1dHRvbicpIHx8XHJcbiAgICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcclxuICAgICAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcclxuICAgICAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpKTtcclxufTtcclxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcclxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcclxudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXHJcbiAgICAgICAgPyAnZmFsc2UnXHJcbiAgICAgICAgOiAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcclxuICAgICAgICAgICAga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IHZhbHVlXHJcbiAgICAgICAgICAgICAgICA6ICd0cnVlJztcclxufTtcclxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKCdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xyXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcclxuICAgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xyXG4gICAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXHJcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLCcgK1xyXG4gICAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnKTtcclxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluayc7XHJcbn07XHJcbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnO1xyXG59O1xyXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSkge1xyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcclxuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICAgIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwYXJlbnROb2RlLnBhcmVudCBub3QgVk5vZGVXaXRoRGF0YVxyXG4gICAgd2hpbGUgKGlzRGVmKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSkge1xyXG4gICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcyk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEoY2hpbGQsIHBhcmVudCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxyXG4gICAgICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcykgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc10gOiBwYXJlbnQuY2xhc3NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyQ2xhc3Moc3RhdGljQ2xhc3MsIGR5bmFtaWNDbGFzcykge1xyXG4gICAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA/IChiID8gYSArICcgJyArIGIgOiBhKSA6IGIgfHwgJyc7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3ModmFsdWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkodmFsdWUpIHtcclxuICAgIHZhciByZXMgPSAnJztcclxuICAgIHZhciBzdHJpbmdpZmllZDtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKChzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xyXG4gICAgICAgICAgICBpZiAocmVzKVxyXG4gICAgICAgICAgICAgICAgcmVzICs9ICcgJztcclxuICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKSB7XHJcbiAgICB2YXIgcmVzID0gJyc7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWVba2V5XSkge1xyXG4gICAgICAgICAgICBpZiAocmVzKVxyXG4gICAgICAgICAgICAgICAgcmVzICs9ICcgJztcclxuICAgICAgICAgICAgcmVzICs9IGtleTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG52YXIgbmFtZXNwYWNlTWFwID0ge1xyXG4gICAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxyXG4gICAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXHJcbn07XHJcbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKCdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcclxuICAgICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXHJcbiAgICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXHJcbiAgICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xyXG4gICAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xyXG4gICAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xyXG4gICAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xyXG4gICAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXHJcbiAgICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcclxuICAgICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXHJcbiAgICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCcpO1xyXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcclxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cclxudmFyIGlzU1ZHID0gbWFrZU1hcCgnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xyXG4gICAgJ2ZvcmVpZ25vYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xyXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLCB0cnVlKTtcclxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcclxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XHJcbiAgICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKTtcclxufTtcclxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlKHRhZykge1xyXG4gICAgaWYgKGlzU1ZHKHRhZykpIHtcclxuICAgICAgICByZXR1cm4gJ3N2Zyc7XHJcbiAgICB9XHJcbiAgICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcclxuICAgIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcclxuICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xyXG4gICAgICAgIHJldHVybiAnbWF0aCc7XHJcbiAgICB9XHJcbn1cclxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50KHRhZykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWluQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddO1xyXG4gICAgfVxyXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xyXG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XHJcbiAgICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPVxyXG4gICAgICAgICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpO1xyXG4gICAgfVxyXG59XHJcbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xyXG5cclxuLyoqXHJcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnkoZWwpIHtcclxuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMignQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgdm5vZGUpIHtcclxuICAgIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gICAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsbTtcclxuICAgIH1cclxuICAgIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XHJcbiAgICBpZiAodm5vZGUuZGF0YSAmJlxyXG4gICAgICAgIHZub2RlLmRhdGEuYXR0cnMgJiZcclxuICAgICAgICB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsbTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWdOYW1lKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh0ZXh0KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpIHtcclxuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGVuZENoaWxkKG5vZGUsIGNoaWxkKSB7XHJcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XHJcbn1cclxuZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XHJcbn1cclxuZnVuY3Rpb24gdGFnTmFtZShub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lO1xyXG59XHJcbmZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpIHtcclxuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUobm9kZSwgc2NvcGVJZCkge1xyXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xyXG59XHJcblxyXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcclxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcclxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXHJcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcclxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcclxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXHJcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxyXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXHJcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxyXG4gIHRhZ05hbWU6IHRhZ05hbWUsXHJcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxyXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcclxufSk7XHJcblxyXG52YXIgcmVmID0ge1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoXywgdm5vZGUpIHtcclxuICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgICAgICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xyXG4gICAgICAgICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKHZub2RlKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiByZWdpc3RlclJlZih2bm9kZSwgaXNSZW1vdmFsKSB7XHJcbiAgICB2YXIgcmVmID0gdm5vZGUuZGF0YS5yZWY7XHJcbiAgICBpZiAoIWlzRGVmKHJlZikpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcclxuICAgIHZhciByZWZWYWx1ZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcclxuICAgIHZhciB2YWx1ZSA9IGlzUmVtb3ZhbCA/IG51bGwgOiByZWZWYWx1ZTtcclxuICAgIHZhciAkcmVmc1ZhbHVlID0gaXNSZW1vdmFsID8gdW5kZWZpbmVkIDogcmVmVmFsdWU7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XHJcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcocmVmLCB2bSwgW3ZhbHVlXSwgdm0sIFwidGVtcGxhdGUgcmVmIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBpc0ZvciA9IHZub2RlLmRhdGEucmVmSW5Gb3I7XHJcbiAgICB2YXIgX2lzU3RyaW5nID0gdHlwZW9mIHJlZiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHJlZiA9PT0gJ251bWJlcic7XHJcbiAgICB2YXIgX2lzUmVmID0gaXNSZWYocmVmKTtcclxuICAgIHZhciByZWZzID0gdm0uJHJlZnM7XHJcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xyXG4gICAgICAgIGlmIChpc0Zvcikge1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyByZWZzW3JlZl0gOiByZWYudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc1JlbW92YWwpIHtcclxuICAgICAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZSQyKGV4aXN0aW5nLCByZWZWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTZXR1cFJlZih2bSwgcmVmLCByZWZzW3JlZl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoX2lzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1JlbW92YWwgJiYgcmVmc1tyZWZdICE9PSByZWZWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlZnNbcmVmXSA9ICRyZWZzVmFsdWU7XHJcbiAgICAgICAgICAgIHNldFNldHVwUmVmKHZtLCByZWYsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoX2lzUmVmKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1JlbW92YWwgJiYgcmVmLnZhbHVlICE9PSByZWZWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6IFwiLmNvbmNhdCh0eXBlb2YgcmVmKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldFNldHVwUmVmKF9hLCBrZXksIHZhbCkge1xyXG4gICAgdmFyIF9zZXR1cFN0YXRlID0gX2EuX3NldHVwU3RhdGU7XHJcbiAgICBpZiAoX3NldHVwU3RhdGUgJiYgaGFzT3duKF9zZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgaWYgKGlzUmVmKF9zZXR1cFN0YXRlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIF9zZXR1cFN0YXRlW2tleV0udmFsdWUgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc2V0dXBTdGF0ZVtrZXldID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxyXG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICpcclxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXHJcbiAqXHJcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcclxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXHJcbiAqL1xyXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xyXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcclxuZnVuY3Rpb24gc2FtZVZub2RlKGEsIGIpIHtcclxuICAgIHJldHVybiAoYS5rZXkgPT09IGIua2V5ICYmXHJcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXHJcbiAgICAgICAgKChhLnRhZyA9PT0gYi50YWcgJiZcclxuICAgICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXHJcbiAgICAgICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcclxuICAgICAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKSkgfHxcclxuICAgICAgICAgICAgKGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiYgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcikpKSk7XHJcbn1cclxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZShhLCBiKSB7XHJcbiAgICBpZiAoYS50YWcgIT09ICdpbnB1dCcpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB0eXBlQSA9IGlzRGVmKChpID0gYS5kYXRhKSkgJiYgaXNEZWYoKGkgPSBpLmF0dHJzKSkgJiYgaS50eXBlO1xyXG4gICAgdmFyIHR5cGVCID0gaXNEZWYoKGkgPSBiLmRhdGEpKSAmJiBpc0RlZigoaSA9IGkuYXR0cnMpKSAmJiBpLnR5cGU7XHJcbiAgICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IChpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQikpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4KGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XHJcbiAgICB2YXIgaSwga2V5O1xyXG4gICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcclxuICAgICAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XHJcbiAgICAgICAgaWYgKGlzRGVmKGtleSkpXHJcbiAgICAgICAgICAgIG1hcFtrZXldID0gaTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXA7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbihiYWNrZW5kKSB7XHJcbiAgICB2YXIgaSwgajtcclxuICAgIHZhciBjYnMgPSB7fTtcclxuICAgIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzLCBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcclxuICAgICAgICAgICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBlbXB0eU5vZGVBdChlbG0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUm1DYihjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICAgICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xyXG4gICAgICAgIHJldHVybiByZW1vdmU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKGVsKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XHJcbiAgICAgICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XHJcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50KHZub2RlLCBpblZQcmUpIHtcclxuICAgICAgICByZXR1cm4gKCFpblZQcmUgJiZcclxuICAgICAgICAgICAgIXZub2RlLm5zICYmXHJcbiAgICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWc7XHJcbiAgICAgICAgICAgICAgICB9KSkgJiZcclxuICAgICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQsIG93bmVyQXJyYXksIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcclxuICAgICAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cclxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcclxuICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXHJcbiAgICAgICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcclxuICAgICAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xyXG4gICAgICAgIGlmIChpc0RlZih0YWcpKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc+IC0gZGlkIHlvdSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xyXG4gICAgICAgICAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxyXG4gICAgICAgICAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XHJcbiAgICAgICAgICAgIHNldFNjb3BlKHZub2RlKTtcclxuICAgICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xyXG4gICAgICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcclxuICAgICAgICB2YXIgaSA9IHZub2RlLmRhdGE7XHJcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XHJcbiAgICAgICAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cclxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cclxuICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcclxuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xyXG4gICAgICAgICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XHJcbiAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xyXG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXHJcbiAgICAgICAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xyXG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cclxuICAgICAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXHJcbiAgICAgICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XHJcbiAgICAgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cclxuICAgICAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XHJcbiAgICAgICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpbm5lck5vZGUuZGF0YSkpICYmIGlzRGVmKChpID0gaS50cmFuc2l0aW9uKSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxyXG4gICAgICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXHJcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBhcmVudCwgZWxtLCByZWYpIHtcclxuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYpID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2lfMSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2lfMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaV8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xyXG4gICAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1BhdGNoYWJsZSh2bm9kZSkge1xyXG4gICAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraV8yKSB7XHJcbiAgICAgICAgICAgIGNicy5jcmVhdGVbaV8yXShlbXB0eU5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcclxuICAgICAgICBpZiAoaXNEZWYoaSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSlcclxuICAgICAgICAgICAgICAgIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKVxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXHJcbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxyXG4gICAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxyXG4gICAgZnVuY3Rpb24gc2V0U2NvcGUodm5vZGUpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5mblNjb3BlSWQpKSkge1xyXG4gICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xyXG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGFuY2VzdG9yLmNvbnRleHQpKSAmJiBpc0RlZigoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxyXG4gICAgICAgIGlmIChpc0RlZigoaSA9IGFjdGl2ZUluc3RhbmNlKSkgJiZcclxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxyXG4gICAgICAgICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcclxuICAgICAgICAgICAgaXNEZWYoKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkpIHtcclxuICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xyXG4gICAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcclxuICAgICAgICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayh2bm9kZSkge1xyXG4gICAgICAgIHZhciBpLCBqO1xyXG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmRlc3Ryb3kpKSlcclxuICAgICAgICAgICAgICAgIGkodm5vZGUpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmNoaWxkcmVuKSkpIHtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXModm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XHJcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xyXG4gICAgICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sodm5vZGUsIHJtKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xyXG4gICAgICAgICAgICB2YXIgaV8zO1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYocm0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcclxuICAgICAgICAgICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xyXG4gICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGlfMyA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKChpXzMgPSBpXzMuX3Zub2RlKSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKGlfMy5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpXzMsIHJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGlfMyA9IDA7IGlfMyA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2lfMykge1xyXG4gICAgICAgICAgICAgICAgY2JzLnJlbW92ZVtpXzNdKHZub2RlLCBybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpXzMgPSB2bm9kZS5kYXRhLmhvb2spKSAmJiBpc0RlZigoaV8zID0gaV8zLnJlbW92ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpXzModm5vZGUsIHJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJtKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XHJcbiAgICAgICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcclxuICAgICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xyXG4gICAgICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XHJcbiAgICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcclxuICAgICAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xyXG4gICAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XHJcbiAgICAgICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcclxuICAgICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cclxuICAgICAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXHJcbiAgICAgICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcclxuICAgICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcclxuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XHJcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcclxuICAgICAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xyXG4gICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XHJcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XHJcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICBjYW5Nb3ZlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgICAgICAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcclxuICAgICAgICAgICAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxyXG4gICAgICAgICAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xyXG4gICAgICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XHJcbiAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdmFyIHNlZW5LZXlzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaV80ID0gMDsgaV80IDwgY2hpbGRyZW4ubGVuZ3RoOyBpXzQrKykge1xyXG4gICAgICAgICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXzRdO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiLmNvbmNhdChrZXksIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSwgdm5vZGUuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGZvciAodmFyIGlfNSA9IHN0YXJ0OyBpXzUgPCBlbmQ7IGlfNSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gb2xkQ2hbaV81XTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBpXzU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgb3duZXJBcnJheSwgaW5kZXgsIHJlbW92ZU9ubHkpIHtcclxuICAgICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcclxuICAgICAgICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXHJcbiAgICAgICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsbSA9ICh2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG0pO1xyXG4gICAgICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgICAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cclxuICAgICAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cclxuICAgICAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cclxuICAgICAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxyXG4gICAgICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXHJcbiAgICAgICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcclxuICAgICAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcclxuICAgICAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XHJcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5wcmVwYXRjaCkpKSB7XHJcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnVwZGF0ZSkpKVxyXG4gICAgICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZENoICE9PSBjaClcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihjaCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSlcclxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xyXG4gICAgICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcclxuICAgICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnBvc3RwYXRjaCkpKVxyXG4gICAgICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XHJcbiAgICAgICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXHJcbiAgICAgICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcclxuICAgICAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaV82ID0gMDsgaV82IDwgcXVldWUubGVuZ3RoOyArK2lfNikge1xyXG4gICAgICAgICAgICAgICAgcXVldWVbaV82XS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2lfNl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xyXG4gICAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcclxuICAgIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcclxuICAgIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxyXG4gICAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcclxuICAgIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXHJcbiAgICBmdW5jdGlvbiBoeWRyYXRlKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRhZyA9IHZub2RlLnRhZywgZGF0YSA9IHZub2RlLmRhdGEsIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcclxuICAgICAgICB2bm9kZS5lbG0gPSBlbG07XHJcbiAgICAgICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcclxuICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKVxyXG4gICAgICAgICAgICAgICAgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cclxuICAgICAgICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWYodGFnKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuZG9tUHJvcHMpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuaW5uZXJIVE1MKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfNyA9IDA7IGlfNyA8IGNoaWxkcmVuLmxlbmd0aDsgaV83KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpXzddLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xyXG4gICAgICAgICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcclxuICAgICAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgICghaXNVbmtub3duRWxlbWVudCh2bm9kZSwgaW5WUHJlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpXHJcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xyXG4gICAgICAgICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XHJcbiAgICAgICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBcclxuICAgICAgICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXHJcbiAgICAgICAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcclxuICAgICAgICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXHJcbiAgICAgICAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzggPSAwOyBpXzggPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraV84KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXzhdKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfOSA9IDA7IGlfOSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2lfOSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV85XShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICM2NTEzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydF8xID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnRfMS5tZXJnZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9uZSBpbnNlcnQgaG9va3MgdG8gYXZvaWQgYmVpbmcgbXV0YXRlZCBkdXJpbmcgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGN1c3RvbWVkIGRpcmVjdGl2ZXMgdW5kZXIgdHJhbnNpdGlvbiBncm91cC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmVkID0gaW5zZXJ0XzEuZm5zLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTAgPSAwOyBpXzEwIDwgY2xvbmVkLmxlbmd0aDsgaV8xMCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZFtpXzEwXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlLmVsbTtcclxuICAgIH07XHJcbn1cclxuXHJcbnZhciBkaXJlY3RpdmVzJDEgPSB7XHJcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzKHZub2RlKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBlbXB0eU5vZGUgaXMgbm90IFZOb2RlV2l0aERhdGFcclxuICAgICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XHJcbiAgICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcclxuICAgIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyhvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xyXG4gICAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XHJcbiAgICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcclxuICAgIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xyXG4gICAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XHJcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XHJcbiAgICAgICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xyXG4gICAgICAgIGRpciA9IG5ld0RpcnNba2V5XTtcclxuICAgICAgICBpZiAoIW9sZERpcikge1xyXG4gICAgICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXHJcbiAgICAgICAgICAgIGNhbGxIb29rKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXHJcbiAgICAgICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcclxuICAgICAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGlzQ3JlYXRlKSB7XHJcbiAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsSW5zZXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQ3JlYXRlKSB7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xyXG4gICAgICAgICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxyXG4gICAgICAgICAgICAgICAgY2FsbEhvb2sob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMoZGlycywgdm0pIHtcclxuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgaWYgKCFkaXJzKSB7XHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHZhciBpLCBkaXI7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGRpciA9IGRpcnNbaV07XHJcbiAgICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xyXG4gICAgICAgIGlmICh2bS5fc2V0dXBTdGF0ZSAmJiB2bS5fc2V0dXBTdGF0ZS5fX3NmYykge1xyXG4gICAgICAgICAgICB2YXIgc2V0dXBEZWYgPSBkaXIuZGVmIHx8IHJlc29sdmVBc3NldCh2bSwgJ19zZXR1cFN0YXRlJywgJ3YtJyArIGRpci5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR1cERlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZGlyLmRlZiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5kOiBzZXR1cERlZixcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHNldHVwRGVmLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpci5kZWYgPSBzZXR1cERlZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkaXIuZGVmID0gZGlyLmRlZiB8fCByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUoZGlyKSB7XHJcbiAgICByZXR1cm4gKGRpci5yYXdOYW1lIHx8IFwiXCIuY29uY2F0KGRpci5uYW1lLCBcIi5cIikuY29uY2F0KE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcclxuICAgIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcclxuICAgIGlmIChmbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIFwiZGlyZWN0aXZlIFwiLmNvbmNhdChkaXIubmFtZSwgXCIgXCIpLmNvbmNhdChob29rLCBcIiBob29rXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBiYXNlTW9kdWxlcyA9IFtyZWYsIGRpcmVjdGl2ZXMkMV07XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVBdHRycyhvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBrZXksIGN1ciwgb2xkO1xyXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcclxuICAgIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XHJcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xyXG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XHJcbiAgICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSB8fCBpc1RydWUoYXR0cnMuX3ZfYXR0cl9wcm94eSkpIHtcclxuICAgICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcclxuICAgIH1cclxuICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgY3VyID0gYXR0cnNba2V5XTtcclxuICAgICAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xyXG4gICAgICAgIGlmIChvbGQgIT09IGN1cikge1xyXG4gICAgICAgICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxyXG4gICAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcclxuICAgICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNYbGluayhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRBdHRyKGVsLCBrZXksIHZhbHVlLCBpc0luUHJlKSB7XHJcbiAgICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XHJcbiAgICAgICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XHJcbiAgICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcclxuICAgICAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxyXG4gICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcclxuICAgICAgICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcclxuICAgICAgICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCcgPyAndHJ1ZScgOiBrZXk7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xyXG4gICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpIHtcclxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cclxuICAgICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXHJcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKGlzSUUgJiZcclxuICAgICAgICAgICAgIWlzSUU5ICYmXHJcbiAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcclxuICAgICAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmXHJcbiAgICAgICAgICAgIHZhbHVlICE9PSAnJyAmJlxyXG4gICAgICAgICAgICAhZWwuX19pZXBoKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VyXzEgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcl8xKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyXzEpO1xyXG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgICAgICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxudmFyIGF0dHJzID0ge1xyXG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcclxuICAgIHVwZGF0ZTogdXBkYXRlQXR0cnNcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcclxuICAgICAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmXHJcbiAgICAgICAgKGlzVW5kZWYob2xkRGF0YSkgfHxcclxuICAgICAgICAgICAgKGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiYgaXNVbmRlZihvbGREYXRhLmNsYXNzKSkpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xyXG4gICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xyXG4gICAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcclxuICAgIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XHJcbiAgICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XHJcbiAgICB9XHJcbiAgICAvLyBzZXQgdGhlIGNsYXNzXHJcbiAgICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XHJcbiAgICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcclxuICAgIH1cclxufVxyXG52YXIga2xhc3MkMSA9IHtcclxuICAgIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXHJcbiAgICB1cGRhdGU6IHVwZGF0ZUNsYXNzXHJcbn07XHJcblxyXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcclxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzKGV4cCkge1xyXG4gICAgdmFyIGluU2luZ2xlID0gZmFsc2U7XHJcbiAgICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcclxuICAgIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XHJcbiAgICB2YXIgaW5SZWdleCA9IGZhbHNlO1xyXG4gICAgdmFyIGN1cmx5ID0gMDtcclxuICAgIHZhciBzcXVhcmUgPSAwO1xyXG4gICAgdmFyIHBhcmVuID0gMDtcclxuICAgIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xyXG4gICAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcHJldiA9IGM7XHJcbiAgICAgICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChpblNpbmdsZSkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5TaW5nbGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5Eb3VibGUpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluRG91YmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5SZWdleCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5SZWdleCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjID09PSAweDdjICYmIC8vIHBpcGVcclxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdjICYmXHJcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3YyAmJlxyXG4gICAgICAgICAgICAhY3VybHkgJiZcclxuICAgICAgICAgICAgIXNxdWFyZSAmJlxyXG4gICAgICAgICAgICAhcGFyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHB1c2hGaWx0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4MjI6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBcIlxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDI3OlxyXG4gICAgICAgICAgICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gJ1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDYwOlxyXG4gICAgICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBgXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjg6XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4rKztcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gKFxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDI5OlxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVuLS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIClcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg1YjpcclxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUrKztcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gW1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDVkOlxyXG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBdXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4N2I6XHJcbiAgICAgICAgICAgICAgICAgICAgY3VybHkrKztcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8ge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDdkOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cmx5LS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZikge1xyXG4gICAgICAgICAgICAgICAgLy8gL1xyXG4gICAgICAgICAgICAgICAgdmFyIGogPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgIHZhciBwIFxyXG4gICAgICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcclxuICAgICAgICAgICAgICAgID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcclxuICAgICAgICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9PSAnICcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xyXG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XHJcbiAgICAgICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcclxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgIH1cclxuICAgIGlmIChmaWx0ZXJzKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHJlc3Npb247XHJcbn1cclxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlcikge1xyXG4gICAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcclxuICAgICAgICByZXR1cm4gXCJfZihcXFwiXCIuY29uY2F0KGZpbHRlciwgXCJcXFwiKShcIikuY29uY2F0KGV4cCwgXCIpXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG5hbWVfMSA9IGZpbHRlci5zbGljZSgwLCBpKTtcclxuICAgICAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIFwiX2YoXFxcIlwiLmNvbmNhdChuYW1lXzEsIFwiXFxcIikoXCIpLmNvbmNhdChleHApLmNvbmNhdChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbmZ1bmN0aW9uIGJhc2VXYXJuKG1zZywgcmFuZ2UpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIGNvbXBpbGVyXTogXCIuY29uY2F0KG1zZykpO1xyXG59XHJcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbihtb2R1bGVzLCBrZXkpIHtcclxuICAgIHJldHVybiBtb2R1bGVzID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KSA6IFtdO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xyXG4gICAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcclxuICAgIGVsLnBsYWluID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XHJcbiAgICB2YXIgYXR0cnMgPSBkeW5hbWljXHJcbiAgICAgICAgPyBlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKVxyXG4gICAgICAgIDogZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pO1xyXG4gICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcclxuICAgIGVsLnBsYWluID0gZmFsc2U7XHJcbn1cclxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXHJcbmZ1bmN0aW9uIGFkZFJhd0F0dHIoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xyXG4gICAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcclxuICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljQXJnLCBtb2RpZmllcnMsIHJhbmdlKSB7XHJcbiAgICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgcmF3TmFtZTogcmF3TmFtZSxcclxuICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgaXNEeW5hbWljQXJnOiBpc0R5bmFtaWNBcmcsXHJcbiAgICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcclxuICAgIH0sIHJhbmdlKSk7XHJcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlcihzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcclxuICAgIHJldHVybiBkeW5hbWljID8gXCJfcChcIi5jb25jYXQobmFtZSwgXCIsXFxcIlwiKS5jb25jYXQoc3ltYm9sLCBcIlxcXCIpXCIpIDogc3ltYm9sICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcclxufVxyXG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpbXBvcnRhbnQsIHdhcm4sIHJhbmdlLCBkeW5hbWljKSB7XHJcbiAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XHJcbiAgICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xyXG4gICAgICAgIHdhcm4oXCJwYXNzaXZlIGFuZCBwcmV2ZW50IGNhbid0IGJlIHVzZWQgdG9nZXRoZXIuIFwiICtcclxuICAgICAgICAgICAgXCJQYXNzaXZlIGhhbmRsZXIgY2FuJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LlwiLCByYW5nZSk7XHJcbiAgICB9XHJcbiAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcclxuICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXHJcbiAgICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cclxuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcclxuICAgICAgICBpZiAoZHluYW1pYykge1xyXG4gICAgICAgICAgICBuYW1lID0gXCIoXCIuY29uY2F0KG5hbWUsIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIpLmNvbmNhdChuYW1lLCBcIilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xyXG4gICAgICAgIGlmIChkeW5hbWljKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBcIihcIi5jb25jYXQobmFtZSwgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiKS5jb25jYXQobmFtZSwgXCIpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxyXG4gICAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XHJcbiAgICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xyXG4gICAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMub25jZSkge1xyXG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcclxuICAgICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xyXG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcclxuICAgICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XHJcbiAgICB9XHJcbiAgICB2YXIgZXZlbnRzO1xyXG4gICAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcclxuICAgICAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcclxuICAgICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xyXG4gICAgfVxyXG4gICAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcclxuICAgIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XHJcbiAgICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XHJcbiAgICB9XHJcbiAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xyXG4gICAgICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFuZGxlcnMpIHtcclxuICAgICAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyKGVsLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XHJcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcclxuICAgICAgICBlbC5yYXdBdHRyc01hcFtuYW1lXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIoZWwsIG5hbWUsIGdldFN0YXRpYykge1xyXG4gICAgdmFyIGR5bmFtaWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xyXG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xyXG4gICAgICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcclxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cclxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXHJcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cclxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSwgcmVtb3ZlRnJvbU1hcCkge1xyXG4gICAgdmFyIHZhbDtcclxuICAgIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcclxuICAgICAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmVtb3ZlRnJvbU1hcCkge1xyXG4gICAgICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIG5hbWUpIHtcclxuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciBhdHRyID0gbGlzdFtpXTtcclxuICAgICAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcclxuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhdHRyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0oaXRlbSwgcmFuZ2UpIHtcclxuICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc3RhcnQgPSByYW5nZS5zdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtO1xyXG59XHJcblxyXG4vKipcclxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcclxuICAgIHZhciBfYSA9IG1vZGlmaWVycyB8fCB7fSwgbnVtYmVyID0gX2EubnVtYmVyLCB0cmltID0gX2EudHJpbTtcclxuICAgIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XHJcbiAgICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcclxuICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uID1cclxuICAgICAgICAgICAgXCIodHlwZW9mIFwiLmNvbmNhdChiYXNlVmFsdWVFeHByZXNzaW9uLCBcIiA9PT0gJ3N0cmluZydcIikgK1xyXG4gICAgICAgICAgICAgICAgXCI/IFwiLmNvbmNhdChiYXNlVmFsdWVFeHByZXNzaW9uLCBcIi50cmltKClcIikgK1xyXG4gICAgICAgICAgICAgICAgXCI6IFwiLmNvbmNhdChiYXNlVmFsdWVFeHByZXNzaW9uLCBcIilcIik7XHJcbiAgICB9XHJcbiAgICBpZiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIi5jb25jYXQodmFsdWVFeHByZXNzaW9uLCBcIilcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xyXG4gICAgZWwubW9kZWwgPSB7XHJcbiAgICAgICAgdmFsdWU6IFwiKFwiLmNvbmNhdCh2YWx1ZSwgXCIpXCIpLFxyXG4gICAgICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcclxuICAgICAgICBjYWxsYmFjazogXCJmdW5jdGlvbiAoXCIuY29uY2F0KGJhc2VWYWx1ZUV4cHJlc3Npb24sIFwiKSB7XCIpLmNvbmNhdChhc3NpZ25tZW50LCBcIn1cIilcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpIHtcclxuICAgIHZhciByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcclxuICAgIGlmIChyZXMua2V5ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbHVlLCBcIj1cIikuY29uY2F0KGFzc2lnbm1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwiJHNldChcIi5jb25jYXQocmVzLmV4cCwgXCIsIFwiKS5jb25jYXQocmVzLmtleSwgXCIsIFwiKS5jb25jYXQoYXNzaWdubWVudCwgXCIpXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxyXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cclxuICpcclxuICogUG9zc2libGUgY2FzZXM6XHJcbiAqXHJcbiAqIC0gdGVzdFxyXG4gKiAtIHRlc3Rba2V5XVxyXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cclxuICogLSB0ZXN0W1wiYVwiXVtrZXldXHJcbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxyXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cclxuICpcclxuICovXHJcbnZhciBsZW4sIHN0ciwgY2hyLCBpbmRleCwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcclxuZnVuY3Rpb24gcGFyc2VNb2RlbCh2YWwpIHtcclxuICAgIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxyXG4gICAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXHJcbiAgICB2YWwgPSB2YWwudHJpbSgpO1xyXG4gICAgbGVuID0gdmFsLmxlbmd0aDtcclxuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcclxuICAgICAgICBpbmRleCA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCksXHJcbiAgICAgICAgICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXggKyAxKSArICdcIidcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBleHA6IHZhbCxcclxuICAgICAgICAgICAgICAgIGtleTogbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0ciA9IHZhbDtcclxuICAgIGluZGV4ID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xyXG4gICAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgICAgIGNociA9IG5leHQoKTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XHJcbiAgICAgICAgICAgIHBhcnNlU3RyaW5nKGNocik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNociA9PT0gMHg1Yikge1xyXG4gICAgICAgICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxyXG4gICAgICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIGVvZigpIHtcclxuICAgIHJldHVybiBpbmRleCA+PSBsZW47XHJcbn1cclxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydChjaHIpIHtcclxuICAgIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQnJhY2tldChjaHIpIHtcclxuICAgIHZhciBpbkJyYWNrZXQgPSAxO1xyXG4gICAgZXhwcmVzc2lvblBvcyA9IGluZGV4O1xyXG4gICAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgICAgIGNociA9IG5leHQoKTtcclxuICAgICAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XHJcbiAgICAgICAgICAgIHBhcnNlU3RyaW5nKGNocik7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hyID09PSAweDViKVxyXG4gICAgICAgICAgICBpbkJyYWNrZXQrKztcclxuICAgICAgICBpZiAoY2hyID09PSAweDVkKVxyXG4gICAgICAgICAgICBpbkJyYWNrZXQtLTtcclxuICAgICAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKGNocikge1xyXG4gICAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xyXG4gICAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgICAgIGNociA9IG5leHQoKTtcclxuICAgICAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB3YXJuJDE7XHJcbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcclxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cclxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XHJcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xyXG5mdW5jdGlvbiBtb2RlbCQxKGVsLCBkaXIsIF93YXJuKSB7XHJcbiAgICB3YXJuJDEgPSBfd2FybjtcclxuICAgIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcclxuICAgIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xyXG4gICAgdmFyIHRhZyA9IGVsLnRhZztcclxuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXHJcbiAgICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cclxuICAgICAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xyXG4gICAgICAgICAgICB3YXJuJDEoXCI8XCIuY29uY2F0KGVsLnRhZywgXCIgdi1tb2RlbD1cXFwiXCIpLmNvbmNhdCh2YWx1ZSwgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIikgK1xyXG4gICAgICAgICAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiLCBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XHJcbiAgICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcclxuICAgICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcclxuICAgICAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcclxuICAgICAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybiQxKFwiPFwiLmNvbmNhdChlbC50YWcsIFwiIHYtbW9kZWw9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIj46IFwiKSArXHJcbiAgICAgICAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXHJcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdCdzIHJlY29tbWVuZGVkIHRvIFwiICtcclxuICAgICAgICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJywgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXSk7XHJcbiAgICB9XHJcbiAgICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcclxuICAgIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcclxuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xyXG4gICAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XHJcbiAgICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcclxuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgXCJBcnJheS5pc0FycmF5KFwiLmNvbmNhdCh2YWx1ZSwgXCIpXCIpICtcclxuICAgICAgICBcIj9faShcIi5jb25jYXQodmFsdWUsIFwiLFwiKS5jb25jYXQodmFsdWVCaW5kaW5nLCBcIik+LTFcIikgK1xyXG4gICAgICAgICh0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcclxuICAgICAgICAgICAgPyBcIjooXCIuY29uY2F0KHZhbHVlLCBcIilcIilcclxuICAgICAgICAgICAgOiBcIjpfcShcIi5jb25jYXQodmFsdWUsIFwiLFwiKS5jb25jYXQodHJ1ZVZhbHVlQmluZGluZywgXCIpXCIpKSk7XHJcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgXCJ2YXIgJCRhPVwiLmNvbmNhdCh2YWx1ZSwgXCIsXCIpICtcclxuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xyXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIuY29uY2F0KHRydWVWYWx1ZUJpbmRpbmcsIFwiKTooXCIpLmNvbmNhdChmYWxzZVZhbHVlQmluZGluZywgXCIpO1wiKSArXHJcbiAgICAgICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXHJcbiAgICAgICAgXCJ2YXIgJCR2PVwiLmNvbmNhdChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZywgXCIsXCIpICtcclxuICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xyXG4gICAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiLmNvbmNhdChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJyksIFwiKX1cIikgK1xyXG4gICAgICAgIFwiZWxzZXskJGk+LTEmJihcIi5jb25jYXQoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpLCBcIil9XCIpICtcclxuICAgICAgICBcIn1lbHNle1wiLmNvbmNhdChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpLCBcIn1cIiksIG51bGwsIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcclxuICAgIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcclxuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xyXG4gICAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gXCJfbihcIi5jb25jYXQodmFsdWVCaW5kaW5nLCBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XHJcbiAgICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIFwiX3EoXCIuY29uY2F0KHZhbHVlLCBcIixcIikuY29uY2F0KHZhbHVlQmluZGluZywgXCIpXCIpKTtcclxuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XHJcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XHJcbiAgICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXHJcbiAgICAgICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcclxuICAgICAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xyXG4gICAgICAgIFwicmV0dXJuIFwiLmNvbmNhdChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJywgXCJ9KVwiKTtcclxuICAgIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XHJcbiAgICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIi5jb25jYXQoc2VsZWN0ZWRWYWwsIFwiO1wiKTtcclxuICAgIGNvZGUgPSBcIlwiLmNvbmNhdChjb2RlLCBcIiBcIikuY29uY2F0KGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XHJcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XHJcbiAgICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XHJcbiAgICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXHJcbiAgICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHZhciB2YWx1ZV8xID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcclxuICAgICAgICB2YXIgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcclxuICAgICAgICBpZiAodmFsdWVfMSAmJiAhdHlwZUJpbmRpbmcpIHtcclxuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xyXG4gICAgICAgICAgICB3YXJuJDEoXCJcIi5jb25jYXQoYmluZGluZywgXCI9XFxcIlwiKS5jb25jYXQodmFsdWVfMSwgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIikgK1xyXG4gICAgICAgICAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLCBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIF9hID0gbW9kaWZpZXJzIHx8IHt9LCBsYXp5ID0gX2EubGF6eSwgbnVtYmVyID0gX2EubnVtYmVyLCB0cmltID0gX2EudHJpbTtcclxuICAgIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XHJcbiAgICB2YXIgZXZlbnQgPSBsYXp5ID8gJ2NoYW5nZScgOiB0eXBlID09PSAncmFuZ2UnID8gUkFOR0VfVE9LRU4gOiAnaW5wdXQnO1xyXG4gICAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcclxuICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xyXG4gICAgfVxyXG4gICAgaWYgKG51bWJlcikge1xyXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIuY29uY2F0KHZhbHVlRXhwcmVzc2lvbiwgXCIpXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcclxuICAgIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xyXG4gICAgICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIi5jb25jYXQoY29kZSk7XHJcbiAgICB9XHJcbiAgICBhZGRQcm9wKGVsLCAndmFsdWUnLCBcIihcIi5jb25jYXQodmFsdWUsIFwiKVwiKSk7XHJcbiAgICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XHJcbiAgICBpZiAodHJpbSB8fCBudW1iZXIpIHtcclxuICAgICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXHJcbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2VcclxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxyXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxyXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMob24pIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcclxuICAgICAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XHJcbiAgICAgICAgdmFyIGV2ZW50XzEgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xyXG4gICAgICAgIG9uW2V2ZW50XzFdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRfMV0gfHwgW10pO1xyXG4gICAgICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxyXG4gICAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xyXG4gICAgICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XHJcbiAgICAgICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcclxuICAgIH1cclxufVxyXG52YXIgdGFyZ2V0O1xyXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xyXG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZShldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcclxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xyXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXHJcbnZhciB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xyXG5mdW5jdGlvbiBhZGQobmFtZSwgaGFuZGxlciwgY2FwdHVyZSwgcGFzc2l2ZSkge1xyXG4gICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxyXG4gICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcclxuICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxyXG4gICAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxyXG4gICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxyXG4gICAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xyXG4gICAgICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcF8xID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbF8xID0gaGFuZGxlcjtcclxuICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBoYW5kbGVyID0gb3JpZ2luYWxfMS5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXHJcbiAgICAgICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXHJcbiAgICAgICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxyXG4gICAgICAgICAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXBfMSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyAjOTQ2MiBpT1MgOSBidWc6IGV2ZW50LnRpbWVTdGFtcCBpcyAwIGFmdGVyIGhpc3RvcnkucHVzaFN0YXRlXHJcbiAgICAgICAgICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcclxuICAgICAgICAgICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcclxuICAgICAgICAgICAgICAgIC8vICM5NDQ4IGJhaWwgaWYgZXZlbnQgaXMgZmlyZWQgaW4gYW5vdGhlciBkb2N1bWVudCBpbiBhIG11bHRpLXBhZ2VcclxuICAgICAgICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF8xLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgc3VwcG9ydHNQYXNzaXZlID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH0gOiBjYXB0dXJlKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmUobmFtZSwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCkge1xyXG4gICAgKF90YXJnZXQgfHwgdGFyZ2V0KS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIFxyXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXHJcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsIGNhcHR1cmUpO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xyXG4gICAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcclxuICAgIC8vIHZub2RlIGlzIGVtcHR5IHdoZW4gcmVtb3ZpbmcgYWxsIGxpc3RlbmVycyxcclxuICAgIC8vIGFuZCB1c2Ugb2xkIHZub2RlIGRvbSBlbGVtZW50XHJcbiAgICB0YXJnZXQgPSB2bm9kZS5lbG0gfHwgb2xkVm5vZGUuZWxtO1xyXG4gICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcclxuICAgIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlLCBjcmVhdGVPbmNlSGFuZGxlciwgdm5vZGUuY29udGV4dCk7XHJcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XHJcbn1cclxudmFyIGV2ZW50cyA9IHtcclxuICAgIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxyXG4gICAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGVtcHR5Tm9kZSBoYXMgYWN0dWFsbHkgZGF0YVxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKHZub2RlKSB7IHJldHVybiB1cGRhdGVET01MaXN0ZW5lcnModm5vZGUsIGVtcHR5Tm9kZSk7IH1cclxufTtcclxuXHJcbnZhciBzdmdDb250YWluZXI7XHJcbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBrZXksIGN1cjtcclxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XHJcbiAgICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xyXG4gICAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcclxuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxyXG4gICAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykgfHwgaXNUcnVlKHByb3BzLl92X2F0dHJfcHJveHkpKSB7XHJcbiAgICAgICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgZWxtW2tleV0gPSAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgIGN1ciA9IHByb3BzW2tleV07XHJcbiAgICAgICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXHJcbiAgICAgICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcclxuICAgICAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxyXG4gICAgICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xyXG4gICAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4pXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcclxuICAgICAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcclxuICAgICAgICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XHJcbiAgICAgICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcclxuICAgICAgICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcclxuICAgICAgICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXHJcbiAgICAgICAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XHJcbiAgICAgICAgICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJlxyXG4gICAgICAgICAgICBpc1NWRyhlbG0udGFnTmFtZSkgJiZcclxuICAgICAgICAgICAgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xyXG4gICAgICAgICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcclxuICAgICAgICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gXCI8c3ZnPlwiLmNvbmNhdChjdXIsIFwiPC9zdmc+XCIpO1xyXG4gICAgICAgICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXHJcbiAgICAgICAgLy8gYHZhbHVlYCBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxyXG4gICAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXHJcbiAgICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNzYXJ5IGBjaGVja2VkYCB1cGRhdGUuXHJcbiAgICAgICAgY3VyICE9PSBvbGRQcm9wc1trZXldKSB7XHJcbiAgICAgICAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcclxuICAgICAgICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZWxtW2tleV0gPSBjdXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZShlbG0sIGNoZWNrVmFsKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXHJcbiAgICAhZWxtLmNvbXBvc2luZyAmJlxyXG4gICAgICAgIChlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcclxuICAgICAgICAgICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcclxuICAgICAgICAgICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbCkpKTtcclxufVxyXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB7XHJcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXHJcbiAgICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcclxuICAgIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcclxuICAgIC8vICM2MTU3XHJcbiAgICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWw7XHJcbn1cclxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBuZXdWYWwpIHtcclxuICAgIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcclxuICAgIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxyXG4gICAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcclxuICAgICAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbDtcclxufVxyXG52YXIgZG9tUHJvcHMgPSB7XHJcbiAgICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxyXG4gICAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xyXG59O1xyXG5cclxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XHJcbiAgICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xyXG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59KTtcclxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhKGRhdGEpIHtcclxuICAgIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcclxuICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxyXG4gICAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcclxuICAgIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xyXG59XHJcbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGJpbmRpbmdTdHlsZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xyXG4gICAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmluZGluZ1N0eWxlO1xyXG59XHJcbi8qKlxyXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXHJcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdHlsZSh2bm9kZSwgY2hlY2tDaGlsZCkge1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgdmFyIHN0eWxlRGF0YTtcclxuICAgIGlmIChjaGVja0NoaWxkKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xyXG4gICAgICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLmRhdGEgJiZcclxuICAgICAgICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xyXG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwYXJlbnROb2RlLnBhcmVudCBub3QgVk5vZGVXaXRoRGF0YVxyXG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxudmFyIGNzc1ZhclJFID0gL14tLS87XHJcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xyXG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cclxuICAgICAgICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbnZhciBlbXB0eVN0eWxlO1xyXG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcclxuICAgIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcclxuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiBwcm9wIGluIGVtcHR5U3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgIH1cclxuICAgIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG5hbWVfMSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcclxuICAgICAgICBpZiAobmFtZV8xIGluIGVtcHR5U3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWVfMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5mdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcclxuICAgIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmXHJcbiAgICAgICAgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxyXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiZcclxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3R5bGUpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGN1ciwgbmFtZTtcclxuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcclxuICAgIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XHJcbiAgICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcclxuICAgIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXHJcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XHJcbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XHJcbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXHJcbiAgICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXHJcbiAgICAvLyB0byBtdXRhdGUgaXQuXHJcbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXykgPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xyXG4gICAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xyXG4gICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XHJcbiAgICAgICAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcclxuICAgICAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcclxuICAgICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xyXG4gICAgfVxyXG59XHJcbnZhciBzdHlsZSQxID0ge1xyXG4gICAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcclxuICAgIHVwZGF0ZTogdXBkYXRlU3R5bGVcclxufTtcclxuXHJcbnZhciB3aGl0ZXNwYWNlUkUkMSA9IC9cXHMrLztcclxuLyoqXHJcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxyXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcclxuICovXHJcbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbHMpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xyXG4gICAgICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFJDEpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjdXIgPSBcIiBcIi5jb25jYXQoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnLCBcIiBcIik7XHJcbiAgICAgICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXHJcbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNscykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUkMSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGN1ciA9IFwiIFwiLmNvbmNhdChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycsIFwiIFwiKTtcclxuICAgICAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xyXG4gICAgICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcclxuICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXIgPSBjdXIudHJpbSgpO1xyXG4gICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbihkZWYpIHtcclxuICAgIGlmICghZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHZhciByZXMgPSB7fTtcclxuICAgICAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4dGVuZChyZXMsIGRlZik7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZik7XHJcbiAgICB9XHJcbn1cclxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVudGVyQ2xhc3M6IFwiXCIuY29uY2F0KG5hbWUsIFwiLWVudGVyXCIpLFxyXG4gICAgICAgIGVudGVyVG9DbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItZW50ZXItdG9cIiksXHJcbiAgICAgICAgZW50ZXJBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItZW50ZXItYWN0aXZlXCIpLFxyXG4gICAgICAgIGxlYXZlQ2xhc3M6IFwiXCIuY29uY2F0KG5hbWUsIFwiLWxlYXZlXCIpLFxyXG4gICAgICAgIGxlYXZlVG9DbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItbGVhdmUtdG9cIiksXHJcbiAgICAgICAgbGVhdmVBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItbGVhdmUtYWN0aXZlXCIpXHJcbiAgICB9O1xyXG59KTtcclxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xyXG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcclxudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXHJcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcclxudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcclxudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcclxudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XHJcbmlmIChoYXNUcmFuc2l0aW9uKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcclxuICAgICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcclxuICAgICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xyXG4gICAgfVxyXG59XHJcbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxyXG52YXIgcmFmID0gaW5Ccm93c2VyXHJcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXHJcbiAgICAgICAgOiBzZXRUaW1lb3V0XHJcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uICgvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmbikgeyByZXR1cm4gZm4oKTsgfTtcclxuZnVuY3Rpb24gbmV4dEZyYW1lKGZuKSB7XHJcbiAgICByYWYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICByYWYoZm4pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xyXG4gICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcclxuICAgICAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XHJcbiAgICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICByZW1vdmUkMihlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxufVxyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgY2IpIHtcclxuICAgIHZhciBfYSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpLCB0eXBlID0gX2EudHlwZSwgdGltZW91dCA9IF9hLnRpbWVvdXQsIHByb3BDb3VudCA9IF9hLnByb3BDb3VudDtcclxuICAgIGlmICghdHlwZSlcclxuICAgICAgICByZXR1cm4gY2IoKTtcclxuICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcclxuICAgIHZhciBlbmRlZCA9IDA7XHJcbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcclxuICAgICAgICBjYigpO1xyXG4gICAgfTtcclxuICAgIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xyXG4gICAgICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aW1lb3V0ICsgMSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbn1cclxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcclxuICAgIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XHJcbiAgICB2YXIgdHlwZTtcclxuICAgIHZhciB0aW1lb3V0ID0gMDtcclxuICAgIHZhciBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgdGltZW91dDogdGltZW91dCxcclxuICAgICAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKTtcclxuICAgIH0pKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXHJcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3RpbmdcclxuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxyXG5cclxuZnVuY3Rpb24gZW50ZXIodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcclxuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcclxuICAgIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XHJcbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XHJcbiAgICAgICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgICBlbC5fbGVhdmVDYigpO1xyXG4gICAgfVxyXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xyXG4gICAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY3NzID0gZGF0YS5jc3MsIHR5cGUgPSBkYXRhLnR5cGUsIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3MsIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzLCBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzLCBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3MsIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3MsIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcywgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyLCBlbnRlciA9IGRhdGEuZW50ZXIsIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXIsIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZCwgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXIsIGFwcGVhciA9IGRhdGEuYXBwZWFyLCBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXIsIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkLCBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XHJcbiAgICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXHJcbiAgICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcclxuICAgIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXHJcbiAgICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cclxuICAgIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XHJcbiAgICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XHJcbiAgICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XHJcbiAgICAgICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XHJcbiAgICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzcyA/IGFwcGVhckNsYXNzIDogZW50ZXJDbGFzcztcclxuICAgIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzO1xyXG4gICAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcztcclxuICAgIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhciA/IGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlciA6IGJlZm9yZUVudGVyO1xyXG4gICAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyID8gKGlzRnVuY3Rpb24oYXBwZWFyKSA/IGFwcGVhciA6IGVudGVyKSA6IGVudGVyO1xyXG4gICAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXIgPyBhZnRlckFwcGVhciB8fCBhZnRlckVudGVyIDogYWZ0ZXJFbnRlcjtcclxuICAgIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxyXG4gICAgICAgID8gYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkXHJcbiAgICAgICAgOiBlbnRlckNhbmNlbGxlZDtcclxuICAgIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihpc09iamVjdChkdXJhdGlvbikgPyBkdXJhdGlvbi5lbnRlciA6IGR1cmF0aW9uKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XHJcbiAgICAgICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcclxuICAgIH1cclxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XHJcbiAgICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcclxuICAgIHZhciBjYiA9IChlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuX2VudGVyQ2IgPSBudWxsO1xyXG4gICAgfSkpO1xyXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcclxuICAgICAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxyXG4gICAgICAgICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXHJcbiAgICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcclxuICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcclxuICAgICAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcclxuICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgICBjYigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGxlYXZlKHZub2RlLCBybSkge1xyXG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gICAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcclxuICAgIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcclxuICAgICAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIGVsLl9lbnRlckNiKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XHJcbiAgICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICAgIHJldHVybiBybSgpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGNzcyA9IGRhdGEuY3NzLCB0eXBlID0gZGF0YS50eXBlLCBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzLCBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcywgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcywgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlLCBsZWF2ZSA9IGRhdGEubGVhdmUsIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmUsIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZCwgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZSwgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xyXG4gICAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcclxuICAgIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XHJcbiAgICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoaXNPYmplY3QoZHVyYXRpb24pID8gZHVyYXRpb24ubGVhdmUgOiBkdXJhdGlvbik7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XHJcbiAgICAgICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcclxuICAgIH1cclxuICAgIHZhciBjYiA9IChlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcclxuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBybSgpO1xyXG4gICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XHJcbiAgICB9KSk7XHJcbiAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlKCkge1xyXG4gICAgICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcclxuICAgICAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVt2bm9kZS5rZXldID1cclxuICAgICAgICAgICAgICAgIHZub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XHJcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xyXG4gICAgICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgICAgICBjYigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcclxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbih2YWwsIG5hbWUsIHZub2RlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB3YXJuJDIoXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIuY29uY2F0KG5hbWUsIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiKSArXHJcbiAgICAgICAgICAgIFwiZ290IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWwpLCBcIi5cIiksIHZub2RlLmNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgIHdhcm4kMihcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIi5jb25jYXQobmFtZSwgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIpICtcclxuICAgICAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24odmFsKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbCk7XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxyXG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcclxuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXHJcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcclxuICovXHJcbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZm4pIHtcclxuICAgIGlmIChpc1VuZGVmKGZuKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xyXG4gICAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XHJcbiAgICAgICAgLy8gaW52b2tlclxyXG4gICAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKEFycmF5LmlzQXJyYXkoaW52b2tlckZucykgPyBpbnZva2VyRm5zWzBdIDogaW52b2tlckZucyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9lbnRlcihfLCB2bm9kZSkge1xyXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIGVudGVyKHZub2RlKTtcclxuICAgIH1cclxufVxyXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlclxyXG4gICAgPyB7XHJcbiAgICAgICAgY3JlYXRlOiBfZW50ZXIsXHJcbiAgICAgICAgYWN0aXZhdGU6IF9lbnRlcixcclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICh2bm9kZSwgcm0pIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgICAgICAgICAgbGVhdmUodm5vZGUsIHJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJtKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA6IHt9O1xyXG5cclxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFthdHRycywga2xhc3MkMSwgZXZlbnRzLCBkb21Qcm9wcywgc3R5bGUkMSwgdHJhbnNpdGlvbl07XHJcblxyXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcclxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cclxudmFyIG1vZHVsZXMkMSA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xyXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyQxIH0pO1xyXG5cclxuLyoqXHJcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xyXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbmlmIChpc0lFOSkge1xyXG4gICAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG52YXIgZGlyZWN0aXZlID0ge1xyXG4gICAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XHJcbiAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgLy8gIzY5MDNcclxuICAgICAgICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xyXG4gICAgICAgICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xyXG4gICAgICAgICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcclxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcclxuICAgICAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxyXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgIGlmIChpc0lFOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXHJcbiAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cclxuICAgICAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXHJcbiAgICAgICAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxyXG4gICAgICAgICAgICB2YXIgcHJldk9wdGlvbnNfMSA9IGVsLl92T3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIGN1ck9wdGlvbnNfMSA9IChlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSkpO1xyXG4gICAgICAgICAgICBpZiAoY3VyT3B0aW9uc18xLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zXzFbaV0pOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcclxuICAgICAgICAgICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcclxuICAgICAgICAgICAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zXzEpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnNfMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pIHtcclxuICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSkge1xyXG4gICAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcclxuICAgIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XHJcbiAgICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIuY29uY2F0KGJpbmRpbmcuZXhwcmVzc2lvbiwgXCJcXFwiPiBcIikgK1xyXG4gICAgICAgICAgICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIi5jb25jYXQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSg4LCAtMSkpLCB2bSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHNlbGVjdGVkLCBvcHRpb247XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcclxuICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbih2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VmFsdWUob3B0aW9uKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uID8gb3B0aW9uLl92YWx1ZSA6IG9wdGlvbi52YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xyXG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcclxuICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXHJcbiAgICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcclxuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG5cclxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxyXG5mdW5jdGlvbiBsb2NhdGVOb2RlKHZub2RlKSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXHJcbiAgICAgICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcclxuICAgICAgICA6IHZub2RlO1xyXG59XHJcbnZhciBzaG93ID0ge1xyXG4gICAgYmluZDogZnVuY3Rpb24gKGVsLCBfYSwgdm5vZGUpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcclxuICAgICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IChlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWwsIF9hLCB2bm9kZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBvbGRWYWx1ZSA9IF9hLm9sZFZhbHVlO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XHJcbiAgICAgICAgaWYgKCFpc0Rlc3Ryb3kpIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xyXG4gICAgbW9kZWw6IGRpcmVjdGl2ZSxcclxuICAgIHNob3c6IHNob3dcclxufTtcclxuXHJcbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXHJcbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICBhcHBlYXI6IEJvb2xlYW4sXHJcbiAgICBjc3M6IEJvb2xlYW4sXHJcbiAgICBtb2RlOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBlbnRlckNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXHJcbn07XHJcbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxyXG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxyXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQodm5vZGUpIHtcclxuICAgIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhKGNvbXApIHtcclxuICAgIHZhciBkYXRhID0ge307XHJcbiAgICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XHJcbiAgICAvLyBwcm9wc1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XHJcbiAgICAgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xyXG4gICAgfVxyXG4gICAgLy8gZXZlbnRzLlxyXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGxpc3RlbmVycykge1xyXG4gICAgICAgIGRhdGFbY2FtZWxpemUoa2V5KV0gPSBsaXN0ZW5lcnNba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XHJcbiAgICAgICAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24odm5vZGUpIHtcclxuICAgIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSB7XHJcbiAgICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWc7XHJcbn1cclxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xyXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcclxudmFyIFRyYW5zaXRpb24gPSB7XHJcbiAgICBuYW1lOiAndHJhbnNpdGlvbicsXHJcbiAgICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxyXG4gICAgYWJzdHJhY3Q6IHRydWUsXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xyXG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxyXG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgd2FybiQyKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXHJcbiAgICAgICAgICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLCB0aGlzLiRwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcclxuICAgICAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbicpIHtcclxuICAgICAgICAgICAgd2FybiQyKCdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSwgdGhpcy4kcGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xyXG4gICAgICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxyXG4gICAgICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxyXG4gICAgICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcclxuICAgICAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghY2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJhd0NoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbGVhdmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcclxuICAgICAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXHJcbiAgICAgICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIuY29uY2F0KHRoaXMuX3VpZCwgXCItXCIpO1xyXG4gICAgICAgIGNoaWxkLmtleSA9XHJcbiAgICAgICAgICAgIGNoaWxkLmtleSA9PSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IGNoaWxkLmlzQ29tbWVudFxyXG4gICAgICAgICAgICAgICAgICAgID8gaWQgKyAnY29tbWVudCdcclxuICAgICAgICAgICAgICAgICAgICA6IGlkICsgY2hpbGQudGFnXHJcbiAgICAgICAgICAgICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcclxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hpbGQua2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaWQgKyBjaGlsZC5rZXlcclxuICAgICAgICAgICAgICAgICAgICA6IGNoaWxkLmtleTtcclxuICAgICAgICB2YXIgZGF0YSA9ICgoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9XHJcbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKSk7XHJcbiAgICAgICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XHJcbiAgICAgICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcclxuICAgICAgICAvLyBtYXJrIHYtc2hvd1xyXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxyXG4gICAgICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcclxuICAgICAgICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9sZENoaWxkICYmXHJcbiAgICAgICAgICAgIG9sZENoaWxkLmRhdGEgJiZcclxuICAgICAgICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcclxuICAgICAgICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcclxuICAgICAgICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcclxuICAgICAgICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAgICAgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudCkpIHtcclxuICAgICAgICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcclxuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsYXllZExlYXZlXzE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ZWRMZWF2ZV8xKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlXzEgPSBsZWF2ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYXdDaGlsZDtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cclxudmFyIHByb3BzID0gZXh0ZW5kKHtcclxuICAgIHRhZzogU3RyaW5nLFxyXG4gICAgbW92ZUNsYXNzOiBTdHJpbmdcclxufSwgdHJhbnNpdGlvblByb3BzKTtcclxuZGVsZXRlIHByb3BzLm1vZGU7XHJcbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XHJcbiAgICBwcm9wczogcHJvcHMsXHJcbiAgICBiZWZvcmVNb3VudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcclxuICAgICAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UoX3RoaXMpO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXHJcbiAgICAgICAgICAgIF90aGlzLl9fcGF0Y2hfXyhfdGhpcy5fdm5vZGUsIF90aGlzLmtlcHQsIGZhbHNlLCAvLyBoeWRyYXRpbmdcclxuICAgICAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIF90aGlzLl92bm9kZSA9IF90aGlzLmtlcHQ7XHJcbiAgICAgICAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB1cGRhdGUuY2FsbChfdGhpcywgdm5vZGUsIGh5ZHJhdGluZyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcclxuICAgICAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gKHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSAodGhpcy5jaGlsZHJlbiA9IFtdKTtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoYy50YWcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXBbYy5rZXldID0gYztcclxuICAgICAgICAgICAgICAgICAgICAoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gb3B0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWUob3B0cy5DdG9yLm9wdGlvbnMpIHx8IG9wdHMudGFnIHx8ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYy50YWc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIi5jb25jYXQobmFtZV8xLCBcIj5cIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdmFyIGtlcHQgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gcHJldkNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgYy5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLmdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBub3QgdHlwZWQgaW4gTm9kZVxyXG4gICAgICAgICAgICAgICAgYy5kYXRhLnBvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcFtjLmtleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXB0LnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XHJcbiAgICAgICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZSc7XHJcbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcclxuICAgICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xyXG4gICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxfMSA9IGMuZWxtO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBlbF8xLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsXzEsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcclxuICAgICAgICAgICAgICAgIGVsXzEuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIChlbF8xLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsXzEucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxfMS5fbW92ZUNiID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsXzEsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGhhc01vdmU6IGZ1bmN0aW9uIChlbCwgbW92ZUNsYXNzKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xyXG4gICAgICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcclxuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxyXG4gICAgICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcclxuICAgICAgICAgICAgLy8gaXMgYXBwbGllZC5cclxuICAgICAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XHJcbiAgICAgICAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcclxuICAgICAgICBjLmVsbS5fbW92ZUNiKCk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChjLmVsbS5fZW50ZXJDYikge1xyXG4gICAgICAgIGMuZWxtLl9lbnRlckNiKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xyXG4gICAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xyXG4gICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XHJcbiAgICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcclxuICAgIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcclxuICAgIGlmIChkeCB8fCBkeSkge1xyXG4gICAgICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGR4LCBcInB4LFwiKS5jb25jYXQoZHksIFwicHgpXCIpO1xyXG4gICAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcclxuICAgIH1cclxufVxyXG5cclxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcclxuICAgIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXHJcbiAgICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxyXG59O1xyXG5cclxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xyXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XHJcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XHJcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcclxuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XHJcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xyXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcclxuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cclxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XHJcbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcclxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwsIGh5ZHJhdGluZykge1xyXG4gICAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZyk7XHJcbn07XHJcbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmIChpbkJyb3dzZXIpIHtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcclxuICAgICAgICAgICAgaWYgKGRldnRvb2xzKSB7XHJcbiAgICAgICAgICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcclxuICAgICAgICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcclxuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcclxuICAgICAgICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgMCk7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZztcclxudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xyXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xyXG4gICAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xyXG4gICAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpO1xyXG59KTtcclxuZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpIHtcclxuICAgIC8vQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XHJcbiAgICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgdG9rZW5zID0gW107XHJcbiAgICB2YXIgcmF3VG9rZW5zID0gW107XHJcbiAgICB2YXIgbGFzdEluZGV4ID0gKHRhZ1JFLmxhc3RJbmRleCA9IDApO1xyXG4gICAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcclxuICAgIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xyXG4gICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XHJcbiAgICAgICAgLy8gcHVzaCB0ZXh0IHRva2VuXHJcbiAgICAgICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgIHJhd1Rva2Vucy5wdXNoKCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xyXG4gICAgICAgICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRhZyB0b2tlblxyXG4gICAgICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcclxuICAgICAgICB0b2tlbnMucHVzaChcIl9zKFwiLmNvbmNhdChleHAsIFwiKVwiKSk7XHJcbiAgICAgICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XHJcbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgICByYXdUb2tlbnMucHVzaCgodG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xyXG4gICAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcclxuICAgICAgICB0b2tlbnM6IHJhd1Rva2Vuc1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxKGVsLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICAgIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcclxuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xyXG4gICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgd2FybihcImNsYXNzPVxcXCJcIi5jb25jYXQoc3RhdGljQ2xhc3MsIFwiXFxcIjogXCIpICtcclxuICAgICAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXHJcbiAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJywgZWwucmF3QXR0cnNNYXBbJ2NsYXNzJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzdGF0aWNDbGFzcykge1xyXG4gICAgICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XHJcbiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7XHJcbiAgICAgICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkRhdGEkMihlbCkge1xyXG4gICAgdmFyIGRhdGEgPSAnJztcclxuICAgIGlmIChlbC5zdGF0aWNDbGFzcykge1xyXG4gICAgICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIi5jb25jYXQoZWwuc3RhdGljQ2xhc3MsIFwiLFwiKTtcclxuICAgIH1cclxuICAgIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcclxuICAgICAgICBkYXRhICs9IFwiY2xhc3M6XCIuY29uY2F0KGVsLmNsYXNzQmluZGluZywgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxudmFyIGtsYXNzID0ge1xyXG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxyXG4gICAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxyXG4gICAgZ2VuRGF0YTogZ2VuRGF0YSQyXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlKGVsLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICAgIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xyXG4gICAgaWYgKHN0YXRpY1N0eWxlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcclxuICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgd2FybihcInN0eWxlPVxcXCJcIi5jb25jYXQoc3RhdGljU3R5bGUsIFwiXFxcIjogXCIpICtcclxuICAgICAgICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJywgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcclxuICAgIH1cclxuICAgIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcclxuICAgIGlmIChzdHlsZUJpbmRpbmcpIHtcclxuICAgICAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuRGF0YSQxKGVsKSB7XHJcbiAgICB2YXIgZGF0YSA9ICcnO1xyXG4gICAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XHJcbiAgICAgICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiLmNvbmNhdChlbC5zdGF0aWNTdHlsZSwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsLnN0eWxlQmluZGluZykge1xyXG4gICAgICAgIGRhdGEgKz0gXCJzdHlsZTooXCIuY29uY2F0KGVsLnN0eWxlQmluZGluZywgXCIpLFwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcbnZhciBzdHlsZSA9IHtcclxuICAgIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcclxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXHJcbiAgICBnZW5EYXRhOiBnZW5EYXRhJDFcclxufTtcclxuXHJcbnZhciBkZWNvZGVyO1xyXG52YXIgaGUgPSB7XHJcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50O1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKCdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcclxuICAgICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicicpO1xyXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cclxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxyXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnKTtcclxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xyXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcclxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKCdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXHJcbiAgICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xyXG4gICAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xyXG4gICAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcclxuICAgICd0aXRsZSx0cix0cmFjaycpO1xyXG5cclxuLyoqXHJcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxyXG4gKi9cclxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXHJcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcclxudmFyIGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dKz9cXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xyXG52YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIi5jb25jYXQodW5pY29kZVJlZ0V4cC5zb3VyY2UsIFwiXSpcIik7XHJcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIi5jb25jYXQobmNuYW1lLCBcIlxcXFw6KT9cIikuY29uY2F0KG5jbmFtZSwgXCIpXCIpO1xyXG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cChcIl48XCIuY29uY2F0KHFuYW1lQ2FwdHVyZSkpO1xyXG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xyXG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cChcIl48XFxcXC9cIi5jb25jYXQocW5hbWVDYXB0dXJlLCBcIltePl0qPlwiKSk7XHJcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XHJcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXHJcbnZhciBjb21tZW50ID0gL148IVxcLS0vO1xyXG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XHJcbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxyXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XHJcbnZhciByZUNhY2hlID0ge307XHJcbnZhciBkZWNvZGluZ01hcCA9IHtcclxuICAgICcmbHQ7JzogJzwnLFxyXG4gICAgJyZndDsnOiAnPicsXHJcbiAgICAnJnF1b3Q7JzogJ1wiJyxcclxuICAgICcmYW1wOyc6ICcmJyxcclxuICAgICcmIzEwOyc6ICdcXG4nLFxyXG4gICAgJyYjOTsnOiAnXFx0JyxcclxuICAgICcmIzM5Oyc6IFwiJ1wiXHJcbn07XHJcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcclxudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcclxuLy8gIzU5OTJcclxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xyXG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkge1xyXG4gICAgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJztcclxufTtcclxuZnVuY3Rpb24gZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcclxuICAgIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcclxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VIVE1MKGh0bWwsIG9wdGlvbnMpIHtcclxuICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XHJcbiAgICB2YXIgaXNVbmFyeVRhZyA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcclxuICAgIHZhciBjYW5CZUxlZnRPcGVuVGFnID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIHZhciBsYXN0LCBsYXN0VGFnO1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGFzdCA9IGh0bWw7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcclxuICAgICAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xyXG4gICAgICAgICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCAmJiBvcHRpb25zLmNvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcclxuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRG9jdHlwZTpcclxuICAgICAgICAgICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEVuZCB0YWc6XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRhZzpcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHZvaWQgMCwgcmVzdCA9IHZvaWQgMCwgbmV4dCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWVuZFRhZy50ZXN0KHJlc3QpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0IDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGh0bWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZW5kVGFnTGVuZ3RoXzEgPSAwO1xyXG4gICAgICAgICAgICB2YXIgc3RhY2tlZFRhZ18xID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXzFdIHx8XHJcbiAgICAgICAgICAgICAgICAocmVDYWNoZVtzdGFja2VkVGFnXzFdID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnXzEgKyAnW14+XSo+KScsICdpJykpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xyXG4gICAgICAgICAgICAgICAgZW5kVGFnTGVuZ3RoXzEgPSBlbmRUYWcubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZ18xKSAmJiBzdGFja2VkVGFnXzEgIT09ICdub3NjcmlwdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnXzEsIHRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICBodG1sID0gcmVzdDtcclxuICAgICAgICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZ18xLCBpbmRleCAtIGVuZFRhZ0xlbmd0aF8xLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChodG1sID09PSBsYXN0KSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMud2FybihcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiLmNvbmNhdChodG1sLCBcIlxcXCJcIiksIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgd2hpbGUgKGh0bWwpIHtcclxuICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoKTtcclxuICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xyXG4gICAgcGFyc2VFbmRUYWcoKTtcclxuICAgIGZ1bmN0aW9uIGFkdmFuY2Uobikge1xyXG4gICAgICAgIGluZGV4ICs9IG47XHJcbiAgICAgICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZygpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XHJcbiAgICAgICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHtcclxuICAgICAgICAgICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxyXG4gICAgICAgICAgICAgICAgYXR0cnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IHZvaWQgMCwgYXR0ciA9IHZvaWQgMDtcclxuICAgICAgICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiZcclxuICAgICAgICAgICAgICAgIChhdHRyID0gaHRtbC5tYXRjaChkeW5hbWljQXJnQXR0cmlidXRlKSB8fCBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyLnN0YXJ0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGF0dHIuZW5kID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XHJcbiAgICAgICAgICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyhtYXRjaCkge1xyXG4gICAgICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcclxuICAgICAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XHJcbiAgICAgICAgaWYgKGV4cGVjdEhUTUwpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcclxuICAgICAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcclxuICAgICAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XHJcbiAgICAgICAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcclxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcclxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcclxuICAgICAgICAgICAgYXR0cnNbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdW5hcnkpIHtcclxuICAgICAgICAgICAgc3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0YWc6IHRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICBhdHRyczogYXR0cnMsXHJcbiAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoLmVuZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXg7XHJcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKVxyXG4gICAgICAgICAgICBlbmQgPSBpbmRleDtcclxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICAgIGlmICh0YWdOYW1lKSB7XHJcbiAgICAgICAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcclxuICAgICAgICAgICAgcG9zID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvcyA+PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiYgb3B0aW9ucy53YXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy53YXJuKFwidGFnIDxcIi5jb25jYXQoc3RhY2tbaV0udGFnLCBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFja1tpXS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzdGFja1tpXS5lbmRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcclxuICAgICAgICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcclxudmFyIGRpclJFID0gL152LXxeQHxeOnxeIy87XHJcbnZhciBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xyXG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcclxudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XHJcbnZhciBkeW5hbWljQXJnUkUgPSAvXlxcWy4qXFxdJC87XHJcbnZhciBhcmdSRSA9IC86KC4qKSQvO1xyXG52YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xyXG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xyXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XHJcbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XHJcbnZhciB3aGl0ZXNwYWNlUkUgPSAvWyBcXGZcXHRcXHJcXG5dKy9nO1xyXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcclxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcclxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcclxuLy8gY29uZmlndXJhYmxlIHN0YXRlXHJcbnZhciB3YXJuO1xyXG52YXIgZGVsaW1pdGVycztcclxudmFyIHRyYW5zZm9ybXM7XHJcbnZhciBwcmVUcmFuc2Zvcm1zO1xyXG52YXIgcG9zdFRyYW5zZm9ybXM7XHJcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xyXG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcclxudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xyXG52YXIgbWF5YmVDb21wb25lbnQ7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgcGFyZW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEsXHJcbiAgICAgICAgdGFnOiB0YWcsXHJcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcclxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcclxuICAgICAgICByYXdBdHRyc01hcDoge30sXHJcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XHJcbiAgICB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xyXG4gICAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XHJcbiAgICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcclxuICAgIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XHJcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcclxuICAgIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKGVsLmNvbXBvbmVudCB8fFxyXG4gICAgICAgICAgICBlbC5hdHRyc01hcFsnOmlzJ10gfHxcclxuICAgICAgICAgICAgZWwuYXR0cnNNYXBbJ3YtYmluZDppcyddIHx8XHJcbiAgICAgICAgICAgICEoZWwuYXR0cnNNYXAuaXMgPyBpc1Jlc2VydmVkVGFnKGVsLmF0dHJzTWFwLmlzKSA6IGlzUmVzZXJ2ZWRUYWcoZWwudGFnKSkpO1xyXG4gICAgfTtcclxuICAgIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcclxuICAgIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcclxuICAgIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xyXG4gICAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcclxuICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcclxuICAgIHZhciB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xyXG4gICAgdmFyIHJvb3Q7XHJcbiAgICB2YXIgY3VycmVudFBhcmVudDtcclxuICAgIHZhciBpblZQcmUgPSBmYWxzZTtcclxuICAgIHZhciBpblByZSA9IGZhbHNlO1xyXG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gd2Fybk9uY2UobXNnLCByYW5nZSkge1xyXG4gICAgICAgIGlmICghd2FybmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHdhcm4obXNnLCByYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xvc2VFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcclxuICAgICAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcclxuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxyXG4gICAgICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcclxuICAgICAgICAgICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuT25jZShcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCIsIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzY29wZWQgc2xvdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVfMV0gPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcclxuICAgICAgICAvLyBmaWx0ZXIgb3V0IHNjb3BlZCBzbG90c1xyXG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIWMuc2xvdFNjb3BlOyB9KTtcclxuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXHJcbiAgICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XHJcbiAgICAgICAgLy8gY2hlY2sgcHJlIHN0YXRlXHJcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XHJcbiAgICAgICAgICAgIGluVlByZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcclxuICAgICAgICAgICAgaW5QcmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZShlbCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcclxuICAgICAgICBpZiAoIWluUHJlKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgd2hpbGUgKChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxyXG4gICAgICAgICAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxyXG4gICAgICAgICAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcIkNhbm5vdCB1c2UgPFwiLmNvbmNhdChlbC50YWcsIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiKSArXHJcbiAgICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLCB7IHN0YXJ0OiBlbC5zdGFydCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XHJcbiAgICAgICAgICAgIHdhcm5PbmNlKCdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcclxuICAgICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcclxuICAgICAgICB3YXJuOiB3YXJuLFxyXG4gICAgICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcclxuICAgICAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXHJcbiAgICAgICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxyXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxyXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXHJcbiAgICAgICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXHJcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXHJcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICAgICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcclxuICAgICAgICAgICAgaWYgKG5zKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5zID0gbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGN1bXVsYXRlZCwgYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIiwgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihcIltcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8XCIuY29uY2F0KHRhZywgXCI+XCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJywgeyBzdGFydDogZWxlbWVudC5zdGFydCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpblZQcmUpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpblZQcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgaW5QcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpblZQcmUpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdW5hcnkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kOiBmdW5jdGlvbiAodGFnLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIC8vIHBvcCBzdGFja1xyXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGFyczogZnVuY3Rpb24gKHRleHQsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuT25jZSgnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJywgeyBzdGFydDogc3RhcnQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5PbmNlKFwidGV4dCBcXFwiXCIuY29uY2F0KHRleHQsIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKGlzSUUgJiZcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcclxuICAgICAgICAgICAgICAgIHRleHQgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBub2RlIGlmIGl0IGNvbnRhaW5zXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5QcmUgJiYgd2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlUkUsICcgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWNoaWxkcmVuLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tbWVudDogZnVuY3Rpb24gKHRleHQsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxyXG4gICAgICAgICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNDb21tZW50OiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvb3Q7XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc1ByZShlbCkge1xyXG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcclxuICAgICAgICBlbC5wcmUgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyhlbCkge1xyXG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XHJcbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XHJcbiAgICBpZiAobGVuKSB7XHJcbiAgICAgICAgdmFyIGF0dHJzID0gKGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbikpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYXR0cnNbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZWwucHJlKSB7XHJcbiAgICAgICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xyXG4gICAgICAgIGVsLnBsYWluID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xyXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcclxuICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xyXG4gICAgZWxlbWVudC5wbGFpbiA9XHJcbiAgICAgICAgIWVsZW1lbnQua2V5ICYmICFlbGVtZW50LnNjb3BlZFNsb3RzICYmICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGg7XHJcbiAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xyXG4gICAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xyXG4gICAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XHJcbiAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcclxuICAgIH1cclxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NLZXkoZWwpIHtcclxuICAgIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xyXG4gICAgaWYgKGV4cCkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbC5mb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBlbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IgJiZcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9PT0gZXhwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50XzEgJiZcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMS50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLlwiLCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLCB0cnVlIC8qIHRpcCAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWwua2V5ID0gZXhwO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWYoZWwpIHtcclxuICAgIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xyXG4gICAgaWYgKHJlZikge1xyXG4gICAgICAgIGVsLnJlZiA9IHJlZjtcclxuICAgICAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3IoZWwpIHtcclxuICAgIHZhciBleHA7XHJcbiAgICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xyXG4gICAgICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xyXG4gICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKGVsLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiLmNvbmNhdChleHApLCBlbC5yYXdBdHRyc01hcFsndi1mb3InXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRm9yKGV4cCkge1xyXG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgICBpZiAoIWluTWF0Y2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XHJcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xyXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcclxuICAgICAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XHJcbiAgICAgICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXMuYWxpYXMgPSBhbGlhcztcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc0lmKGVsKSB7XHJcbiAgICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcclxuICAgIGlmIChleHApIHtcclxuICAgICAgICBlbC5pZiA9IGV4cDtcclxuICAgICAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xyXG4gICAgICAgICAgICBleHA6IGV4cCxcclxuICAgICAgICAgICAgYmxvY2s6IGVsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZWwuZWxzZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XHJcbiAgICAgICAgaWYgKGVsc2VpZikge1xyXG4gICAgICAgICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWwsIHBhcmVudCkge1xyXG4gICAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcclxuICAgIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcclxuICAgICAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XHJcbiAgICAgICAgICAgIGV4cDogZWwuZWxzZWlmLFxyXG4gICAgICAgICAgICBibG9jazogZWxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuKFwidi1cIi5jb25jYXQoZWwuZWxzZWlmID8gJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJyA6ICdlbHNlJywgXCIgXCIpICtcclxuICAgICAgICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiLmNvbmNhdChlbC50YWcsIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIiksIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQoY2hpbGRyZW4pIHtcclxuICAgIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgd2FybihcInRleHQgXFxcIlwiLmNvbmNhdChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSwgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIpICtcclxuICAgICAgICAgICAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIiwgY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkcmVuLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbihlbCwgY29uZGl0aW9uKSB7XHJcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzT25jZShlbCkge1xyXG4gICAgdmFyIG9uY2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XHJcbiAgICBpZiAob25jZSAhPSBudWxsKSB7XHJcbiAgICAgICAgZWwub25jZSA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXHJcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQoZWwpIHtcclxuICAgIHZhciBzbG90U2NvcGU7XHJcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLCBlbC5yYXdBdHRyc01hcFsnc2NvcGUnXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcclxuICAgICAgICAgICAgd2FybihcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIuY29uY2F0KGVsLnRhZywgXCI+IFwiKSArXHJcbiAgICAgICAgICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXHJcbiAgICAgICAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIiwgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcclxuICAgIH1cclxuICAgIC8vIHNsb3Q9XCJ4eHhcIlxyXG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcclxuICAgIGlmIChzbG90VGFyZ2V0KSB7XHJcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xyXG4gICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xyXG4gICAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcclxuICAgICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxyXG4gICAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xyXG4gICAgICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAyLjYgdi1zbG90IHN5bnRheFxyXG4gICAge1xyXG4gICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cclxuICAgICAgICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XHJcbiAgICAgICAgICAgIGlmIChzbG90QmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyksIG5hbWVfMiA9IF9hLm5hbWUsIGR5bmFtaWMgPSBfYS5keW5hbWljO1xyXG4gICAgICAgICAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWVfMjtcclxuICAgICAgICAgICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcclxuICAgICAgICAgICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxyXG4gICAgICAgICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcclxuICAgICAgICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJ2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uXCIsIHNsb3RCaW5kaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLCBlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLCBzbG90QmluZGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiB0byBpdHMgZGVmYXVsdCBzbG90XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyksIG5hbWVfMyA9IF9iLm5hbWUsIGR5bmFtaWMgPSBfYi5keW5hbWljO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RDb250YWluZXJfMSA9IChzbG90c1tuYW1lXzNdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpKTtcclxuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXJfMS5zbG90VGFyZ2V0ID0gbmFtZV8zO1xyXG4gICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lcl8xLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcclxuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXJfMS5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lcl8xLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gYXMgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSBzY29wZWRTbG90cyBub3dcclxuICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXHJcbiAgICAgICAgICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFNsb3ROYW1lKGJpbmRpbmcpIHtcclxuICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcclxuICAgICAgICAgICAgbmFtZSA9ICdkZWZhdWx0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuKFwidi1zbG90IHNob3J0aGFuZCBzeW50YXggcmVxdWlyZXMgYSBzbG90IG5hbWUuXCIsIGJpbmRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkeW5hbWljQXJnUkUudGVzdChuYW1lKVxyXG4gICAgICAgID8gLy8gZHluYW1pYyBbbmFtZV1cclxuICAgICAgICAgICAgeyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XHJcbiAgICAgICAgOiAvLyBzdGF0aWMgbmFtZVxyXG4gICAgICAgICAgICB7IG5hbWU6IFwiXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH07XHJcbn1cclxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldChlbCkge1xyXG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcclxuICAgICAgICAgICAgd2FybihcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXHJcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudChlbCkge1xyXG4gICAgdmFyIGJpbmRpbmc7XHJcbiAgICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XHJcbiAgICAgICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcclxuICAgIH1cclxuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xyXG4gICAgICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMoZWwpIHtcclxuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xyXG4gICAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcclxuICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xyXG4gICAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcclxuICAgICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xyXG4gICAgICAgICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIG1vZGlmaWVyc1xyXG4gICAgICAgICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XHJcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2LWJpbmRcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihcIlRoZSB2YWx1ZSBmb3IgYSB2LWJpbmQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZW1wdHkuIEZvdW5kIGluIFxcXCJ2LWJpbmQ6XCIuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ2lubmVySFRNTCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSGFuZGxlcihlbCwgXCJ1cGRhdGU6XCIuY29uY2F0KGNhbWVsaXplKG5hbWUpKSwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBcInVwZGF0ZTpcIi5jb25jYXQoaHlwaGVuYXRlKG5hbWUpKSwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoZWwsIFwiXFxcInVwZGF0ZTpcXFwiKyhcIi5jb25jYXQobmFtZSwgXCIpXCIpLCBzeW5jR2VuLCBudWxsLCBmYWxzZSwgd2FybiwgbGlzdFtpXSwgdHJ1ZSAvLyBkeW5hbWljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2LW9uXHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcclxuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcclxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGFyZ1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChhcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJcIi5jb25jYXQobmFtZSwgXCI9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIjogXCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJywgbGlzdFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cclxuICAgICAgICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcclxuICAgICAgICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja0luRm9yKGVsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gZWw7XHJcbiAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyhuYW1lKSB7XHJcbiAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgdmFyIHJldF8xID0ge307XHJcbiAgICAgICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICByZXRfMVttLnNsaWNlKDEpXSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJldF8xO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1ha2VBdHRyc01hcChhdHRycykge1xyXG4gICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZSkge1xyXG4gICAgICAgICAgICB3YXJuKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXA7XHJcbn1cclxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XHJcbmZ1bmN0aW9uIGlzVGV4dFRhZyhlbCkge1xyXG4gICAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnO1xyXG59XHJcbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnKGVsKSB7XHJcbiAgICByZXR1cm4gKGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxyXG4gICAgICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmXHJcbiAgICAgICAgICAgICghZWwuYXR0cnNNYXAudHlwZSB8fCBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0JykpKTtcclxufVxyXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcclxudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnKGF0dHJzKSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcclxuICAgICAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcclxuICAgICAgICAgICAgcmVzLnB1c2goYXR0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKSB7XHJcbiAgICB2YXIgX2VsID0gZWw7XHJcbiAgICB3aGlsZSAoX2VsKSB7XHJcbiAgICAgICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB3YXJuKFwiPFwiLmNvbmNhdChlbC50YWcsIFwiIHYtbW9kZWw9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIj46IFwiKSArXHJcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXHJcbiAgICAgICAgICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcclxuICAgICAgICAgICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIiwgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9lbCA9IF9lbC5wYXJlbnQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBhbmQgaW5wdXRbdi1tb2RlbF0gd2l0aCBkeW5hbWljIHR5cGUgYmluZGluZ3MgaW50byB2LWlmLWVsc2UgY2hhaW5zXHJcbiAqIFR1cm4gdGhpczpcclxuICogICA8aW5wdXQgdi1tb2RlbD1cImRhdGFbdHlwZV1cIiA6dHlwZT1cInR5cGVcIj5cclxuICogaW50byB0aGlzOlxyXG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XHJcbiAqICAgPGlucHV0IHYtZWxzZS1pZj1cInR5cGUgPT09ICdyYWRpbydcIiB0eXBlPVwicmFkaW9cIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxyXG4gKiAgIDxpbnB1dCB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cclxuICovXHJcbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUoZWwsIG9wdGlvbnMpIHtcclxuICAgIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcclxuICAgICAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XHJcbiAgICAgICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0eXBlQmluZGluZyA9IHZvaWQgMDtcclxuICAgICAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xyXG4gICAgICAgICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XHJcbiAgICAgICAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIuY29uY2F0KG1hcFsndi1iaW5kJ10sIFwiKS50eXBlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZUJpbmRpbmcpIHtcclxuICAgICAgICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IFwiJiYoXCIuY29uY2F0KGlmQ29uZGl0aW9uLCBcIilcIikgOiBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xyXG4gICAgICAgICAgICAvLyAxLiBjaGVja2JveFxyXG4gICAgICAgICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcclxuICAgICAgICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcclxuICAgICAgICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xyXG4gICAgICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxyXG4gICAgICAgICAgICBicmFuY2gwLmlmID0gXCIoXCIuY29uY2F0KHR5cGVCaW5kaW5nLCBcIik9PT0nY2hlY2tib3gnXCIpICsgaWZDb25kaXRpb25FeHRyYTtcclxuICAgICAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xyXG4gICAgICAgICAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxyXG4gICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxyXG4gICAgICAgICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XHJcbiAgICAgICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcclxuICAgICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcclxuICAgICAgICAgICAgICAgIGV4cDogXCIoXCIuY29uY2F0KHR5cGVCaW5kaW5nLCBcIik9PT0ncmFkaW8nXCIpICsgaWZDb25kaXRpb25FeHRyYSxcclxuICAgICAgICAgICAgICAgIGJsb2NrOiBicmFuY2gxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyAzLiBvdGhlclxyXG4gICAgICAgICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XHJcbiAgICAgICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xyXG4gICAgICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xyXG4gICAgICAgICAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcclxuICAgICAgICAgICAgICAgIGJsb2NrOiBicmFuY2gyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaGFzRWxzZSkge1xyXG4gICAgICAgICAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBicmFuY2gwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQoZWwpIHtcclxuICAgIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudCk7XHJcbn1cclxudmFyIG1vZGVsID0ge1xyXG4gICAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxyXG59O1xyXG5cclxudmFyIG1vZHVsZXMgPSBba2xhc3MsIHN0eWxlLCBtb2RlbF07XHJcblxyXG5mdW5jdGlvbiB0ZXh0KGVsLCBkaXIpIHtcclxuICAgIGlmIChkaXIudmFsdWUpIHtcclxuICAgICAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCBcIl9zKFwiLmNvbmNhdChkaXIudmFsdWUsIFwiKVwiKSwgZGlyKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaHRtbChlbCwgZGlyKSB7XHJcbiAgICBpZiAoZGlyLnZhbHVlKSB7XHJcbiAgICAgICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIFwiX3MoXCIuY29uY2F0KGRpci52YWx1ZSwgXCIpXCIpLCBkaXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgZGlyZWN0aXZlcyA9IHtcclxuICAgIG1vZGVsOiBtb2RlbCQxLFxyXG4gICAgdGV4dDogdGV4dCxcclxuICAgIGh0bWw6IGh0bWxcclxufTtcclxuXHJcbnZhciBiYXNlT3B0aW9ucyA9IHtcclxuICAgIGV4cGVjdEhUTUw6IHRydWUsXHJcbiAgICBtb2R1bGVzOiBtb2R1bGVzLFxyXG4gICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcclxuICAgIGlzUHJlVGFnOiBpc1ByZVRhZyxcclxuICAgIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXHJcbiAgICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXHJcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxyXG4gICAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcclxuICAgIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxyXG4gICAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyQxKG1vZHVsZXMpXHJcbn07XHJcblxyXG52YXIgaXNTdGF0aWNLZXk7XHJcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XHJcbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMpO1xyXG4vKipcclxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcclxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxyXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxyXG4gKlxyXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcclxuICpcclxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xyXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XHJcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxyXG4gKi9cclxuZnVuY3Rpb24gb3B0aW1pemUocm9vdCwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFyb290KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xyXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xyXG4gICAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cclxuICAgIG1hcmtTdGF0aWMocm9vdCk7XHJcbiAgICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXHJcbiAgICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMoa2V5cykge1xyXG4gICAgcmV0dXJuIG1ha2VNYXAoJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXHJcbiAgICAgICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpKTtcclxufVxyXG5mdW5jdGlvbiBtYXJrU3RhdGljKG5vZGUpIHtcclxuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICAgICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXHJcbiAgICAgICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xyXG4gICAgICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcclxuICAgICAgICBpZiAoIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcclxuICAgICAgICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxyXG4gICAgICAgICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBtYXJrU3RhdGljKGNoaWxkKTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaztcclxuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWMoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyhub2RlLCBpc0luRm9yKSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICAgICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xyXG4gICAgICAgICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcclxuICAgICAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxyXG4gICAgICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cclxuICAgICAgICBpZiAobm9kZS5zdGF0aWMgJiZcclxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcclxuICAgICAgICAgICAgIShub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDMpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaywgaXNJbkZvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0aWMobm9kZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMikge1xyXG4gICAgICAgIC8vIGV4cHJlc3Npb25cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAzKSB7XHJcbiAgICAgICAgLy8gdGV4dFxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhKG5vZGUucHJlIHx8XHJcbiAgICAgICAgKCFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcclxuICAgICAgICAgICAgIW5vZGUuaWYgJiZcclxuICAgICAgICAgICAgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxyXG4gICAgICAgICAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxyXG4gICAgICAgICAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkge1xyXG4gICAgd2hpbGUgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmZvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XHJcbnZhciBmbkludm9rZVJFID0gL1xcKFteKV0qP1xcKTsqJC87XHJcbnZhciBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJ1teJ10qPyddfFxcW1wiW15cIl0qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKiQvO1xyXG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xyXG52YXIga2V5Q29kZXMgPSB7XHJcbiAgICBlc2M6IDI3LFxyXG4gICAgdGFiOiA5LFxyXG4gICAgZW50ZXI6IDEzLFxyXG4gICAgc3BhY2U6IDMyLFxyXG4gICAgdXA6IDM4LFxyXG4gICAgbGVmdDogMzcsXHJcbiAgICByaWdodDogMzksXHJcbiAgICBkb3duOiA0MCxcclxuICAgIGRlbGV0ZTogWzgsIDQ2XVxyXG59O1xyXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXHJcbnZhciBrZXlOYW1lcyA9IHtcclxuICAgIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxyXG4gICAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcclxuICAgIHRhYjogJ1RhYicsXHJcbiAgICBlbnRlcjogJ0VudGVyJyxcclxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXHJcbiAgICBzcGFjZTogWycgJywgJ1NwYWNlYmFyJ10sXHJcbiAgICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxyXG4gICAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxyXG4gICAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxyXG4gICAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxyXG4gICAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxyXG4gICAgLy8gIzkxMTI6IElFMTEgdXNlcyBgRGVsYCBmb3IgRGVsZXRlIGtleSBuYW1lLlxyXG4gICAgZGVsZXRlOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cclxufTtcclxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxyXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXHJcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIFwiaWYoXCIuY29uY2F0KGNvbmRpdGlvbiwgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xyXG52YXIgbW9kaWZpZXJDb2RlID0ge1xyXG4gICAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxyXG4gICAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXHJcbiAgICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxyXG4gICAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXHJcbiAgICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxyXG4gICAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxyXG4gICAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXHJcbiAgICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxyXG4gICAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxyXG4gICAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcclxufTtcclxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMoZXZlbnRzLCBpc05hdGl2ZSkge1xyXG4gICAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcclxuICAgIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XHJcbiAgICB2YXIgZHluYW1pY0hhbmRsZXJzID0gXCJcIjtcclxuICAgIGZvciAodmFyIG5hbWVfMSBpbiBldmVudHMpIHtcclxuICAgICAgICB2YXIgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXzFdKTtcclxuICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoZXZlbnRzW25hbWVfMV0gJiYgZXZlbnRzW25hbWVfMV0uZHluYW1pYykge1xyXG4gICAgICAgICAgICBkeW5hbWljSGFuZGxlcnMgKz0gXCJcIi5jb25jYXQobmFtZV8xLCBcIixcIikuY29uY2F0KGhhbmRsZXJDb2RlLCBcIixcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIi5jb25jYXQobmFtZV8xLCBcIlxcXCI6XCIpLmNvbmNhdChoYW5kbGVyQ29kZSwgXCIsXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIuY29uY2F0KHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSwgXCJ9XCIpO1xyXG4gICAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xyXG4gICAgICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiLmNvbmNhdChzdGF0aWNIYW5kbGVycywgXCIsW1wiKS5jb25jYXQoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSwgXCJdKVwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVycztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5IYW5kbGVyKGhhbmRsZXIpIHtcclxuICAgIGlmICghaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24oKXt9JztcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihoYW5kbGVyKTsgfSkuam9pbignLCcpLCBcIl1cIik7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XHJcbiAgICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XHJcbiAgICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcclxuICAgIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcclxuICAgICAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJmdW5jdGlvbigkZXZlbnQpe1wiLmNvbmNhdChpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IFwicmV0dXJuIFwiLmNvbmNhdChoYW5kbGVyLnZhbHVlKSA6IGhhbmRsZXIudmFsdWUsIFwifVwiKTsgLy8gaW5saW5lIHN0YXRlbWVudFxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSAnJztcclxuICAgICAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XHJcbiAgICAgICAgICAgICAgICAvLyBsZWZ0L3JpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyc18xID0gaGFuZGxlci5tb2RpZmllcnM7XHJcbiAgICAgICAgICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc18xW2tleU1vZGlmaWVyXTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gXCIkZXZlbnQuXCIuY29uY2F0KGtleU1vZGlmaWVyLCBcIktleVwiKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuam9pbignfHwnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzEoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xyXG4gICAgICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcclxuICAgICAgICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxyXG4gICAgICAgICAgICA/IFwicmV0dXJuIFwiLmNvbmNhdChoYW5kbGVyLnZhbHVlLCBcIi5hcHBseShudWxsLCBhcmd1bWVudHMpXCIpXHJcbiAgICAgICAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgID8gXCJyZXR1cm4gKFwiLmNvbmNhdChoYW5kbGVyLnZhbHVlLCBcIikuYXBwbHkobnVsbCwgYXJndW1lbnRzKVwiKVxyXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgID8gXCJyZXR1cm4gXCIuY29uY2F0KGhhbmRsZXIudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uKCRldmVudCl7XCIuY29uY2F0KGNvZGUpLmNvbmNhdChoYW5kbGVyQ29kZSwgXCJ9XCIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbktleUZpbHRlcihrZXlzKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXHJcbiAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxyXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cclxuICAgIFwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIiArXHJcbiAgICAgICAgXCJcIi5jb25jYXQoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSwgXCIpcmV0dXJuIG51bGw7XCIpKTtcclxufVxyXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlKGtleSkge1xyXG4gICAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xyXG4gICAgaWYgKGtleVZhbCkge1xyXG4gICAgICAgIHJldHVybiBcIiRldmVudC5rZXlDb2RlIT09XCIuY29uY2F0KGtleVZhbCk7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XHJcbiAgICB2YXIga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XHJcbiAgICByZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xyXG4gICAgICAgIFwiXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGtleSksIFwiLFwiKSArXHJcbiAgICAgICAgXCJcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSksIFwiLFwiKSArXHJcbiAgICAgICAgXCIkZXZlbnQua2V5LFwiICtcclxuICAgICAgICBcIlwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xyXG4gICAgICAgIFwiKVwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb24oZWwsIGRpcikge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xyXG4gICAgICAgIHdhcm4kMihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XHJcbiAgICB9XHJcbiAgICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIFwiX2coXCIuY29uY2F0KGNvZGUsIFwiLFwiKS5jb25jYXQoZGlyLnZhbHVlLCBcIilcIik7IH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJpbmQoZWwsIGRpcikge1xyXG4gICAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgIHJldHVybiBcIl9iKFwiLmNvbmNhdChjb2RlLCBcIiwnXCIpLmNvbmNhdChlbC50YWcsIFwiJyxcIikuY29uY2F0KGRpci52YWx1ZSwgXCIsXCIpLmNvbmNhdChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpLmNvbmNhdChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJywgXCIpXCIpO1xyXG4gICAgfTtcclxufVxyXG5cclxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xyXG4gICAgb246IG9uLFxyXG4gICAgYmluZDogYmluZCxcclxuICAgIGNsb2FrOiBub29wXHJcbn07XHJcblxyXG52YXIgQ29kZWdlblN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29kZWdlblN0YXRlKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcclxuICAgICAgICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XHJcbiAgICAgICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25jZUlkID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xyXG4gICAgICAgIHRoaXMucHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ29kZWdlblN0YXRlO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpIHtcclxuICAgIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XHJcbiAgICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cclxuICAgIHZhciBjb2RlID0gYXN0XHJcbiAgICAgICAgPyBhc3QudGFnID09PSAnc2NyaXB0J1xyXG4gICAgICAgICAgICA/ICdudWxsJ1xyXG4gICAgICAgICAgICA6IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSlcclxuICAgICAgICA6ICdfYyhcImRpdlwiKSc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbmRlcjogXCJ3aXRoKHRoaXMpe3JldHVybiBcIi5jb25jYXQoY29kZSwgXCJ9XCIpLFxyXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdlbkVsZW1lbnQoZWwsIHN0YXRlKSB7XHJcbiAgICBpZiAoZWwucGFyZW50KSB7XHJcbiAgICAgICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xyXG4gICAgICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xyXG4gICAgICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xyXG4gICAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcclxuICAgICAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XHJcbiAgICAgICAgdmFyIGNvZGUgPSB2b2lkIDA7XHJcbiAgICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdm9pZCAwO1xyXG4gICAgICAgICAgICB2YXIgbWF5YmVDb21wb25lbnQgPSBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCk7XHJcbiAgICAgICAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBtYXliZUNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBnZW5EYXRhKGVsLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhZyBcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBpbiA8c2NyaXB0IHNldHVwPlxyXG4gICAgICAgICAgICA9IHZvaWQgMDtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBpbiA8c2NyaXB0IHNldHVwPlxyXG4gICAgICAgICAgICB2YXIgYmluZGluZ3MgPSBzdGF0ZS5vcHRpb25zLmJpbmRpbmdzO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVDb21wb25lbnQgJiYgYmluZGluZ3MgJiYgYmluZGluZ3MuX19pc1NjcmlwdFNldHVwICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGFnID0gY2hlY2tCaW5kaW5nVHlwZShiaW5kaW5ncywgZWwudGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRhZylcclxuICAgICAgICAgICAgICAgIHRhZyA9IFwiJ1wiLmNvbmNhdChlbC50YWcsIFwiJ1wiKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcclxuICAgICAgICAgICAgY29kZSA9IFwiX2MoXCIuY29uY2F0KHRhZykuY29uY2F0KGRhdGEgPyBcIixcIi5jb25jYXQoZGF0YSkgOiAnJyAvLyBkYXRhXHJcbiAgICAgICAgICAgICkuY29uY2F0KGNoaWxkcmVuID8gXCIsXCIuY29uY2F0KGNoaWxkcmVuKSA6ICcnIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICwgXCIpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrQmluZGluZ1R5cGUoYmluZGluZ3MsIGtleSkge1xyXG4gICAgdmFyIGNhbWVsTmFtZSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICB2YXIgUGFzY2FsTmFtZSA9IGNhcGl0YWxpemUoY2FtZWxOYW1lKTtcclxuICAgIHZhciBjaGVja1R5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmIChiaW5kaW5nc1trZXldID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaW5kaW5nc1tjYW1lbE5hbWVdID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW1lbE5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaW5kaW5nc1tQYXNjYWxOYW1lXSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGFzY2FsTmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGZyb21Db25zdCA9IGNoZWNrVHlwZShcInNldHVwLWNvbnN0XCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX0NPTlNUICovKSB8fFxyXG4gICAgICAgIGNoZWNrVHlwZShcInNldHVwLXJlYWN0aXZlLWNvbnN0XCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX1JFQUNUSVZFX0NPTlNUICovKTtcclxuICAgIGlmIChmcm9tQ29uc3QpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUNvbnN0O1xyXG4gICAgfVxyXG4gICAgdmFyIGZyb21NYXliZVJlZiA9IGNoZWNrVHlwZShcInNldHVwLWxldFwiIC8qIEJpbmRpbmdUeXBlcy5TRVRVUF9MRVQgKi8pIHx8XHJcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtcmVmXCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX1JFRiAqLykgfHxcclxuICAgICAgICBjaGVja1R5cGUoXCJzZXR1cC1tYXliZS1yZWZcIiAvKiBCaW5kaW5nVHlwZXMuU0VUVVBfTUFZQkVfUkVGICovKTtcclxuICAgIGlmIChmcm9tTWF5YmVSZWYpIHtcclxuICAgICAgICByZXR1cm4gZnJvbU1heWJlUmVmO1xyXG4gICAgfVxyXG59XHJcbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XHJcbmZ1bmN0aW9uIGdlblN0YXRpYyhlbCwgc3RhdGUpIHtcclxuICAgIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XHJcbiAgICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXHJcbiAgICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xyXG4gICAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cclxuICAgIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xyXG4gICAgaWYgKGVsLnByZSkge1xyXG4gICAgICAgIHN0YXRlLnByZSA9IGVsLnByZTtcclxuICAgIH1cclxuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIuY29uY2F0KGdlbkVsZW1lbnQoZWwsIHN0YXRlKSwgXCJ9XCIpKTtcclxuICAgIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XHJcbiAgICByZXR1cm4gXCJfbShcIi5jb25jYXQoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpLmNvbmNhdChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJywgXCIpXCIpO1xyXG59XHJcbi8vIHYtb25jZVxyXG5mdW5jdGlvbiBnZW5PbmNlKGVsLCBzdGF0ZSkge1xyXG4gICAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XHJcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xyXG4gICAgICAgIHZhciBrZXkgPSAnJztcclxuICAgICAgICB2YXIgcGFyZW50XzEgPSBlbC5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudF8xKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRfMS5mb3IpIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IHBhcmVudF8xLmtleTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudF8xID0gcGFyZW50XzEucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS53YXJuKFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiLCBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ10pO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJfbyhcIi5jb25jYXQoZ2VuRWxlbWVudChlbCwgc3RhdGUpLCBcIixcIikuY29uY2F0KHN0YXRlLm9uY2VJZCsrLCBcIixcIikuY29uY2F0KGtleSwgXCIpXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbklmKGVsLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkge1xyXG4gICAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KTtcclxufVxyXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpIHtcclxuICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcclxuICAgIGlmIChjb25kaXRpb24uZXhwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiKFwiLmNvbmNhdChjb25kaXRpb24uZXhwLCBcIik/XCIpLmNvbmNhdChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jayksIFwiOlwiKS5jb25jYXQoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKTtcclxuICAgIH1cclxuICAgIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcclxuICAgIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAoZWwpIHtcclxuICAgICAgICByZXR1cm4gYWx0R2VuXHJcbiAgICAgICAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcclxuICAgICAgICAgICAgOiBlbC5vbmNlXHJcbiAgICAgICAgICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxyXG4gICAgICAgICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuRm9yKGVsLCBzdGF0ZSwgYWx0R2VuLCBhbHRIZWxwZXIpIHtcclxuICAgIHZhciBleHAgPSBlbC5mb3I7XHJcbiAgICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcclxuICAgIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyBcIixcIi5jb25jYXQoZWwuaXRlcmF0b3IxKSA6ICcnO1xyXG4gICAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IFwiLFwiLmNvbmNhdChlbC5pdGVyYXRvcjIpIDogJyc7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxyXG4gICAgICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXHJcbiAgICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAgICAgIWVsLmtleSkge1xyXG4gICAgICAgIHN0YXRlLndhcm4oXCI8XCIuY29uY2F0KGVsLnRhZywgXCIgdi1mb3I9XFxcIlwiKS5jb25jYXQoYWxpYXMsIFwiIGluIFwiKS5jb25jYXQoZXhwLCBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIikgK1xyXG4gICAgICAgICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcclxuICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly92Mi52dWVqcy5vcmcvdjIvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLCBlbC5yYXdBdHRyc01hcFsndi1mb3InXSwgdHJ1ZSAvKiB0aXAgKi8pO1xyXG4gICAgfVxyXG4gICAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXHJcbiAgICByZXR1cm4gKFwiXCIuY29uY2F0KGFsdEhlbHBlciB8fCAnX2wnLCBcIigoXCIpLmNvbmNhdChleHAsIFwiKSxcIikgK1xyXG4gICAgICAgIFwiZnVuY3Rpb24oXCIuY29uY2F0KGFsaWFzKS5jb25jYXQoaXRlcmF0b3IxKS5jb25jYXQoaXRlcmF0b3IyLCBcIil7XCIpICtcclxuICAgICAgICBcInJldHVybiBcIi5jb25jYXQoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXHJcbiAgICAgICAgJ30pJyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRGF0YShlbCwgc3RhdGUpIHtcclxuICAgIHZhciBkYXRhID0gJ3snO1xyXG4gICAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cclxuICAgIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXHJcbiAgICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcclxuICAgIGlmIChkaXJzKVxyXG4gICAgICAgIGRhdGEgKz0gZGlycyArICcsJztcclxuICAgIC8vIGtleVxyXG4gICAgaWYgKGVsLmtleSkge1xyXG4gICAgICAgIGRhdGEgKz0gXCJrZXk6XCIuY29uY2F0KGVsLmtleSwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gcmVmXHJcbiAgICBpZiAoZWwucmVmKSB7XHJcbiAgICAgICAgZGF0YSArPSBcInJlZjpcIi5jb25jYXQoZWwucmVmLCBcIixcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwucmVmSW5Gb3IpIHtcclxuICAgICAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcclxuICAgIH1cclxuICAgIC8vIHByZVxyXG4gICAgaWYgKGVsLnByZSkge1xyXG4gICAgICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcclxuICAgIH1cclxuICAgIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXHJcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XHJcbiAgICAgICAgZGF0YSArPSBcInRhZzpcXFwiXCIuY29uY2F0KGVsLnRhZywgXCJcXFwiLFwiKTtcclxuICAgIH1cclxuICAgIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xyXG4gICAgfVxyXG4gICAgLy8gYXR0cmlidXRlc1xyXG4gICAgaWYgKGVsLmF0dHJzKSB7XHJcbiAgICAgICAgZGF0YSArPSBcImF0dHJzOlwiLmNvbmNhdChnZW5Qcm9wcyhlbC5hdHRycyksIFwiLFwiKTtcclxuICAgIH1cclxuICAgIC8vIERPTSBwcm9wc1xyXG4gICAgaWYgKGVsLnByb3BzKSB7XHJcbiAgICAgICAgZGF0YSArPSBcImRvbVByb3BzOlwiLmNvbmNhdChnZW5Qcm9wcyhlbC5wcm9wcyksIFwiLFwiKTtcclxuICAgIH1cclxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXHJcbiAgICBpZiAoZWwuZXZlbnRzKSB7XHJcbiAgICAgICAgZGF0YSArPSBcIlwiLmNvbmNhdChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlKSwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xyXG4gICAgICAgIGRhdGEgKz0gXCJcIi5jb25jYXQoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gc2xvdCB0YXJnZXRcclxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcclxuICAgIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcclxuICAgICAgICBkYXRhICs9IFwic2xvdDpcIi5jb25jYXQoZWwuc2xvdFRhcmdldCwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gc2NvcGVkIHNsb3RzXHJcbiAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcclxuICAgICAgICBkYXRhICs9IFwiXCIuY29uY2F0KGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpLCBcIixcIik7XHJcbiAgICB9XHJcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbFxyXG4gICAgaWYgKGVsLm1vZGVsKSB7XHJcbiAgICAgICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIi5jb25jYXQoZWwubW9kZWwudmFsdWUsIFwiLGNhbGxiYWNrOlwiKS5jb25jYXQoZWwubW9kZWwuY2FsbGJhY2ssIFwiLGV4cHJlc3Npb246XCIpLmNvbmNhdChlbC5tb2RlbC5leHByZXNzaW9uLCBcIn0sXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gaW5saW5lLXRlbXBsYXRlXHJcbiAgICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcclxuICAgICAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xyXG4gICAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBkYXRhICs9IFwiXCIuY29uY2F0KGlubGluZVRlbXBsYXRlLCBcIixcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XHJcbiAgICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXHJcbiAgICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxyXG4gICAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxyXG4gICAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xyXG4gICAgICAgIGRhdGEgPSBcIl9iKFwiLmNvbmNhdChkYXRhLCBcIixcXFwiXCIpLmNvbmNhdChlbC50YWcsIFwiXFxcIixcIikuY29uY2F0KGdlblByb3BzKGVsLmR5bmFtaWNBdHRycyksIFwiKVwiKTtcclxuICAgIH1cclxuICAgIC8vIHYtYmluZCBkYXRhIHdyYXBcclxuICAgIGlmIChlbC53cmFwRGF0YSkge1xyXG4gICAgICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcclxuICAgIH1cclxuICAgIC8vIHYtb24gZGF0YSB3cmFwXHJcbiAgICBpZiAoZWwud3JhcExpc3RlbmVycykge1xyXG4gICAgICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpIHtcclxuICAgIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcclxuICAgIGlmICghZGlycylcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XHJcbiAgICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xyXG4gICAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBkaXIgPSBkaXJzW2ldO1xyXG4gICAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcclxuICAgICAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XHJcbiAgICAgICAgaWYgKGdlbikge1xyXG4gICAgICAgICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxyXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXHJcbiAgICAgICAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkUnVudGltZSkge1xyXG4gICAgICAgICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiLmNvbmNhdChkaXIubmFtZSwgXCJcXFwiLHJhd05hbWU6XFxcIlwiKS5jb25jYXQoZGlyLnJhd05hbWUsIFwiXFxcIlwiKS5jb25jYXQoZGlyLnZhbHVlXHJcbiAgICAgICAgICAgICAgICA/IFwiLHZhbHVlOihcIi5jb25jYXQoZGlyLnZhbHVlLCBcIiksZXhwcmVzc2lvbjpcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICA6ICcnKS5jb25jYXQoZGlyLmFyZyA/IFwiLGFyZzpcIi5jb25jYXQoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiBcIlxcXCJcIi5jb25jYXQoZGlyLmFyZywgXCJcXFwiXCIpKSA6ICcnKS5jb25jYXQoZGlyLm1vZGlmaWVycyA/IFwiLG1vZGlmaWVyczpcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpIDogJycsIFwifSxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhc1J1bnRpbWUpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpIHtcclxuICAgIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpKSB7XHJcbiAgICAgICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJywgeyBzdGFydDogZWwuc3RhcnQgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XHJcbiAgICAgICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiLmNvbmNhdChpbmxpbmVSZW5kZXJGbnMucmVuZGVyLCBcIn0sc3RhdGljUmVuZGVyRm5zOltcIikuY29uY2F0KGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gXCJmdW5jdGlvbigpe1wiLmNvbmNhdChjb2RlLCBcIn1cIik7IH0pXHJcbiAgICAgICAgICAgIC5qb2luKCcsJyksIFwiXX1cIik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMoZWwsIHNsb3RzLCBzdGF0ZSkge1xyXG4gICAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcclxuICAgIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxyXG4gICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxyXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxyXG4gICAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSBlbC5mb3IgfHxcclxuICAgICAgICBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNba2V5XTtcclxuICAgICAgICAgICAgcmV0dXJuIChzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8IHNsb3QuaWYgfHwgc2xvdC5mb3IgfHwgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXHJcbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxyXG4gICAgLy8gY29tcGlsZWQgc2xvdCBjb250ZW50LiBUbyBhdm9pZCB0aGF0LCB3ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYmFzZWQgb25cclxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXHJcbiAgICB2YXIgbmVlZHNLZXkgPSAhIWVsLmlmO1xyXG4gICAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXHJcbiAgICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXHJcbiAgICAvLyAjOTQzOCwgIzk1MDZcclxuICAgIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xyXG4gICAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxyXG4gICAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudF8yID0gZWwucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChwYXJlbnRfMikge1xyXG4gICAgICAgICAgICBpZiAoKHBhcmVudF8yLnNsb3RTY29wZSAmJiBwYXJlbnRfMi5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRfMi5mb3IpIHtcclxuICAgICAgICAgICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudF8yLmlmKSB7XHJcbiAgICAgICAgICAgICAgICBuZWVkc0tleSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50XzIgPSBwYXJlbnRfMi5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcclxuICAgICAgICAuam9pbignLCcpO1xyXG4gICAgcmV0dXJuIFwic2NvcGVkU2xvdHM6X3UoW1wiLmNvbmNhdChnZW5lcmF0ZWRTbG90cywgXCJdXCIpLmNvbmNhdChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKS5jb25jYXQoIW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyBcIixudWxsLGZhbHNlLFwiLmNvbmNhdChoYXNoKGdlbmVyYXRlZFNsb3RzKSkgOiBcIlwiLCBcIilcIik7XHJcbn1cclxuZnVuY3Rpb24gaGFzaChzdHIpIHtcclxuICAgIHZhciBoYXNoID0gNTM4MTtcclxuICAgIHZhciBpID0gc3RyLmxlbmd0aDtcclxuICAgIHdoaWxlIChpKSB7XHJcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNoID4+PiAwO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnRhaW5zU2xvdENoaWxkKGVsKSB7XHJcbiAgICBpZiAoZWwudHlwZSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QoZWwsIHN0YXRlKSB7XHJcbiAgICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xyXG4gICAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcclxuICAgICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcclxuICAgICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCk7XHJcbiAgICB9XHJcbiAgICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuID8gXCJcIiA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xyXG4gICAgdmFyIGZuID0gXCJmdW5jdGlvbihcIi5jb25jYXQoc2xvdFNjb3BlLCBcIil7XCIpICtcclxuICAgICAgICBcInJldHVybiBcIi5jb25jYXQoZWwudGFnID09PSAndGVtcGxhdGUnXHJcbiAgICAgICAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcclxuICAgICAgICAgICAgICAgID8gXCIoXCIuY29uY2F0KGVsLmlmLCBcIik/XCIpLmNvbmNhdChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnLCBcIjp1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSwgXCJ9XCIpO1xyXG4gICAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xyXG4gICAgdmFyIHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IFwiXCIgOiBcIixwcm94eTp0cnVlXCI7XHJcbiAgICByZXR1cm4gXCJ7a2V5OlwiLmNvbmNhdChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIsIFwiLGZuOlwiKS5jb25jYXQoZm4pLmNvbmNhdChyZXZlcnNlUHJveHksIFwifVwiKTtcclxufVxyXG5mdW5jdGlvbiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIGNoZWNrU2tpcCwgYWx0R2VuRWxlbWVudCwgYWx0R2VuTm9kZSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGVsXzEgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgIGVsXzEuZm9yICYmXHJcbiAgICAgICAgICAgIGVsXzEudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAgICAgICAgIGVsXzEudGFnICE9PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlXzEgPSBjaGVja1NraXBcclxuICAgICAgICAgICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWxfMSlcclxuICAgICAgICAgICAgICAgICAgICA/IFwiLDFcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogXCIsMFwiXHJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCgoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbF8xLCBzdGF0ZSkpLmNvbmNhdChub3JtYWxpemF0aW9uVHlwZV8xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXHJcbiAgICAgICAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgdmFyIGdlbl8xID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xyXG4gICAgICAgIHJldHVybiBcIltcIi5jb25jYXQoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW5fMShjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSwgXCJdXCIpLmNvbmNhdChub3JtYWxpemF0aW9uVHlwZSA/IFwiLFwiLmNvbmNhdChub3JtYWxpemF0aW9uVHlwZSkgOiAnJyk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxyXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxyXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXHJcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcclxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIG1heWJlQ29tcG9uZW50KSB7XHJcbiAgICB2YXIgcmVzID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcclxuICAgICAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IDI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XHJcbiAgICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcclxuICAgICAgICAgICAgcmVzID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbihlbCkge1xyXG4gICAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90JztcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIHN0YXRlKSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2VuVGV4dChub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5UZXh0KHRleHQpIHtcclxuICAgIHJldHVybiBcIl92KFwiLmNvbmNhdCh0ZXh0LnR5cGUgPT09IDJcclxuICAgICAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXHJcbiAgICAgICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSksIFwiKVwiKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Db21tZW50KGNvbW1lbnQpIHtcclxuICAgIHJldHVybiBcIl9lKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpLCBcIilcIik7XHJcbn1cclxuZnVuY3Rpb24gZ2VuU2xvdChlbCwgc3RhdGUpIHtcclxuICAgIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xyXG4gICAgdmFyIHJlcyA9IFwiX3QoXCIuY29uY2F0KHNsb3ROYW1lKS5jb25jYXQoY2hpbGRyZW4gPyBcIixmdW5jdGlvbigpe3JldHVybiBcIi5jb25jYXQoY2hpbGRyZW4sIFwifVwiKSA6ICcnKTtcclxuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xyXG4gICAgICAgID8gZ2VuUHJvcHMoKGVsLmF0dHJzIHx8IFtdKS5jb25jYXQoZWwuZHluYW1pY0F0dHJzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxyXG4gICAgICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxyXG4gICAgICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcclxuICAgICAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXHJcbiAgICAgICAgfSk7IH0pKVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIHZhciBiaW5kID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xyXG4gICAgaWYgKChhdHRycyB8fCBiaW5kKSAmJiAhY2hpbGRyZW4pIHtcclxuICAgICAgICByZXMgKz0gXCIsbnVsbFwiO1xyXG4gICAgfVxyXG4gICAgaWYgKGF0dHJzKSB7XHJcbiAgICAgICAgcmVzICs9IFwiLFwiLmNvbmNhdChhdHRycyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmluZCkge1xyXG4gICAgICAgIHJlcyArPSBcIlwiLmNvbmNhdChhdHRycyA/ICcnIDogJyxudWxsJywgXCIsXCIpLmNvbmNhdChiaW5kKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXMgKyAnKSc7XHJcbn1cclxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxyXG5mdW5jdGlvbiBnZW5Db21wb25lbnQoY29tcG9uZW50TmFtZSwgZWwsIHN0YXRlKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xyXG4gICAgcmV0dXJuIFwiX2MoXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiLFwiKS5jb25jYXQoZ2VuRGF0YShlbCwgc3RhdGUpKS5jb25jYXQoY2hpbGRyZW4gPyBcIixcIi5jb25jYXQoY2hpbGRyZW4pIDogJycsIFwiKVwiKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Qcm9wcyhwcm9wcykge1xyXG4gICAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcclxuICAgIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xyXG4gICAgICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcclxuICAgICAgICAgICAgZHluYW1pY1Byb3BzICs9IFwiXCIuY29uY2F0KHByb3AubmFtZSwgXCIsXCIpLmNvbmNhdCh2YWx1ZSwgXCIsXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIuY29uY2F0KHByb3AubmFtZSwgXCJcXFwiOlwiKS5jb25jYXQodmFsdWUsIFwiLFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWNQcm9wcyA9IFwie1wiLmNvbmNhdChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSksIFwifVwiKTtcclxuICAgIGlmIChkeW5hbWljUHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gXCJfZChcIi5jb25jYXQoc3RhdGljUHJvcHMsIFwiLFtcIikuY29uY2F0KGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSksIFwiXSlcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc3RhdGljUHJvcHM7XHJcbiAgICB9XHJcbn1cclxuLy8gIzM4OTUsICM0MjY4XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKS5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKTtcclxufVxyXG5cclxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcclxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxyXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArXHJcbiAgICAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXHJcbiAgICAgICAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcclxuICAgICAgICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cycpXHJcbiAgICAgICAgLnNwbGl0KCcsJylcclxuICAgICAgICAuam9pbignXFxcXGJ8XFxcXGInKSArXHJcbiAgICAnXFxcXGInKTtcclxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcclxudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgK1xyXG4gICAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCcuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgK1xyXG4gICAgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcclxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xyXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xyXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxyXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMoYXN0LCB3YXJuKSB7XHJcbiAgICBpZiAoYXN0KSB7XHJcbiAgICAgICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tOb2RlKG5vZGUsIHdhcm4pIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcclxuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gbm9kZS5hdHRyc01hcCkge1xyXG4gICAgICAgICAgICBpZiAoZGlyUkUudGVzdChuYW1lXzEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVfMV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVfMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVfMSA9PT0gJ3YtZm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Zvcihub2RlLCBcInYtZm9yPVxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lXzEgPT09ICd2LXNsb3QnIHx8IG5hbWVfMVswXSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKHZhbHVlLCBcIlwiLmNvbmNhdChuYW1lXzEsIFwiPVxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25SRS50ZXN0KG5hbWVfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgXCJcIi5jb25jYXQobmFtZV8xLCBcIj1cXFwiXCIpLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIFwiXCIuY29uY2F0KG5hbWVfMSwgXCI9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xyXG4gICAgICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tFdmVudChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XHJcbiAgICB2YXIgc3RyaXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XHJcbiAgICB2YXIga2V5d29yZE1hdGNoID0gc3RyaXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XHJcbiAgICBpZiAoa2V5d29yZE1hdGNoICYmIHN0cmlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XHJcbiAgICAgICAgd2FybihcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xyXG4gICAgICAgICAgICBcIlxcXCJcIi5jb25jYXQoa2V5d29yZE1hdGNoWzBdLCBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIikuY29uY2F0KHRleHQudHJpbSgpKSwgcmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrRm9yKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XHJcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcclxuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XHJcbiAgICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcclxuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllcihpZGVudCwgdHlwZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcclxuICAgIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKFwidmFyIFwiLmNvbmNhdChpZGVudCwgXCI9X1wiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJpbnZhbGlkIFwiLmNvbmNhdCh0eXBlLCBcIiBcXFwiXCIpLmNvbmNhdChpZGVudCwgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiKS5jb25jYXQodGV4dC50cmltKCkpLCByYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBGdW5jdGlvbihcInJldHVybiBcIi5jb25jYXQoZXhwKSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHBcclxuICAgICAgICAgICAgLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpXHJcbiAgICAgICAgICAgIC5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcclxuICAgICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJcXFwiXCIuY29uY2F0KGtleXdvcmRNYXRjaFswXSwgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIpLmNvbmNhdCh0ZXh0LnRyaW0oKSksIHJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiLmNvbmNhdChlLm1lc3NhZ2UsIFwiIGluXFxuXFxuXCIpICtcclxuICAgICAgICAgICAgICAgIFwiICAgIFwiLmNvbmNhdChleHAsIFwiXFxuXFxuXCIpICtcclxuICAgICAgICAgICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIuY29uY2F0KHRleHQudHJpbSgpLCBcIlxcblwiKSwgcmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBGdW5jdGlvbihleHAsICcnKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgd2FybihcImludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246IFwiLmNvbmNhdChlLm1lc3NhZ2UsIFwiIGluXFxuXFxuXCIpICtcclxuICAgICAgICAgICAgXCIgICAgXCIuY29uY2F0KGV4cCwgXCJcXG5cXG5cIikgK1xyXG4gICAgICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiLmNvbmNhdCh0ZXh0LnRyaW0oKSwgXCJcXG5cIiksIHJhbmdlKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHJhbmdlID0gMjtcclxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCwgZW5kKSB7XHJcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBzb3VyY2UubGVuZ3RoOyB9XHJcbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcclxuICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcclxuICAgICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goXCJcIi5jb25jYXQoaiArIDEpLmNvbmNhdChyZXBlYXQoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCksIFwifCAgXCIpLmNvbmNhdChsaW5lc1tqXSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQoXCIgXCIsIHBhZCkgKyByZXBlYXQoXCJeXCIsIGxlbmd0aF8xKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzIgPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQoXCJeXCIsIGxlbmd0aF8yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgbikge1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgaWYgKG4gPiAwKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICAgICAgaWYgKG4gJiAxKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcclxuICAgICAgICAgICAgbiA+Pj49IDE7XHJcbiAgICAgICAgICAgIGlmIChuIDw9IDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgc3RyICs9IHN0cjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbihjb2RlLCBlcnJvcnMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xyXG4gICAgICAgIHJldHVybiBub29wO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSkge1xyXG4gICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIG9wdGlvbnMsIHZtKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgd2FybiQyO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgY2FjaGVcclxuICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICA6IHRlbXBsYXRlO1xyXG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21waWxlXHJcbiAgICAgICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIi5jb25jYXQoZS5tc2csIFwiXFxuXFxuXCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksIHZtKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIuY29uY2F0KHRlbXBsYXRlLCBcIlxcblxcblwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFwiLSBcIi5jb25jYXQoZSk7IH0pLmpvaW4oJ1xcbicpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicsIHZtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xyXG4gICAgICAgIHZhciByZXMgPSB7fTtcclxuICAgICAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcclxuICAgICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XHJcbiAgICAgICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cclxuICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxyXG4gICAgICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGZuR2VuRXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBfYS5lcnIsIGNvZGUgPSBfYS5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZXJyLnRvU3RyaW5nKCksIFwiIGluXFxuXFxuXCIpLmNvbmNhdChjb2RlLCBcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJyksIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGJhc2VDb21waWxlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpIHtcclxuICAgICAgICBmdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgdGlwcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcclxuICAgICAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aF8xID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgPyB7IG1zZzogbXNnIH0gOiBtc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGhfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcclxuICAgICAgICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUudHJpbSgpLCBmaW5hbE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCwgd2Fybik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgICAgICAgICBjb21waWxlZC50aXBzID0gdGlwcztcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb21waWxlOiBjb21waWxlLFxyXG4gICAgICAgICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxyXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXHJcbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxyXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xyXG4gICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXN0OiBhc3QsXHJcbiAgICAgICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcclxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXHJcbiAgICB9O1xyXG59KTtcclxuXHJcbnZhciBfYSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKSwgY29tcGlsZVRvRnVuY3Rpb25zID0gX2EuY29tcGlsZVRvRnVuY3Rpb25zO1xyXG5cclxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcclxudmFyIGRpdjtcclxuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlKGhyZWYpIHtcclxuICAgIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcclxuICAgIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwO1xyXG59XHJcbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XHJcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcclxuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxyXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyXHJcbiAgICA/IGdldFNob3VsZERlY29kZSh0cnVlKVxyXG4gICAgOiBmYWxzZTtcclxuXHJcbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgZWwgPSBxdWVyeShpZCk7XHJcbiAgICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MO1xyXG59KTtcclxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XHJcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsLCBoeWRyYXRpbmcpIHtcclxuICAgIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybiQyKFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xyXG4gICAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cclxuICAgIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xyXG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIuY29uY2F0KG9wdGlvbnMudGVtcGxhdGUpLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbCkge1xyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgICAgICAgICAgbWFyaygnY29tcGlsZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXHJcbiAgICAgICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXHJcbiAgICAgICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcclxuICAgICAgICAgICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcclxuICAgICAgICAgICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXHJcbiAgICAgICAgICAgIH0sIHRoaXMpLCByZW5kZXIgPSBfYS5yZW5kZXIsIHN0YXRpY1JlbmRlckZucyA9IF9hLnN0YXRpY1JlbmRlckZucztcclxuICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgICAgICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XHJcbiAgICAgICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdCh0aGlzLl9uYW1lLCBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZyk7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxyXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cclxuICovXHJcbmZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xyXG4gICAgaWYgKGVsLm91dGVySFRNTCkge1xyXG4gICAgICAgIHJldHVybiBlbC5vdXRlckhUTUw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XHJcbiAgICB9XHJcbn1cclxuVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XHJcblxyXG5leHBvcnQgeyBFZmZlY3RTY29wZSwgY29tcHV0ZWQsIGN1c3RvbVJlZiwgVnVlIGFzIGRlZmF1bHQsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlbCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0Q3VycmVudFNjb3BlLCBoLCBpbmplY3QsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG1lcmdlRGVmYXVsdHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2NvcGVEaXNwb3NlLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBwcm92aWRlLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmJDEgYXMgcmVmLCBzZXQsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJpZ2dlclJlZiwgdW5yZWYsIHVzZUF0dHJzLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHVzZUxpc3RlbmVycywgdXNlU2xvdHMsIHZlcnNpb24sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QgfTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///782\n")}}]);