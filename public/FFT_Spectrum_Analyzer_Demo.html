<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFT频谱分析器演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group h3 {
            color: #495057;
            font-size: 1.2em;
            margin-bottom: 10px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group label {
            min-width: 80px;
            font-weight: 500;
            color: #495057;
        }

        .input-group input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .chart-container h3 {
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3em;
        }

        canvas {
            width: 100%;
            height: 300px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .info-panel {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .info-panel h3 {
            color: #1976d2;
            margin-bottom: 15px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .info-item h4 {
            color: #495057;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-item p {
            color: #667eea;
            font-weight: 600;
            font-size: 1.1em;
        }

        .spectrum-info {
            background: #fff3e0;
            border: 1px solid #ffcc02;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .spectrum-info h3 {
            color: #f57c00;
            margin-bottom: 15px;
        }

        .peak-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .peak-item {
            background: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #ffcc02;
        }

        .peak-item .frequency {
            font-weight: 600;
            color: #f57c00;
        }

        .peak-item .magnitude {
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 768px) {
            .visualization {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔬 FFT频谱分析器</h1>
            <p>实时信号分析与频谱显示演示</p>
        </div>

        <div class="content">
            <!-- 控制面板 -->
            <div class="control-panel">
                <div class="control-group">
                    <h3>📡 信号参数</h3>
                    <div class="input-group">
                        <label>采样率:</label>
                        <input type="number" id="sampleRate" value="44100" min="1000" max="192000" step="1000">
                    </div>
                    <div class="input-group">
                        <label>采样点数:</label>
                        <input type="number" id="fftSize" value="2048" min="256" max="16384" step="256">
                    </div>
                    <div class="input-group">
                        <label>窗口类型:</label>
                        <select id="windowType">
                            <option value="hann">汉宁窗 (Hann)</option>
                            <option value="hamming">海明窗 (Hamming)</option>
                            <option value="blackman">布莱克曼窗 (Blackman)</option>
                            <option value="rectangular">矩形窗 (Rectangular)</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>🎵 信号生成</h3>
                    <div class="input-group">
                        <label>频率1:</label>
                        <input type="number" id="freq1" value="440" min="1" max="20000" step="1">
                    </div>
                    <div class="input-group">
                        <label>频率2:</label>
                        <input type="number" id="freq2" value="880" min="1" max="20000" step="1">
                    </div>
                    <div class="input-group">
                        <label>频率3:</label>
                        <input type="number" id="freq3" value="1320" min="1" max="20000" step="1">
                    </div>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="generateSignal()">生成信号</button>
                        <button class="btn btn-success" onclick="startRealTime()">实时分析</button>
                        <button class="btn btn-secondary" onclick="stopRealTime()">停止</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>🎛️ 显示设置</h3>
                    <div class="input-group">
                        <label>显示模式:</label>
                        <select id="displayMode">
                            <option value="magnitude">幅度谱</option>
                            <option value="power">功率谱</option>
                            <option value="db">分贝谱</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Y轴范围:</label>
                        <input type="number" id="yAxisMax" value="1" min="0.1" max="10" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>峰值检测:</label>
                        <input type="checkbox" id="peakDetection" checked>
                    </div>
                </div>
            </div>

            <!-- 加载指示器 -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>正在计算FFT...</p>
            </div>

            <!-- 可视化区域 -->
            <div class="visualization">
                <div class="chart-container">
                    <h3>📈 时域信号</h3>
                    <canvas id="timeCanvas" width="600" height="300"></canvas>
                </div>
                <div class="chart-container">
                    <h3>📊 频域频谱</h3>
                    <canvas id="freqCanvas" width="600" height="300"></canvas>
                </div>
            </div>

            <!-- 信息面板 -->
            <div class="info-panel">
                <h3>📋 分析信息</h3>
                <div class="info-grid">
                    <div class="info-item">
                        <h4>信号长度</h4>
                        <p id="signalLength">0 ms</p>
                    </div>
                    <div class="info-item">
                        <h4>频率分辨率</h4>
                        <p id="freqResolution">0 Hz</p>
                    </div>
                    <div class="info-item">
                        <h4>奈奎斯特频率</h4>
                        <p id="nyquistFreq">0 Hz</p>
                    </div>
                    <div class="info-item">
                        <h4>计算时间</h4>
                        <p id="computeTime">0 ms</p>
                    </div>
                </div>
            </div>

            <!-- 频谱峰值信息 -->
            <div class="spectrum-info">
                <h3>🔍 检测到的峰值</h3>
                <div class="peak-list" id="peakList">
                    <div class="peak-item">
                        <div class="frequency">无峰值</div>
                        <div class="magnitude">-</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // FFT频谱分析器类
        class FFTSpectrumAnalyzer {
            constructor() {
                this.sampleRate = 44100;
                this.fftSize = 2048;
                this.windowType = 'hann';
                this.displayMode = 'magnitude';
                this.yAxisMax = 1;
                this.peakDetection = true;
                
                this.timeCanvas = document.getElementById('timeCanvas');
                this.freqCanvas = document.getElementById('freqCanvas');
                this.timeCtx = this.timeCanvas.getContext('2d');
                this.freqCtx = this.freqCanvas.getContext('2d');
                
                this.signal = [];
                this.spectrum = [];
                this.frequencies = [];
                this.realTimeMode = false;
                this.animationId = null;
                
                this.initializeEventListeners();
                this.updateInfo();
            }

            // 初始化事件监听器
            initializeEventListeners() {
                // 参数变化监听
                ['sampleRate', 'fftSize', 'windowType', 'displayMode', 'yAxisMax', 'peakDetection'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => {
                        this[id] = document.getElementById(id).type === 'checkbox' ? 
                            document.getElementById(id).checked : 
                            parseFloat(document.getElementById(id).value) || document.getElementById(id).value;
                        this.updateInfo();
                        if (this.signal.length > 0) {
                            this.analyzeSignal();
                        }
                    });
                });
            }

            // 生成测试信号
            generateSignal() {
                const freq1 = parseFloat(document.getElementById('freq1').value);
                const freq2 = parseFloat(document.getElementById('freq2').value);
                const freq3 = parseFloat(document.getElementById('freq3').value);
                
                this.signal = [];
                const duration = this.fftSize / this.sampleRate;
                
                for (let i = 0; i < this.fftSize; i++) {
                    const t = i / this.sampleRate;
                    const signal1 = Math.sin(2 * Math.PI * freq1 * t);
                    const signal2 = Math.sin(2 * Math.PI * freq2 * t) * 0.7;
                    const signal3 = Math.sin(2 * Math.PI * freq3 * t) * 0.5;
                    
                    // 添加一些噪声
                    const noise = (Math.random() - 0.5) * 0.1;
                    
                    this.signal.push(signal1 + signal2 + signal3 + noise);
                }
                
                this.analyzeSignal();
                this.drawTimeDomain();
            }

                         // 分析信号
             analyzeSignal() {
                 const startTime = performance.now();
                 
                 // 应用窗口函数
                 const windowedSignal = this.applyWindow(this.signal);
                 
                 // 计算FFT
                 const fft = this.computeFFT(windowedSignal);
                 
                 // 计算频谱
                 this.spectrum = this.computeSpectrum(fft);
                 
                 // 计算频率轴
                 this.frequencies = this.computeFrequencies();
                 
                 // 更新计算时间
                 const endTime = performance.now();
                 document.getElementById('computeTime').textContent = `${(endTime - startTime).toFixed(2)} ms`;
                 
                 // 添加调试信息
                 console.log('FFT分析结果:', {
                     signalLength: this.signal.length,
                     fftLength: fft.length,
                     spectrumLength: this.spectrum.length,
                     frequenciesLength: this.frequencies.length,
                     maxSpectrum: Math.max(...this.spectrum),
                     minSpectrum: Math.min(...this.spectrum)
                 });
                 
                 this.drawFrequencyDomain();
                 this.detectPeaks();
             }

            // 应用窗口函数
            applyWindow(signal) {
                const windowed = new Array(signal.length);
                
                for (let i = 0; i < signal.length; i++) {
                    let windowValue = 1;
                    const normalizedIndex = i / (signal.length - 1);
                    
                    switch (this.windowType) {
                        case 'hann':
                            windowValue = 0.5 * (1 - Math.cos(2 * Math.PI * normalizedIndex));
                            break;
                        case 'hamming':
                            windowValue = 0.54 - 0.46 * Math.cos(2 * Math.PI * normalizedIndex);
                            break;
                        case 'blackman':
                            windowValue = 0.42 - 0.5 * Math.cos(2 * Math.PI * normalizedIndex) + 
                                         0.08 * Math.cos(4 * Math.PI * normalizedIndex);
                            break;
                        case 'rectangular':
                        default:
                            windowValue = 1;
                            break;
                    }
                    
                    windowed[i] = signal[i] * windowValue;
                }
                
                return windowed;
            }

                         // 计算FFT（使用JavaScript实现的FFT算法）
             computeFFT(signal) {
                 const n = signal.length;
                 
                 // 确保信号长度是2的幂次
                 if ((n & (n - 1)) !== 0) {
                     console.warn('信号长度不是2的幂次，可能影响FFT性能');
                 }
                 
                 // 创建复数数组
                 const complex = new Array(n);
                 for (let i = 0; i < n; i++) {
                     complex[i] = { real: signal[i], imag: 0 };
                 }
                 
                 // 执行FFT
                 this.fft(complex);
                 
                 // 计算幅度
                 const magnitudes = new Array(n / 2);
                 for (let i = 0; i < n / 2; i++) {
                     magnitudes[i] = Math.sqrt(complex[i].real * complex[i].real + complex[i].imag * complex[i].imag);
                 }
                 
                 return magnitudes;
             }
             
             // FFT算法实现
             fft(complex) {
                 const n = complex.length;
                 
                 // 位反转
                 for (let i = 1, j = 0; i < n; i++) {
                     let bit = n >> 1;
                     for (; j & bit; bit >>= 1) {
                         j ^= bit;
                     }
                     j ^= bit;
                     
                     if (i < j) {
                         [complex[i], complex[j]] = [complex[j], complex[i]];
                     }
                 }
                 
                 // 蝶形运算
                 for (let len = 2; len <= n; len <<= 1) {
                     const angle = -2 * Math.PI / len;
                     const wlen_real = Math.cos(angle);
                     const wlen_imag = Math.sin(angle);
                     
                     for (let i = 0; i < n; i += len) {
                         let w_real = 1;
                         let w_imag = 0;
                         
                         for (let j = 0; j < len / 2; j++) {
                             const u_real = complex[i + j].real;
                             const u_imag = complex[i + j].imag;
                             const v_real = complex[i + j + len / 2].real * w_real - complex[i + j + len / 2].imag * w_imag;
                             const v_imag = complex[i + j + len / 2].real * w_imag + complex[i + j + len / 2].imag * w_real;
                             
                             complex[i + j].real = u_real + v_real;
                             complex[i + j].imag = u_imag + v_imag;
                             complex[i + j + len / 2].real = u_real - v_real;
                             complex[i + j + len / 2].imag = u_imag - v_imag;
                             
                             const next_w_real = w_real * wlen_real - w_imag * wlen_imag;
                             const next_w_imag = w_real * wlen_imag + w_imag * wlen_real;
                             w_real = next_w_real;
                             w_imag = next_w_imag;
                         }
                     }
                 }
             }

                         // 计算频谱
             computeSpectrum(fft) {
                 const spectrum = [];
                 const binCount = fft.length;
                 
                 // 应用窗口函数的补偿因子
                 let windowCompensation = 1;
                 switch (this.windowType) {
                     case 'hann':
                         windowCompensation = 2;
                         break;
                     case 'hamming':
                         windowCompensation = 1.85;
                         break;
                     case 'blackman':
                         windowCompensation = 2.8;
                         break;
                     case 'rectangular':
                     default:
                         windowCompensation = 1;
                         break;
                 }
                 
                 for (let i = 0; i < binCount; i++) {
                     let value;
                     
                     // 应用窗口补偿
                     const compensatedValue = fft[i] * windowCompensation;
                     
                     switch (this.displayMode) {
                         case 'magnitude':
                             value = compensatedValue;
                             break;
                         case 'power':
                             value = compensatedValue ** 2;
                             break;
                         case 'db':
                             value = 20 * Math.log10(compensatedValue + 1e-10);
                             break;
                         default:
                             value = compensatedValue;
                     }
                     
                     spectrum.push(value);
                 }
                 
                 return spectrum;
             }

                         // 计算频率轴
             computeFrequencies() {
                 const frequencies = [];
                 const binCount = this.spectrum.length;
                 
                 for (let i = 0; i < binCount; i++) {
                     // FFT结果只包含到奈奎斯特频率
                     const frequency = i * this.sampleRate / this.fftSize;
                     frequencies.push(frequency);
                 }
                 
                 return frequencies;
             }

                         // 检测峰值
             detectPeaks() {
                 if (!this.peakDetection || !this.spectrum || this.spectrum.length === 0) return;
                 
                 const peaks = [];
                 const maxValue = Math.max(...this.spectrum);
                 const threshold = maxValue * 0.05; // 降低阈值以检测更多峰值
                 
                 // 寻找局部最大值
                 for (let i = 2; i < this.spectrum.length - 2; i++) {
                     const current = this.spectrum[i];
                     
                     // 检查是否是局部最大值
                     if (current > threshold &&
                         current > this.spectrum[i - 1] &&
                         current > this.spectrum[i - 2] &&
                         current > this.spectrum[i + 1] &&
                         current > this.spectrum[i + 2]) {
                         
                         peaks.push({
                             frequency: this.frequencies[i],
                             magnitude: current,
                             index: i
                         });
                     }
                 }
                 
                 // 按幅度排序，取前5个峰值
                 peaks.sort((a, b) => b.magnitude - a.magnitude);
                 peaks.splice(5);
                 
                 this.displayPeaks(peaks);
             }

            // 显示峰值
            displayPeaks(peaks) {
                const peakList = document.getElementById('peakList');
                
                if (peaks.length === 0) {
                    peakList.innerHTML = '<div class="peak-item"><div class="frequency">无峰值</div><div class="magnitude">-</div></div>';
                    return;
                }
                
                peakList.innerHTML = peaks.map(peak => `
                    <div class="peak-item">
                        <div class="frequency">${peak.frequency.toFixed(1)} Hz</div>
                        <div class="magnitude">${peak.magnitude.toFixed(3)}</div>
                    </div>
                `).join('');
            }

            // 绘制时域信号
            drawTimeDomain() {
                const ctx = this.timeCtx;
                const width = this.timeCanvas.width;
                const height = this.timeCanvas.height;
                
                // 清除画布
                ctx.clearRect(0, 0, width, height);
                
                // 绘制网格
                this.drawGrid(ctx, width, height, 'time');
                
                // 绘制信号
                ctx.beginPath();
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                
                const timeStep = width / this.signal.length;
                const amplitudeScale = height / 4;
                const centerY = height / 2;
                
                for (let i = 0; i < this.signal.length; i++) {
                    const x = i * timeStep;
                    const y = centerY - this.signal[i] * amplitudeScale;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // 绘制标签
                ctx.fillStyle = '#495057';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('时间 (ms)', width / 2, height - 10);
                
                ctx.save();
                ctx.translate(10, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('幅度', 0, 0);
                ctx.restore();
            }

                         // 绘制频域频谱
             drawFrequencyDomain() {
                 const ctx = this.freqCtx;
                 const width = this.freqCanvas.width;
                 const height = this.freqCanvas.height;
                 
                 // 清除画布
                 ctx.clearRect(0, 0, width, height);
                 
                 // 绘制网格
                 this.drawGrid(ctx, width, height, 'frequency');
                 
                 // 检查是否有频谱数据
                 if (!this.spectrum || this.spectrum.length === 0) {
                     ctx.fillStyle = '#666';
                     ctx.font = '16px Arial';
                     ctx.textAlign = 'center';
                     ctx.fillText('无频谱数据', width / 2, height / 2);
                     return;
                 }
                 
                 // 绘制频谱
                 ctx.beginPath();
                 ctx.strokeStyle = '#28a745';
                 ctx.lineWidth = 2;
                 
                 const freqStep = width / this.spectrum.length;
                 const maxValue = Math.max(...this.spectrum);
                 const minValue = Math.min(...this.spectrum);
                 
                 // 计算缩放因子
                 let amplitudeScale;
                 if (this.displayMode === 'db') {
                     const range = maxValue - minValue;
                     amplitudeScale = height / (range * this.yAxisMax);
                 } else {
                     amplitudeScale = height / (maxValue * this.yAxisMax);
                 }
                 
                 for (let i = 0; i < this.spectrum.length; i++) {
                     const x = i * freqStep;
                     let y;
                     
                     if (this.displayMode === 'db') {
                         y = height - (this.spectrum[i] - minValue) * amplitudeScale;
                     } else {
                         y = height - this.spectrum[i] * amplitudeScale;
                     }
                     
                     if (i === 0) {
                         ctx.moveTo(x, y);
                     } else {
                         ctx.lineTo(x, y);
                     }
                 }
                 
                 ctx.stroke();
                 
                 // 绘制频率标签
                 ctx.fillStyle = '#495057';
                 ctx.font = '12px Arial';
                 ctx.textAlign = 'center';
                 
                 // 绘制频率刻度
                 const maxFreq = this.frequencies[this.frequencies.length - 1];
                 for (let i = 0; i <= 5; i++) {
                     const freq = (i / 5) * maxFreq;
                     const x = (i / 5) * width;
                     ctx.fillText(`${freq.toFixed(0)}Hz`, x, height - 5);
                 }
                 
                 // 绘制Y轴标签
                 ctx.save();
                 ctx.translate(10, height / 2);
                 ctx.rotate(-Math.PI / 2);
                 ctx.fillText(this.displayMode === 'db' ? '幅度 (dB)' : '幅度', 0, 0);
                 ctx.restore();
                 
                 // 显示最大值信息
                 ctx.fillStyle = '#28a745';
                 ctx.font = '10px Arial';
                 ctx.textAlign = 'left';
                 ctx.fillText(`最大: ${maxValue.toFixed(3)}`, 10, 20);
             }

            // 绘制网格
            drawGrid(ctx, width, height, type) {
                ctx.strokeStyle = '#e9ecef';
                ctx.lineWidth = 1;
                
                // 垂直网格线
                const vLines = type === 'time' ? 10 : 20;
                for (let i = 0; i <= vLines; i++) {
                    const x = (i / vLines) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // 水平网格线
                const hLines = 8;
                for (let i = 0; i <= hLines; i++) {
                    const y = (i / hLines) * height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }

            // 更新信息面板
            updateInfo() {
                const signalLength = (this.fftSize / this.sampleRate) * 1000;
                const freqResolution = this.sampleRate / this.fftSize;
                const nyquistFreq = this.sampleRate / 2;
                
                document.getElementById('signalLength').textContent = `${signalLength.toFixed(1)} ms`;
                document.getElementById('freqResolution').textContent = `${freqResolution.toFixed(2)} Hz`;
                document.getElementById('nyquistFreq').textContent = `${nyquistFreq.toFixed(0)} Hz`;
            }

            // 开始实时分析
            startRealTime() {
                if (this.realTimeMode) return;
                
                this.realTimeMode = true;
                this.animate();
            }

            // 停止实时分析
            stopRealTime() {
                this.realTimeMode = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            // 动画循环
            animate() {
                if (!this.realTimeMode) return;
                
                // 生成实时信号
                this.generateRealTimeSignal();
                this.analyzeSignal();
                this.drawTimeDomain();
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }

            // 生成实时信号
            generateRealTimeSignal() {
                const freq1 = parseFloat(document.getElementById('freq1').value);
                const freq2 = parseFloat(document.getElementById('freq2').value);
                const freq3 = parseFloat(document.getElementById('freq3').value);
                
                this.signal = [];
                const time = Date.now() / 1000;
                
                for (let i = 0; i < this.fftSize; i++) {
                    const t = time + i / this.sampleRate;
                    const signal1 = Math.sin(2 * Math.PI * freq1 * t);
                    const signal2 = Math.sin(2 * Math.PI * freq2 * t) * 0.7;
                    const signal3 = Math.sin(2 * Math.PI * freq3 * t) * 0.5;
                    
                    // 添加一些噪声
                    const noise = (Math.random() - 0.5) * 0.1;
                    
                    this.signal.push(signal1 + signal2 + signal3 + noise);
                }
            }
        }

        // 全局变量
        let analyzer;

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            analyzer = new FFTSpectrumAnalyzer();
            
            // 设置初始值
            analyzer.sampleRate = parseFloat(document.getElementById('sampleRate').value);
            analyzer.fftSize = parseInt(document.getElementById('fftSize').value);
            analyzer.windowType = document.getElementById('windowType').value;
            analyzer.displayMode = document.getElementById('displayMode').value;
            analyzer.yAxisMax = parseFloat(document.getElementById('yAxisMax').value);
            analyzer.peakDetection = document.getElementById('peakDetection').checked;
            
            // 生成初始信号
            analyzer.generateSignal();
        });

        // 全局函数
        function generateSignal() {
            analyzer.generateSignal();
        }

        function startRealTime() {
            analyzer.startRealTime();
        }

        function stopRealTime() {
            analyzer.stopRealTime();
        }

        // 显示加载状态
        function showLoading() {
            document.getElementById('loading').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loading').classList.remove('show');
        }

        // 错误处理
        window.addEventListener('error', (e) => {
            console.error('FFT分析器错误:', e.error);
            alert('发生错误: ' + e.error.message);
        });

        // 页面卸载时清理资源
        window.addEventListener('beforeunload', () => {
            if (analyzer) {
                analyzer.stopRealTime();
            }
        });
    </script>
</body>
</html>
